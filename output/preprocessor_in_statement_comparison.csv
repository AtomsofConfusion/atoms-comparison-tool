Type,File,Line,CLJ,CQL,CLJ_Code,CQL_Column,CQL_Code
preprocessor_in_statement,blame.c,1663,+,+,"{
    int sim, p_idx;
    int best_sim_val = FINGERPRINT_FILE_THRESHOLD;
    int best_sim_idx = -1;
    for (p_idx = from;p_idx < from + nr_lines;p_idx++){
        sim = fingerprint_similarity(&t_fps[t_idx], &p_fps[p_idx]);
        if (sim < best_sim_val)
            continue;

        if (sim == best_sim_val && best_sim_idx != -1 && abs(best_sim_idx - t_idx) < abs(p_idx - t_idx))
            continue;

        best_sim_val = sim;
        best_sim_idx = p_idx;
    }
    return best_sim_idx;
}
",,"{
	int sim, p_idx;
	#define FINGERPRINT_FILE_THRESHOLD	10
	int best_sim_val = FINGERPRINT_FILE_THRESHOLD;
	int best_sim_idx = -1;

	for (p_idx = from; p_idx < from + nr_lines; p_idx++) {
		sim = fingerprint_similarity(&t_fps[t_idx], &p_fps[p_idx]);
		if (sim < best_sim_val)
			continue;
		/* Break ties with the closest-to-target line number */
		if (sim == best_sim_val && best_sim_idx != -1 &&
		    abs(best_sim_idx - t_idx) < abs(p_idx - t_idx))
			continue;
		best_sim_val = sim;
		best_sim_idx = p_idx;
	}
	return best_sim_idx;
}"
preprocessor_in_statement,color.c,193,-,+,,,"{
	static const struct {
		const char *name;
		size_t len;
		int val, neg;
	} attrs[] = {
#define ATTR(x, val, neg) { (x), sizeof(x)-1, (val), (neg) }
		ATTR(""bold"",      1, 22),
		ATTR(""dim"",       2, 22),
		ATTR(""italic"",    3, 23),
		ATTR(""ul"",        4, 24),
		ATTR(""blink"",     5, 25),
		ATTR(""reverse"",   7, 27),
		ATTR(""strike"",    9, 29)
#undef ATTR
	};
	int negate = 0;
	int i;

	if (skip_prefix_mem(name, len, ""no"", &name, &len)) {
		skip_prefix_mem(name, len, ""-"", &name, &len);
		negate = 1;
	}

	for (i = 0; i < ARRAY_SIZE(attrs); i++) {
		if (attrs[i].len == len && !memcmp(attrs[i].name, name, len))
			return negate ? attrs[i].neg : attrs[i].val;
	}
	return -1;
}"
preprocessor_in_statement,color.c,266,+,+,"{
    const char* ptr = value;
    int len = value_len;
    char* end = dst + COLOR_MAXLEN;
    unsigned int has_reset = 0;
    unsigned int attr = 0;
    struct color fg = {COLOR_UNSPECIFIED};
    struct color bg = {COLOR_UNSPECIFIED};
    while (len > 0 && isspace(*ptr)){
        ptr++;
        len--;
    }
    if (!len){
        dst[0] = '\0';
        return 0;
    }
    while (len > 0){
        const char* word = ptr;
        struct color c = {COLOR_UNSPECIFIED};
        int val, wordlen = 0;
        while (len > 0 && !isspace(word[wordlen])){
            wordlen++;
            len--;
        }
        ptr = word + wordlen;
        while (len > 0 && isspace(*ptr)){
            ptr++;
            len--;
        }
        if (match_word(word, wordlen, ""reset"")){
            has_reset = 1;
            continue;
        }
        if (!parse_color(&c, word, wordlen)){
            if (fg.type == COLOR_UNSPECIFIED){
                fg = c;
                continue;
            }
            if (bg.type == COLOR_UNSPECIFIED){
                bg = c;
                continue;
            }
            goto bad;
        }
        val = parse_attr(word, wordlen);
        if (0 <= val)
            attr |= (1 << val);
        else
            goto bad;
    }
    if (has_reset || attr || !color_empty(&fg) || !color_empty(&bg)){
        int sep = 0;
        int i;
        OUT('\033');
        OUT('[');
        if (has_reset)
            sep++;

        for (i = 0;attr;i++){
            unsigned bit = (1 << i);
            if (!(attr & bit))
                continue;

            attr &= ~bit;
            if (sep++)
                OUT(';');

            dst += xsnprintf(dst, end - dst, ""%d"", i);
        }
        if (!color_empty(&fg)){
            if (sep++)
                OUT(';');

            dst = color_output(dst, end - dst, &fg, 0);
        }
        if (!color_empty(&bg)){
            if (sep++)
                OUT(';');

            dst = color_output(dst, end - dst, &bg, 1);
        }
        OUT('m');
    }
    OUT(0);
    return 0;
    bad:
    return error(_(""invalid color value: %.*s""), value_len, value);
}
",,"{
	const char *ptr = value;
	int len = value_len;
	char *end = dst + COLOR_MAXLEN;
	unsigned int has_reset = 0;
	unsigned int attr = 0;
	struct color fg = { COLOR_UNSPECIFIED };
	struct color bg = { COLOR_UNSPECIFIED };

	while (len > 0 && isspace(*ptr)) {
		ptr++;
		len--;
	}

	if (!len) {
		dst[0] = '\0';
		return 0;
	}

	/* [reset] [fg [bg]] [attr]... */
	while (len > 0) {
		const char *word = ptr;
		struct color c = { COLOR_UNSPECIFIED };
		int val, wordlen = 0;

		while (len > 0 && !isspace(word[wordlen])) {
			wordlen++;
			len--;
		}

		ptr = word + wordlen;
		while (len > 0 && isspace(*ptr)) {
			ptr++;
			len--;
		}

		if (match_word(word, wordlen, ""reset"")) {
			has_reset = 1;
			continue;
		}

		if (!parse_color(&c, word, wordlen)) {
			if (fg.type == COLOR_UNSPECIFIED) {
				fg = c;
				continue;
			}
			if (bg.type == COLOR_UNSPECIFIED) {
				bg = c;
				continue;
			}
			goto bad;
		}
		val = parse_attr(word, wordlen);
		if (0 <= val)
			attr |= (1 << val);
		else
			goto bad;
	}

#undef OUT
#define OUT(x) do { \
	if (dst == end) \
		BUG(""color parsing ran out of space""); \
	*dst++ = (x); \
} while(0)

	if (has_reset || attr || !color_empty(&fg) || !color_empty(&bg)) {
		int sep = 0;
		int i;

		OUT('\033');
		OUT('[');

		if (has_reset)
			sep++;

		for (i = 0; attr; i++) {
			unsigned bit = (1 << i);
			if (!(attr & bit))
				continue;
			attr &= ~bit;
			if (sep++)
				OUT(';');
			dst += xsnprintf(dst, end - dst, ""%d"", i);
		}
		if (!color_empty(&fg)) {
			if (sep++)
				OUT(';');
			dst = color_output(dst, end - dst, &fg, 0);
		}
		if (!color_empty(&bg)) {
			if (sep++)
				OUT(';');
			dst = color_output(dst, end - dst, &bg, 1);
		}
		OUT('m');
	}
	OUT(0);
	return 0;
bad:
	return error(_(""invalid color value: %.*s""), value_len, value);
#undef OUT
}"
preprocessor_in_statement,credential.c,88,+,+,"{
    return CHECK(protocol) && CHECK(host) && CHECK(path) && CHECK(username) && (!match_password || CHECK(password)) && (!match_password || CHECK(credential));
}
",,"{
#define CHECK(x) (!want->x || (have->x && !strcmp(want->x, have->x)))
	return CHECK(protocol) &&
	       CHECK(host) &&
	       CHECK(path) &&
	       CHECK(username) &&
	       (!match_password || CHECK(password)) &&
	       (!match_password || CHECK(credential));
#undef CHECK
}"
preprocessor_in_statement,flush.c,6,+,-,<!!!>,,
preprocessor_in_statement,ipc-win32.c,659,+,-,"{
    SID_IDENTIFIER_AUTHORITY sid_auth_world = SECURITY_WORLD_SID_AUTHORITY;
    EXPLICIT_ACCESS ea[NR_EA];
    DWORD dwResult;
    if (!AllocateAndInitializeSid(&sid_auth_world, 1, SECURITY_WORLD_RID, 0, 0, 0, 0, 0, 0, 0, &d->pEveryoneSID)){
        DWORD gle = GetLastError();
        trace2_data_intmax(""ipc-debug"", NULL, ""alloc-world-sid/gle"", (intmax_t)gle);
        goto fail;
    }
    memset(ea, 0, NR_EA * sizeof (EXPLICIT_ACCESS));
    ea[0].grfAccessPermissions = GENERIC_READ | GENERIC_WRITE;
    ea[0].grfAccessMode = SET_ACCESS;
    ea[0].grfInheritance = NO_INHERITANCE;
    ea[0].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ea[0].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
    ea[0].Trustee.ptstrName = (LPTSTR)d->pEveryoneSID;
    dwResult = SetEntriesInAcl(NR_EA, ea, NULL, &d->pACL);
    if (dwResult != ERROR_SUCCESS){
        DWORD gle = GetLastError();
        trace2_data_intmax(""ipc-debug"", NULL, ""set-acl-entry/gle"", (intmax_t)gle);
        trace2_data_intmax(""ipc-debug"", NULL, ""set-acl-entry/dw"", (intmax_t)dwResult);
        goto fail;
    }
    d->pSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH);
    if (!InitializeSecurityDescriptor(d->pSD, SECURITY_DESCRIPTOR_REVISION)){
        DWORD gle = GetLastError();
        trace2_data_intmax(""ipc-debug"", NULL, ""init-sd/gle"", (intmax_t)gle);
        goto fail;
    }
    if (!SetSecurityDescriptorDacl(d->pSD, TRUE, d->pACL, FALSE)){
        DWORD gle = GetLastError();
        trace2_data_intmax(""ipc-debug"", NULL, ""set-sd-dacl/gle"", (intmax_t)gle);
        goto fail;
    }
    d->lpSA = (LPSECURITY_ATTRIBUTES)LocalAlloc(LPTR, sizeof (SECURITY_ATTRIBUTES));
    d->lpSA->nLength = sizeof (SECURITY_ATTRIBUTES);
    d->lpSA->lpSecurityDescriptor = d->pSD;
    d->lpSA->bInheritHandle = FALSE;
    return d->lpSA;
    fail:
    release_sa(d);
    return NULL;
}
",,
preprocessor_in_statement,malloc.c.h,4797,+,-,"{
    mchunkptr p = mem2chunk(mem);
    if (!PREACTION(fm)){
        ;
        if (RTCHECK(ok_address(fm, p) && ok_cinuse(p))){
            size_t psize = chunksize(p);
            mchunkptr next = chunk_plus_offset(p, psize);
            if (!pinuse(p)){
                size_t prevsize = p->prev_foot;
                if ((prevsize & IS_MMAPPED_BIT) != 0){
                    prevsize &= ~IS_MMAPPED_BIT;
                    psize += prevsize + MMAP_FOOT_PAD;
                    if (CALL_MUNMAP((char*)p - prevsize, psize) == 0)
                        fm->footprint -= psize;

                    goto postaction;
                }else{
                    mchunkptr prev = chunk_minus_offset(p, prevsize);
                    psize += prevsize;
                    p = prev;
                    if (RTCHECK(ok_address(fm, prev))){
                        if (p != fm->dv){
                            unlink_chunk(fm, p, prevsize);
                        }else
                            if ((next->head & INUSE_BITS) == INUSE_BITS){
                                fm->dvsize = psize;
                                set_free_with_pinuse(p, psize, next);
                                goto postaction;
                            }
                    }else
                        goto erroraction;
                }
            }
            if (RTCHECK(ok_next(p, next) && ok_pinuse(next))){
                if (!cinuse(next)){
                    if (next == fm->top){
                        size_t tsize = fm->topsize += psize;
                        fm->top = p;
                        p->head = tsize | PINUSE_BIT;
                        if (p == fm->dv){
                            fm->dv = 0;
                            fm->dvsize = 0;
                        }
                        if (should_trim(fm, tsize))
                            sys_trim(fm, 0);

                        goto postaction;
                    }else
                        if (next == fm->dv){
                            size_t dsize = fm->dvsize += psize;
                            fm->dv = p;
                            set_size_and_pinuse_of_free_chunk(p, dsize);
                            goto postaction;
                        }else{
                            size_t nsize = chunksize(next);
                            psize += nsize;
                            unlink_chunk(fm, next, nsize);
                            set_size_and_pinuse_of_free_chunk(p, psize);
                            if (p == fm->dv){
                                fm->dvsize = psize;
                                goto postaction;
                            }
                        }
                }else
                    set_free_with_pinuse(p, psize, next);

                if (is_small(psize)){
                    insert_small_chunk(fm, p, psize);
                    ;
                }else{
                    tchunkptr tp = (tchunkptr)p;
                    insert_large_chunk(fm, tp, psize);
                    ;
                    if (--fm->release_checks == 0)
                        release_unused_segments(fm);
                }
                goto postaction;
            }
        }
        erroraction:
        USAGE_ERROR_ACTION(fm, p);
        postaction:
      POSTACTION(fm);
    }
}
",,
preprocessor_in_statement,merge-tree.c,219,+,+,"{
    struct repository* r = the_repository;
    char* newbase;
    struct name_entry* p;
    struct tree_desc t[3];
    void *buf0, *buf1, *buf2;
    for (p = n;p < n + 3;p++){
        if (p->mode && S_ISDIR(p->mode))
            break;
    }
    if (n + 3 <= p)
        return;

    newbase = traverse_path(info, p);
    buf0 = fill_tree_descriptor(r, t + 0, ENTRY_OID(n + 0));
    buf1 = fill_tree_descriptor(r, t + 1, ENTRY_OID(n + 1));
    buf2 = fill_tree_descriptor(r, t + 2, ENTRY_OID(n + 2));
    trivial_merge_trees(t, newbase);
    free(buf0);
    free(buf1);
    free(buf2);
    free(newbase);
}
",,"{
	struct repository *r = the_repository;
	char *newbase;
	struct name_entry *p;
	struct tree_desc t[3];
	void *buf0, *buf1, *buf2;

	for (p = n; p < n + 3; p++) {
		if (p->mode && S_ISDIR(p->mode))
			break;
	}
	if (n + 3 <= p)
		return; /* there is no tree here */

	newbase = traverse_path(info, p);

#define ENTRY_OID(e) (((e)->mode && S_ISDIR((e)->mode)) ? &(e)->oid : NULL)
	buf0 = fill_tree_descriptor(r, t + 0, ENTRY_OID(n + 0));
	buf1 = fill_tree_descriptor(r, t + 1, ENTRY_OID(n + 1));
	buf2 = fill_tree_descriptor(r, t + 2, ENTRY_OID(n + 2));
#undef ENTRY_OID

	trivial_merge_trees(t, newbase);

	free(buf0);
	free(buf1);
	free(buf2);
	free(newbase);
}"
preprocessor_in_statement,mingw.c,1953,+,-,"{
    static char* values[GETENV_MAX_RETAIN];
    static int value_counter;
    int len_key, len_value;
    wchar_t* w_key;
    char* value;
    wchar_t w_value[32768];
    if (!name || !*name)
        return NULL;

    len_key = strlen(name) + 1;
    w_key = calloc(len_key, sizeof (wchar_t));
    if (!w_key)
        die(""Out of memory, (tried to allocate %u wchar_t's)"", len_key);

    xutftowcs(w_key, name, len_key);
    SetLastError (ERROR_SUCCESS);
    len_value = GetEnvironmentVariableW(w_key, w_value, ARRAY_SIZE(w_value));
    if (!len_value && GetLastError() == ERROR_ENVVAR_NOT_FOUND){
        free(w_key);
        return NULL;
    }
    free(w_key);
    len_value = len_value * 3 + 1;
    value = calloc(len_value, sizeof (char));
    if (!value)
        die(""Out of memory, (tried to allocate %u bytes)"", len_value);

    xwcstoutf(value, w_value, len_value);
    free(values[value_counter]);
    values[value_counter++] = value;
    if (value_counter >= ARRAY_SIZE(values))
        value_counter = 0;

    return value;
}
",,
preprocessor_in_statement,name-rev.c,515,-,+,,,"{
	struct strbuf buf = STRBUF_INIT;
	int counter = 0;
	char *p_start;
	const unsigned hexsz = the_hash_algo->hexsz;

	for (p_start = p; *p; p++) {
#define ishex(x) (isdigit((x)) || ((x) >= 'a' && (x) <= 'f'))
		if (!ishex(*p))
			counter = 0;
		else if (++counter == hexsz &&
			 !ishex(*(p+1))) {
			struct object_id oid;
			const char *name = NULL;
			char c = *(p+1);
			int p_len = p - p_start + 1;

			counter = 0;

			*(p+1) = 0;
			if (!repo_get_oid(the_repository, p - (hexsz - 1), &oid)) {
				struct object *o =
					lookup_object(the_repository, &oid);
				if (o)
					name = get_rev_name(o, &buf);
			}
			*(p+1) = c;

			if (!name)
				continue;

			if (data->name_only)
				printf(""%.*s%s"", p_len - hexsz, p_start, name);
			else
				printf(""%.*s (%s)"", p_len, p_start, name);
			p_start = p + 1;
		}
	}

	/* flush */
	if (p_start != p)
		fwrite(p_start, p - p_start, 1, stdout);

	strbuf_release(&buf);
}"
preprocessor_in_statement,name-rev.c,521,+,-,"{
    if (!ishex(*p))
        counter = 0;
    else
        if (++counter == hexsz && !ishex(*(p+1))){
            struct object_id oid;
            const char* name = NULL;
            char c = *(p + 1);
            int p_len = p - p_start + 1;
            counter = 0;
            *(p + 1) = 0;
            if (!repo_get_oid(the_repository, p - (hexsz - 1), &oid)){
                struct object* o = lookup_object(the_repository, &oid);
                if (o)
                    name = get_rev_name(o, &buf);
            }
            *(p + 1) = c;
            if (!name)
                continue;

            if (data->name_only)
                printf(""%.*s%s"", p_len - hexsz, p_start, name);
            else
                printf(""%.*s (%s)"", p_len, p_start, name);

            p_start = p + 1;
        }
}
",,
preprocessor_in_statement,pack-revindex.c,40,+,+,"{
    struct revindex_entry *tmp, *from, *to;
    int bits;
    unsigned *pos;
    ALLOC_ARRAY(pos, BUCKETS);
    ALLOC_ARRAY(tmp, n);
    from = entries;
    to = tmp;
    for (bits = 0;max >> bits;bits += DIGIT_SIZE){
        unsigned i;
        memset(pos, 0, BUCKETS * sizeof (*pos));
        for (i = 0;i < n;i++)
            pos[BUCKET_FOR(from, i, bits)]++;
        for (i = 1;i < BUCKETS;i++)
            pos[i] += pos[i - 1];
        for (i = n - 1;i != UINT_MAX;i--)
            to[--pos[BUCKET_FOR(from, i, bits)]] = from[i];
        SWAP(from, to);
    }
    if (from != entries)
        COPY_ARRAY(entries, tmp, n);

    free(tmp);
    free(pos);
}
",,"{
	/*
	 * We use a ""digit"" size of 16 bits. That keeps our memory
	 * usage reasonable, and we can generally (for a 4G or smaller
	 * packfile) quit after two rounds of radix-sorting.
	 */
#define DIGIT_SIZE (16)
#define BUCKETS (1 << DIGIT_SIZE)
	/*
	 * We want to know the bucket that a[i] will go into when we are using
	 * the digit that is N bits from the (least significant) end.
	 */
#define BUCKET_FOR(a, i, bits) (((a)[(i)].offset >> (bits)) & (BUCKETS-1))

	/*
	 * We need O(n) temporary storage. Rather than do an extra copy of the
	 * partial results into ""entries"", we sort back and forth between the
	 * real array and temporary storage. In each iteration of the loop, we
	 * keep track of them with alias pointers, always sorting from ""from""
	 * to ""to"".
	 */
	struct revindex_entry *tmp, *from, *to;
	int bits;
	unsigned *pos;

	ALLOC_ARRAY(pos, BUCKETS);
	ALLOC_ARRAY(tmp, n);
	from = entries;
	to = tmp;

	/*
	 * If (max >> bits) is zero, then we know that the radix digit we are
	 * on (and any higher) will be zero for all entries, and our loop will
	 * be a no-op, as everybody lands in the same zero-th bucket.
	 */
	for (bits = 0; max >> bits; bits += DIGIT_SIZE) {
		unsigned i;

		memset(pos, 0, BUCKETS * sizeof(*pos));

		/*
		 * We want pos[i] to store the index of the last element that
		 * will go in bucket ""i"" (actually one past the last element).
		 * To do this, we first count the items that will go in each
		 * bucket, which gives us a relative offset from the last
		 * bucket. We can then cumulatively add the index from the
		 * previous bucket to get the true index.
		 */
		for (i = 0; i < n; i++)
			pos[BUCKET_FOR(from, i, bits)]++;
		for (i = 1; i < BUCKETS; i++)
			pos[i] += pos[i-1];

		/*
		 * Now we can drop the elements into their correct buckets (in
		 * our temporary array).  We iterate the pos counter backwards
		 * to avoid using an extra index to count up. And since we are
		 * going backwards there, we must also go backwards through the
		 * array itself, to keep the sort stable.
		 *
		 * Note that we use an unsigned iterator to make sure we can
		 * handle 2^32-1 objects, even on a 32-bit system. But this
		 * means we cannot use the more obvious ""i >= 0"" loop condition
		 * for counting backwards, and must instead check for
		 * wrap-around with UINT_MAX.
		 */
		for (i = n - 1; i != UINT_MAX; i--)
			to[--pos[BUCKET_FOR(from, i, bits)]] = from[i];

		/*
		 * Now ""to"" contains the most sorted list, so we swap ""from"" and
		 * ""to"" for the next iteration.
		 */
		SWAP(from, to);
	}

	/*
	 * If we ended with our data in the original array, great. If not,
	 * we have to move it back from the temporary storage.
	 */
	if (from != entries)
		COPY_ARRAY(entries, tmp, n);
	free(tmp);
	free(pos);

#undef BUCKET_FOR
#undef BUCKETS
#undef DIGIT_SIZE
}"
preprocessor_in_statement,patch-delta.c,18,-,+,,,"{
	const unsigned char *data, *top;
	unsigned char *dst_buf, *out, cmd;
	unsigned long size;

	if (delta_size < DELTA_SIZE_MIN)
		return NULL;

	data = delta_buf;
	top = (const unsigned char *) delta_buf + delta_size;

	/* make sure the orig file size matches what we expect */
	size = get_delta_hdr_size(&data, top);
	if (size != src_size)
		return NULL;

	/* now the result size */
	size = get_delta_hdr_size(&data, top);
	dst_buf = xmallocz(size);

	out = dst_buf;
	while (data < top) {
		cmd = *data++;
		if (cmd & 0x80) {
			unsigned long cp_off = 0, cp_size = 0;
#define PARSE_CP_PARAM(bit, var, shift) do { \
			if (cmd & (bit)) { \
				if (data >= top) \
					goto bad_length; \
				var |= ((unsigned) *data++ << (shift)); \
			} } while (0)
			PARSE_CP_PARAM(0x01, cp_off, 0);
			PARSE_CP_PARAM(0x02, cp_off, 8);
			PARSE_CP_PARAM(0x04, cp_off, 16);
			PARSE_CP_PARAM(0x08, cp_off, 24);
			PARSE_CP_PARAM(0x10, cp_size, 0);
			PARSE_CP_PARAM(0x20, cp_size, 8);
			PARSE_CP_PARAM(0x40, cp_size, 16);
#undef PARSE_CP_PARAM
			if (cp_size == 0) cp_size = 0x10000;
			if (unsigned_add_overflows(cp_off, cp_size) ||
			    cp_off + cp_size > src_size ||
			    cp_size > size)
				goto bad_length;
			memcpy(out, (char *) src_buf + cp_off, cp_size);
			out += cp_size;
			size -= cp_size;
		} else if (cmd) {
			if (cmd > size || cmd > top - data)
				goto bad_length;
			memcpy(out, data, cmd);
			out += cmd;
			data += cmd;
			size -= cmd;
		} else {
			/*
			 * cmd == 0 is reserved for future encoding
			 * extensions. In the mean time we must fail when
			 * encountering them (might be data corruption).
			 */
			error(""unexpected delta opcode 0"");
			goto bad;
		}
	}

	/* sanity check */
	if (data != top || size != 0) {
		bad_length:
		error(""delta replay has gone wild"");
		bad:
		free(dst_buf);
		return NULL;
	}

	*dst_size = out - dst_buf;"
preprocessor_in_statement,patch-delta.c,41,+,-,"{
    unsigned long cp_off = 0, cp_size = 0;
    PARSE_CP_PARAM(0x01, cp_off, 0);
    PARSE_CP_PARAM(0x02, cp_off, 8);
    PARSE_CP_PARAM(0x04, cp_off, 16);
    PARSE_CP_PARAM(0x08, cp_off, 24);
    PARSE_CP_PARAM(0x10, cp_size, 0);
    PARSE_CP_PARAM(0x20, cp_size, 8);
    PARSE_CP_PARAM(0x40, cp_size, 16);
    if (cp_size == 0)
        cp_size = 0x10000;

    if (unsigned_add_overflows(cp_off, cp_size) || cp_off + cp_size > src_size || cp_size > size)
        goto bad_length;

    memcpy(out, (char*)src_buf + cp_off, cp_size);
    out += cp_size;
    size -= cp_size;
}
",,
preprocessor_in_statement,pkt-line.c,136,+,+,"{
    static char hexchar[] = ""0123456789abcdef"";
    buf[0] = hex(size >> 12);
    buf[1] = hex(size >> 8);
    buf[2] = hex(size >> 4);
    buf[3] = hex(size);
}
",,"{
	static char hexchar[] = ""0123456789abcdef"";

	#define hex(a) (hexchar[(a) & 15])
	buf[0] = hex(size >> 12);
	buf[1] = hex(size >> 8);
	buf[2] = hex(size >> 4);
	buf[3] = hex(size);
	#undef hex
}"
preprocessor_in_statement,quote.c,267,+,+,"{
    int no_dq = !!(flags & CQUOTE_NODQ);
    size_t len, count = 0;
    const char* p = name;
    for (;;){
        int ch;
        len = next_quote_pos(p, maxlen);
        if (len == maxlen || (maxlen < 0 && !p[len]))
            break;

        if (!no_dq && p == name)
            EMIT('""');

        EMITBUF(p, len);
        EMIT('\\');
        p += len;
        ch = (unsigned char)*p++;
        if (maxlen >= 0)
            maxlen -= len + 1;

        if (cq_lookup[ch] >= ' '){
            EMIT(cq_lookup[ch]);
        }else{
            EMIT(((ch >> 6) & 03) + '0');
            EMIT(((ch >> 3) & 07) + '0');
            EMIT(((ch >> 0) & 07) + '0');
        }
    }
    EMITBUF(p, len);
    if (p == name)
        return 0;

    if (!no_dq)
        EMIT('""');

    return count;
}
",,"{
#undef EMIT
#define EMIT(c)                                 \
	do {                                        \
		if (sb) strbuf_addch(sb, (c));          \
		if (fp) fputc((c), fp);                 \
		count++;                                \
	} while (0)
#define EMITBUF(s, l)                           \
	do {                                        \
		if (sb) strbuf_add(sb, (s), (l));       \
		if (fp) fwrite((s), (l), 1, fp);        \
		count += (l);                           \
	} while (0)

	int no_dq = !!(flags & CQUOTE_NODQ);
	size_t len, count = 0;
	const char *p = name;

	for (;;) {
		int ch;

		len = next_quote_pos(p, maxlen);
		if (len == maxlen || (maxlen < 0 && !p[len]))
			break;

		if (!no_dq && p == name)
			EMIT('""');

		EMITBUF(p, len);
		EMIT('\\');
		p += len;
		ch = (unsigned char)*p++;
		if (maxlen >= 0)
			maxlen -= len + 1;
		if (cq_lookup[ch] >= ' ') {
			EMIT(cq_lookup[ch]);
		} else {
			EMIT(((ch >> 6) & 03) + '0');
			EMIT(((ch >> 3) & 07) + '0');
			EMIT(((ch >> 0) & 07) + '0');
		}
	}

	EMITBUF(p, len);
	if (p == name)   /* no ending quote needed */
		return 0;

	if (!no_dq)
		EMIT('""');
	return count;
}"
preprocessor_in_statement,regcomp.c,3536,+,-,"{
    int i;
    if ((syntax & RE_ICASE) && (strcmp(class_name, ""upper"") == 0 || strcmp(class_name, ""lower"") == 0))
        class_name = ""alpha"";

    if (strcmp(class_name, ""alnum"") == 0)
        BUILD_CHARCLASS_LOOP (isalnum);
    else
        if (strcmp(class_name, ""cntrl"") == 0)
            BUILD_CHARCLASS_LOOP (iscntrl);
        else
            if (strcmp(class_name, ""lower"") == 0)
                BUILD_CHARCLASS_LOOP (islower);
            else
                if (strcmp(class_name, ""space"") == 0)
                    BUILD_CHARCLASS_LOOP (isspace);
                else
                    if (strcmp(class_name, ""alpha"") == 0)
                        BUILD_CHARCLASS_LOOP (isalpha);
                    else
                        if (strcmp(class_name, ""digit"") == 0)
                            BUILD_CHARCLASS_LOOP (isdigit);
                        else
                            if (strcmp(class_name, ""print"") == 0)
                                BUILD_CHARCLASS_LOOP (isprint);
                            else
                                if (strcmp(class_name, ""upper"") == 0)
                                    BUILD_CHARCLASS_LOOP (isupper);
                                else
                                    if (strcmp(class_name, ""blank"") == 0)
                                        BUILD_CHARCLASS_LOOP (isblank);
                                    else
                                        if (strcmp(class_name, ""graph"") == 0)
                                            BUILD_CHARCLASS_LOOP (isgraph);
                                        else
                                            if (strcmp(class_name, ""punct"") == 0)
                                                BUILD_CHARCLASS_LOOP (ispunct);
                                            else
                                                if (strcmp(class_name, ""xdigit"") == 0)
                                                    BUILD_CHARCLASS_LOOP (isxdigit);
                                                else
                                                    return REG_ECTYPE;

    return REG_NOERROR;
}
",,
preprocessor_in_statement,sha256.c,59,+,+,"{
    uint32_t S[8], W[64], t0, t1;
    int i;
    for (i = 0;i < 8;i++)
        S[i] = ctx->state[i];
    for (i = 0;i < 16;i++, buf += sizeof (uint32_t))
        W[i] = get_be32(buf);
    for (i = 16;i < 64;i++)
        W[i] = gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16];
    RND(S[0],S[1],S[2],S[3],S[4],S[5],S[6],S[7],0,0x428a2f98);
    RND(S[7],S[0],S[1],S[2],S[3],S[4],S[5],S[6],1,0x71374491);
    RND(S[6],S[7],S[0],S[1],S[2],S[3],S[4],S[5],2,0xb5c0fbcf);
    RND(S[5],S[6],S[7],S[0],S[1],S[2],S[3],S[4],3,0xe9b5dba5);
    RND(S[4],S[5],S[6],S[7],S[0],S[1],S[2],S[3],4,0x3956c25b);
    RND(S[3],S[4],S[5],S[6],S[7],S[0],S[1],S[2],5,0x59f111f1);
    RND(S[2],S[3],S[4],S[5],S[6],S[7],S[0],S[1],6,0x923f82a4);
    RND(S[1],S[2],S[3],S[4],S[5],S[6],S[7],S[0],7,0xab1c5ed5);
    RND(S[0],S[1],S[2],S[3],S[4],S[5],S[6],S[7],8,0xd807aa98);
    RND(S[7],S[0],S[1],S[2],S[3],S[4],S[5],S[6],9,0x12835b01);
    RND(S[6],S[7],S[0],S[1],S[2],S[3],S[4],S[5],10,0x243185be);
    RND(S[5],S[6],S[7],S[0],S[1],S[2],S[3],S[4],11,0x550c7dc3);
    RND(S[4],S[5],S[6],S[7],S[0],S[1],S[2],S[3],12,0x72be5d74);
    RND(S[3],S[4],S[5],S[6],S[7],S[0],S[1],S[2],13,0x80deb1fe);
    RND(S[2],S[3],S[4],S[5],S[6],S[7],S[0],S[1],14,0x9bdc06a7);
    RND(S[1],S[2],S[3],S[4],S[5],S[6],S[7],S[0],15,0xc19bf174);
    RND(S[0],S[1],S[2],S[3],S[4],S[5],S[6],S[7],16,0xe49b69c1);
    RND(S[7],S[0],S[1],S[2],S[3],S[4],S[5],S[6],17,0xefbe4786);
    RND(S[6],S[7],S[0],S[1],S[2],S[3],S[4],S[5],18,0x0fc19dc6);
    RND(S[5],S[6],S[7],S[0],S[1],S[2],S[3],S[4],19,0x240ca1cc);
    RND(S[4],S[5],S[6],S[7],S[0],S[1],S[2],S[3],20,0x2de92c6f);
    RND(S[3],S[4],S[5],S[6],S[7],S[0],S[1],S[2],21,0x4a7484aa);
    RND(S[2],S[3],S[4],S[5],S[6],S[7],S[0],S[1],22,0x5cb0a9dc);
    RND(S[1],S[2],S[3],S[4],S[5],S[6],S[7],S[0],23,0x76f988da);
    RND(S[0],S[1],S[2],S[3],S[4],S[5],S[6],S[7],24,0x983e5152);
    RND(S[7],S[0],S[1],S[2],S[3],S[4],S[5],S[6],25,0xa831c66d);
    RND(S[6],S[7],S[0],S[1],S[2],S[3],S[4],S[5],26,0xb00327c8);
    RND(S[5],S[6],S[7],S[0],S[1],S[2],S[3],S[4],27,0xbf597fc7);
    RND(S[4],S[5],S[6],S[7],S[0],S[1],S[2],S[3],28,0xc6e00bf3);
    RND(S[3],S[4],S[5],S[6],S[7],S[0],S[1],S[2],29,0xd5a79147);
    RND(S[2],S[3],S[4],S[5],S[6],S[7],S[0],S[1],30,0x06ca6351);
    RND(S[1],S[2],S[3],S[4],S[5],S[6],S[7],S[0],31,0x14292967);
    RND(S[0],S[1],S[2],S[3],S[4],S[5],S[6],S[7],32,0x27b70a85);
    RND(S[7],S[0],S[1],S[2],S[3],S[4],S[5],S[6],33,0x2e1b2138);
    RND(S[6],S[7],S[0],S[1],S[2],S[3],S[4],S[5],34,0x4d2c6dfc);
    RND(S[5],S[6],S[7],S[0],S[1],S[2],S[3],S[4],35,0x53380d13);
    RND(S[4],S[5],S[6],S[7],S[0],S[1],S[2],S[3],36,0x650a7354);
    RND(S[3],S[4],S[5],S[6],S[7],S[0],S[1],S[2],37,0x766a0abb);
    RND(S[2],S[3],S[4],S[5],S[6],S[7],S[0],S[1],38,0x81c2c92e);
    RND(S[1],S[2],S[3],S[4],S[5],S[6],S[7],S[0],39,0x92722c85);
    RND(S[0],S[1],S[2],S[3],S[4],S[5],S[6],S[7],40,0xa2bfe8a1);
    RND(S[7],S[0],S[1],S[2],S[3],S[4],S[5],S[6],41,0xa81a664b);
    RND(S[6],S[7],S[0],S[1],S[2],S[3],S[4],S[5],42,0xc24b8b70);
    RND(S[5],S[6],S[7],S[0],S[1],S[2],S[3],S[4],43,0xc76c51a3);
    RND(S[4],S[5],S[6],S[7],S[0],S[1],S[2],S[3],44,0xd192e819);
    RND(S[3],S[4],S[5],S[6],S[7],S[0],S[1],S[2],45,0xd6990624);
    RND(S[2],S[3],S[4],S[5],S[6],S[7],S[0],S[1],46,0xf40e3585);
    RND(S[1],S[2],S[3],S[4],S[5],S[6],S[7],S[0],47,0x106aa070);
    RND(S[0],S[1],S[2],S[3],S[4],S[5],S[6],S[7],48,0x19a4c116);
    RND(S[7],S[0],S[1],S[2],S[3],S[4],S[5],S[6],49,0x1e376c08);
    RND(S[6],S[7],S[0],S[1],S[2],S[3],S[4],S[5],50,0x2748774c);
    RND(S[5],S[6],S[7],S[0],S[1],S[2],S[3],S[4],51,0x34b0bcb5);
    RND(S[4],S[5],S[6],S[7],S[0],S[1],S[2],S[3],52,0x391c0cb3);
    RND(S[3],S[4],S[5],S[6],S[7],S[0],S[1],S[2],53,0x4ed8aa4a);
    RND(S[2],S[3],S[4],S[5],S[6],S[7],S[0],S[1],54,0x5b9cca4f);
    RND(S[1],S[2],S[3],S[4],S[5],S[6],S[7],S[0],55,0x682e6ff3);
    RND(S[0],S[1],S[2],S[3],S[4],S[5],S[6],S[7],56,0x748f82ee);
    RND(S[7],S[0],S[1],S[2],S[3],S[4],S[5],S[6],57,0x78a5636f);
    RND(S[6],S[7],S[0],S[1],S[2],S[3],S[4],S[5],58,0x84c87814);
    RND(S[5],S[6],S[7],S[0],S[1],S[2],S[3],S[4],59,0x8cc70208);
    RND(S[4],S[5],S[6],S[7],S[0],S[1],S[2],S[3],60,0x90befffa);
    RND(S[3],S[4],S[5],S[6],S[7],S[0],S[1],S[2],61,0xa4506ceb);
    RND(S[2],S[3],S[4],S[5],S[6],S[7],S[0],S[1],62,0xbef9a3f7);
    RND(S[1],S[2],S[3],S[4],S[5],S[6],S[7],S[0],63,0xc67178f2);
    for (i = 0;i < 8;i++)
        ctx->state[i] += S[i];
}
",,"{

	uint32_t S[8], W[64], t0, t1;
	int i;

	/* copy state into S */
	for (i = 0; i < 8; i++)
		S[i] = ctx->state[i];

	/* copy the state into 512-bits into W[0..15] */
	for (i = 0; i < 16; i++, buf += sizeof(uint32_t))
		W[i] = get_be32(buf);

	/* fill W[16..63] */
	for (i = 16; i < 64; i++)
		W[i] = gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16];

#define RND(a,b,c,d,e,f,g,h,i,ki)                    \
	t0 = h + sigma1(e) + ch(e, f, g) + ki + W[i];   \
	t1 = sigma0(a) + maj(a, b, c);                  \
	d += t0;                                        \
	h  = t0 + t1;

	RND(S[0],S[1],S[2],S[3],S[4],S[5],S[6],S[7],0,0x428a2f98);
	RND(S[7],S[0],S[1],S[2],S[3],S[4],S[5],S[6],1,0x71374491);
	RND(S[6],S[7],S[0],S[1],S[2],S[3],S[4],S[5],2,0xb5c0fbcf);
	RND(S[5],S[6],S[7],S[0],S[1],S[2],S[3],S[4],3,0xe9b5dba5);
	RND(S[4],S[5],S[6],S[7],S[0],S[1],S[2],S[3],4,0x3956c25b);
	RND(S[3],S[4],S[5],S[6],S[7],S[0],S[1],S[2],5,0x59f111f1);
	RND(S[2],S[3],S[4],S[5],S[6],S[7],S[0],S[1],6,0x923f82a4);
	RND(S[1],S[2],S[3],S[4],S[5],S[6],S[7],S[0],7,0xab1c5ed5);
	RND(S[0],S[1],S[2],S[3],S[4],S[5],S[6],S[7],8,0xd807aa98);
	RND(S[7],S[0],S[1],S[2],S[3],S[4],S[5],S[6],9,0x12835b01);
	RND(S[6],S[7],S[0],S[1],S[2],S[3],S[4],S[5],10,0x243185be);
	RND(S[5],S[6],S[7],S[0],S[1],S[2],S[3],S[4],11,0x550c7dc3);
	RND(S[4],S[5],S[6],S[7],S[0],S[1],S[2],S[3],12,0x72be5d74);
	RND(S[3],S[4],S[5],S[6],S[7],S[0],S[1],S[2],13,0x80deb1fe);
	RND(S[2],S[3],S[4],S[5],S[6],S[7],S[0],S[1],14,0x9bdc06a7);
	RND(S[1],S[2],S[3],S[4],S[5],S[6],S[7],S[0],15,0xc19bf174);
	RND(S[0],S[1],S[2],S[3],S[4],S[5],S[6],S[7],16,0xe49b69c1);
	RND(S[7],S[0],S[1],S[2],S[3],S[4],S[5],S[6],17,0xefbe4786);
	RND(S[6],S[7],S[0],S[1],S[2],S[3],S[4],S[5],18,0x0fc19dc6);
	RND(S[5],S[6],S[7],S[0],S[1],S[2],S[3],S[4],19,0x240ca1cc);
	RND(S[4],S[5],S[6],S[7],S[0],S[1],S[2],S[3],20,0x2de92c6f);
	RND(S[3],S[4],S[5],S[6],S[7],S[0],S[1],S[2],21,0x4a7484aa);
	RND(S[2],S[3],S[4],S[5],S[6],S[7],S[0],S[1],22,0x5cb0a9dc);
	RND(S[1],S[2],S[3],S[4],S[5],S[6],S[7],S[0],23,0x76f988da);
	RND(S[0],S[1],S[2],S[3],S[4],S[5],S[6],S[7],24,0x983e5152);
	RND(S[7],S[0],S[1],S[2],S[3],S[4],S[5],S[6],25,0xa831c66d);
	RND(S[6],S[7],S[0],S[1],S[2],S[3],S[4],S[5],26,0xb00327c8);
	RND(S[5],S[6],S[7],S[0],S[1],S[2],S[3],S[4],27,0xbf597fc7);
	RND(S[4],S[5],S[6],S[7],S[0],S[1],S[2],S[3],28,0xc6e00bf3);
	RND(S[3],S[4],S[5],S[6],S[7],S[0],S[1],S[2],29,0xd5a79147);
	RND(S[2],S[3],S[4],S[5],S[6],S[7],S[0],S[1],30,0x06ca6351);
	RND(S[1],S[2],S[3],S[4],S[5],S[6],S[7],S[0],31,0x14292967);
	RND(S[0],S[1],S[2],S[3],S[4],S[5],S[6],S[7],32,0x27b70a85);
	RND(S[7],S[0],S[1],S[2],S[3],S[4],S[5],S[6],33,0x2e1b2138);
	RND(S[6],S[7],S[0],S[1],S[2],S[3],S[4],S[5],34,0x4d2c6dfc);
	RND(S[5],S[6],S[7],S[0],S[1],S[2],S[3],S[4],35,0x53380d13);
	RND(S[4],S[5],S[6],S[7],S[0],S[1],S[2],S[3],36,0x650a7354);
	RND(S[3],S[4],S[5],S[6],S[7],S[0],S[1],S[2],37,0x766a0abb);
	RND(S[2],S[3],S[4],S[5],S[6],S[7],S[0],S[1],38,0x81c2c92e);
	RND(S[1],S[2],S[3],S[4],S[5],S[6],S[7],S[0],39,0x92722c85);
	RND(S[0],S[1],S[2],S[3],S[4],S[5],S[6],S[7],40,0xa2bfe8a1);
	RND(S[7],S[0],S[1],S[2],S[3],S[4],S[5],S[6],41,0xa81a664b);
	RND(S[6],S[7],S[0],S[1],S[2],S[3],S[4],S[5],42,0xc24b8b70);
	RND(S[5],S[6],S[7],S[0],S[1],S[2],S[3],S[4],43,0xc76c51a3);
	RND(S[4],S[5],S[6],S[7],S[0],S[1],S[2],S[3],44,0xd192e819);
	RND(S[3],S[4],S[5],S[6],S[7],S[0],S[1],S[2],45,0xd6990624);
	RND(S[2],S[3],S[4],S[5],S[6],S[7],S[0],S[1],46,0xf40e3585);
	RND(S[1],S[2],S[3],S[4],S[5],S[6],S[7],S[0],47,0x106aa070);
	RND(S[0],S[1],S[2],S[3],S[4],S[5],S[6],S[7],48,0x19a4c116);
	RND(S[7],S[0],S[1],S[2],S[3],S[4],S[5],S[6],49,0x1e376c08);
	RND(S[6],S[7],S[0],S[1],S[2],S[3],S[4],S[5],50,0x2748774c);
	RND(S[5],S[6],S[7],S[0],S[1],S[2],S[3],S[4],51,0x34b0bcb5);
	RND(S[4],S[5],S[6],S[7],S[0],S[1],S[2],S[3],52,0x391c0cb3);
	RND(S[3],S[4],S[5],S[6],S[7],S[0],S[1],S[2],53,0x4ed8aa4a);
	RND(S[2],S[3],S[4],S[5],S[6],S[7],S[0],S[1],54,0x5b9cca4f);
	RND(S[1],S[2],S[3],S[4],S[5],S[6],S[7],S[0],55,0x682e6ff3);
	RND(S[0],S[1],S[2],S[3],S[4],S[5],S[6],S[7],56,0x748f82ee);
	RND(S[7],S[0],S[1],S[2],S[3],S[4],S[5],S[6],57,0x78a5636f);
	RND(S[6],S[7],S[0],S[1],S[2],S[3],S[4],S[5],58,0x84c87814);
	RND(S[5],S[6],S[7],S[0],S[1],S[2],S[3],S[4],59,0x8cc70208);
	RND(S[4],S[5],S[6],S[7],S[0],S[1],S[2],S[3],60,0x90befffa);
	RND(S[3],S[4],S[5],S[6],S[7],S[0],S[1],S[2],61,0xa4506ceb);
	RND(S[2],S[3],S[4],S[5],S[6],S[7],S[0],S[1],62,0xbef9a3f7);
	RND(S[1],S[2],S[3],S[4],S[5],S[6],S[7],S[0],63,0xc67178f2);

	for (i = 0; i < 8; i++)
		ctx->state[i] += S[i];
}"
preprocessor_in_statement,trace2_win32_process_info.c,155,+,-,"{
    struct json_writer jw = JSON_WRITER_INIT;
    jw_object_begin(&jw, 0);
    jw_object_intmax(&jw, KV(PageFaultCount), );
    jw_object_intmax(&jw, KV(PeakWorkingSetSize), );
    jw_object_intmax(&jw, KV(PeakPagefileUsage), );
    jw_end(&jw);
    trace2_data_json(""process"", the_repository, ""windows/memory"", &jw);
    jw_release(&jw);
}
",,
preprocessor_in_statement,wt-status.c,2048,+,+,"{
    struct branch* branch;
    const char* header_color = color(WT_STATUS_HEADER, s);
    const char* branch_color_local = color(WT_STATUS_LOCAL_BRANCH, s);
    const char* branch_color_remote = color(WT_STATUS_REMOTE_BRANCH, s);
    const char* base;
    char* short_base;
    const char* branch_name;
    int num_ours, num_theirs, sti;
    int upstream_is_gone = 0;
    color_fprintf(s->fp, color(WT_STATUS_HEADER, s), ""## "");
    if (!s->branch)
        return;

    branch_name = s->branch;
    if (s->is_initial)
        color_fprintf(s->fp, header_color, LABEL(N_(""No commits yet on "")));

    if (!strcmp(s->branch, ""HEAD"")){
        color_fprintf(s->fp, color(WT_STATUS_NOBRANCH, s), ""%s"", LABEL(N_(""HEAD (no branch)"")));
        goto conclude;
    }
    skip_prefix(branch_name, ""refs/heads/"", &branch_name);
    branch = branch_get(branch_name);
    color_fprintf(s->fp, branch_color_local, ""%s"", branch_name);
    sti = stat_tracking_info(branch, &num_ours, &num_theirs, &base, 0, s->ahead_behind_flags);
    if (sti < 0){
        if (!base)
            goto conclude;

        upstream_is_gone = 1;
    }
    short_base = refs_shorten_unambiguous_ref(get_main_ref_store(the_repository), base, 0);
    color_fprintf(s->fp, header_color, ""..."");
    color_fprintf(s->fp, branch_color_remote, ""%s"", short_base);
    free(short_base);
    if (!upstream_is_gone && !sti)
        goto conclude;

    color_fprintf(s->fp, header_color, "" ["");
    if (upstream_is_gone){
        color_fprintf(s->fp, header_color, LABEL(N_(""gone"")));
    }else
        if (s->ahead_behind_flags == AHEAD_BEHIND_QUICK){
            color_fprintf(s->fp, header_color, LABEL(N_(""different"")));
        }else
            if (!num_ours){
                color_fprintf(s->fp, header_color, LABEL(N_(""behind "")));
                color_fprintf(s->fp, branch_color_remote, ""%d"", num_theirs);
            }else
                if (!num_theirs){
                    color_fprintf(s->fp, header_color, LABEL(N_(""ahead "")));
                    color_fprintf(s->fp, branch_color_local, ""%d"", num_ours);
                }else{
                    color_fprintf(s->fp, header_color, LABEL(N_(""ahead "")));
                    color_fprintf(s->fp, branch_color_local, ""%d"", num_ours);
                    color_fprintf(s->fp, header_color, "", %s"", LABEL(N_(""behind "")));
                    color_fprintf(s->fp, branch_color_remote, ""%d"", num_theirs);
                }

    color_fprintf(s->fp, header_color, ""]"");
    conclude:
    fputc(s->null_termination ? '\0' : '\n', s->fp);
}
",,"{
	struct branch *branch;
	const char *header_color = color(WT_STATUS_HEADER, s);
	const char *branch_color_local = color(WT_STATUS_LOCAL_BRANCH, s);
	const char *branch_color_remote = color(WT_STATUS_REMOTE_BRANCH, s);

	const char *base;
	char *short_base;
	const char *branch_name;
	int num_ours, num_theirs, sti;
	int upstream_is_gone = 0;

	color_fprintf(s->fp, color(WT_STATUS_HEADER, s), ""## "");

	if (!s->branch)
		return;
	branch_name = s->branch;

#define LABEL(string) (s->no_gettext ? (string) : _(string))

	if (s->is_initial)
		color_fprintf(s->fp, header_color, LABEL(N_(""No commits yet on "")));

	if (!strcmp(s->branch, ""HEAD"")) {
		color_fprintf(s->fp, color(WT_STATUS_NOBRANCH, s), ""%s"",
			      LABEL(N_(""HEAD (no branch)"")));
		goto conclude;
	}

	skip_prefix(branch_name, ""refs/heads/"", &branch_name);

	branch = branch_get(branch_name);

	color_fprintf(s->fp, branch_color_local, ""%s"", branch_name);

	sti = stat_tracking_info(branch, &num_ours, &num_theirs, &base,
				 0, s->ahead_behind_flags);
	if (sti < 0) {
		if (!base)
			goto conclude;

		upstream_is_gone = 1;
	}

	short_base = refs_shorten_unambiguous_ref(get_main_ref_store(the_repository),
						  base, 0);
	color_fprintf(s->fp, header_color, ""..."");
	color_fprintf(s->fp, branch_color_remote, ""%s"", short_base);
	free(short_base);

	if (!upstream_is_gone && !sti)
		goto conclude;

	color_fprintf(s->fp, header_color, "" ["");
	if (upstream_is_gone) {
		color_fprintf(s->fp, header_color, LABEL(N_(""gone"")));
	} else if (s->ahead_behind_flags == AHEAD_BEHIND_QUICK) {
		color_fprintf(s->fp, header_color, LABEL(N_(""different"")));
	} else if (!num_ours) {
		color_fprintf(s->fp, header_color, LABEL(N_(""behind "")));
		color_fprintf(s->fp, branch_color_remote, ""%d"", num_theirs);
	} else if (!num_theirs) {
		color_fprintf(s->fp, header_color, LABEL(N_(""ahead "")));
		color_fprintf(s->fp, branch_color_local, ""%d"", num_ours);
	} else {
		color_fprintf(s->fp, header_color, LABEL(N_(""ahead "")));
		color_fprintf(s->fp, branch_color_local, ""%d"", num_ours);
		color_fprintf(s->fp, header_color, "", %s"", LABEL(N_(""behind "")));
		color_fprintf(s->fp, branch_color_remote, ""%d"", num_theirs);
	}

	color_fprintf(s->fp, header_color, ""]"");
 conclude:
	fputc(s->null_termination ? '\0' : '\n', s->fp);
}"
