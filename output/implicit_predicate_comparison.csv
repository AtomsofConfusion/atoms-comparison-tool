Type,File,Line,CLJ,CQL,CLJ_Code,CQL_Column,CQL_Code
implicit_predicate,_fd_def.h,82,+,-,"if (__darwin_check_fd_set(_fd, (const void*)_p)){
    return _p->fds_bits[(unsigned long )_fd / __DARWIN_NFDBITS] & ((__int32_t)(((unsigned long )1) << ((unsigned long )_fd % __DARWIN_NFDBITS)));
}
",,
implicit_predicate,_fd_def.h,92,+,-,"if (__darwin_check_fd_set(_fd, (const void*)_p)){
    (_p->fds_bits[(unsigned long )_fd / __DARWIN_NFDBITS] |= ((__int32_t)(((unsigned long )1) << ((unsigned long )_fd % __DARWIN_NFDBITS))));
}
",,
implicit_predicate,_fd_def.h,100,+,-,"if (__darwin_check_fd_set(_fd, (const void*)_p)){
    (_p->fds_bits[(unsigned long )_fd / __DARWIN_NFDBITS] &= ~((__int32_t)(((unsigned long )1) << ((unsigned long )_fd % __DARWIN_NFDBITS))));
}
",,
implicit_predicate,abspath.c,90,+,-,"if (flags & REALPATH_DIE_ON_ERROR)
    die(""The empty string is not a valid path"");
else
    goto error_out;
",,
implicit_predicate,abspath.c,102,+,-,"if (flags & REALPATH_DIE_ON_ERROR)
    die_errno(""unable to get current working directory"");
else
    goto error_out;
",,
implicit_predicate,abspath.c,132,+,-,"if (flags & REALPATH_DIE_ON_ERROR)
    die_errno(""Invalid path '%s'"", resolved->buf);
else
    goto error_out;
",,
implicit_predicate,abspath.c,145,+,-,"if (flags & REALPATH_DIE_ON_ERROR)
    die(""More than %d nested symlinks on path '%s'"", MAXSYMLINKS, path);
else
    goto error_out;
",,
implicit_predicate,abspath.c,155,+,-,"if (flags & REALPATH_DIE_ON_ERROR)
    die_errno(""Invalid symlink '%s'"", resolved->buf);
else
    goto error_out;
",,
implicit_predicate,abspath.c,220,+,+,die_on_error ? REALPATH_DIE_ON_ERROR : 0,6,				 die_on_error ? REALPATH_DIE_ON_ERROR : 0);
implicit_predicate,abspath.c,231,+,+,die_on_error ? REALPATH_DIE_ON_ERROR : 0,8,				 ((die_on_error ? REALPATH_DIE_ON_ERROR : 0) |
implicit_predicate,abspath.c,270,-,+,,19,	size_t pfx_len = pfx ? strlen(pfx) : 0;
implicit_predicate,add-interactive.c,69,-,+,,3,"		s->use_color ? GIT_COLOR_RESET : """", COLOR_MAXLEN);"
implicit_predicate,add-interactive.c,246,-,+,,23,"		opts->print_item(i, selected ? selected[i] : 0, list->items + i,"
implicit_predicate,add-interactive.c,291,+,+,singleton ? LIST_AND_CHOOSE_ERROR : 0,16,	ssize_t res = singleton ? LIST_AND_CHOOSE_ERROR : 0;
implicit_predicate,add-interactive.c,311,+,+,"singleton ? ""> "" : "">> """,9,"		fputs(singleton ? ""> "" : "">> "", stdout);"
implicit_predicate,add-interactive.c,316,+,-,"if (immediate)
    res = LIST_AND_CHOOSE_QUIT;
",,
implicit_predicate,add-interactive.c,391,+,-,"if (singleton){
    res = from;
    break;
}
",,
implicit_predicate,add-interactive.c,402,+,+,choose ? +1 : -1,13,					res += choose ? +1 : -1;
implicit_predicate,add-interactive.c,450,-,+,,26,"	return strcmp(e1->name, name ? (const char *)name : e2->name);"
implicit_predicate,add-interactive.c,487,+,-,"if (s->skip_unseen)
    continue;
",,
implicit_predicate,add-interactive.c,559,+,+,is_initial ? empty_tree_oid_hex() : oid_to_hex(&head_oid),13,"		opt.def = is_initial ?
			empty_tree_oid_hex() : oid_to_hex(&head_oid);"
implicit_predicate,add-interactive.c,649,+,-,"if (d->only_names){
    printf(""%c%2d: %s"", selected ? '*' : ' ', i + 1, highlighted ? highlighted : item->string);
    return;
}
",,
implicit_predicate,add-interactive.c,650,+,+,selected ? '*' : ' ',23,"		printf(""%c%2d: %s"", selected ? '*' : ' ', i + 1,"
implicit_predicate,add-interactive.c,651,-,+,,10,		       highlighted ? highlighted : item->string);
implicit_predicate,add-interactive.c,659,-,+,,7,		    highlighted ? highlighted : item->string);
implicit_predicate,add-interactive.c,661,+,+,selected ? '*' : ' ',22,"	printf(""%c%2d: %s"", selected ? '*' : ' ', i + 1, d->buf.buf);"
implicit_predicate,add-interactive.c,793,+,-,"if (is_initial)
    oidcpy(&oid, s->r->hash_algo->empty_tree);
else{
    tree = parse_tree_indirect(&oid);
    if (!tree){
        res = error(_(""Could not parse HEAD^{tree}""));
        goto finish_revert;
    }
    oidcpy(&oid, &tree->object.oid);
}
",,
implicit_predicate,add-patch.c,435,+,-,"if (res){
    strvec_clear(&args);
    return error(_(""could not parse diff""));
}
",,
implicit_predicate,add-patch.c,455,+,-,"if (res)
    return error(_(""could not parse colored diff""));
",,
implicit_predicate,add-patch.c,669,+,-,"if (header->suppress_colored_line_range){
    strbuf_add(out, s->colored.buf + header->colored_extra_start, header->colored_extra_end - header->colored_extra_start);
    strbuf_add(out, s->colored.buf + hunk->colored_start, hunk->colored_end - hunk->colored_start);
    return;
}else{
    strbuf_addstr(out, s->s.fraginfo_color);
    p = s->colored.buf + header->colored_extra_start;
    len = header->colored_extra_end - header->colored_extra_start;
}
",,
implicit_predicate,add-patch.c,685,+,-,"if (s->mode->is_reverse)
    old_offset -= delta;
else
    new_offset += delta;
",,
implicit_predicate,add-patch.c,700,+,-,"if (colored)
    strbuf_addf(out, ""%s\n"", s->s.reset_color);
else
    strbuf_addch(out, '\n');
",,
implicit_predicate,add-patch.c,706,+,-,"if (colored)
    strbuf_add(out, s->colored.buf + hunk->colored_start, hunk->colored_end - hunk->colored_start);
else
    strbuf_add(out, s->plain.buf + hunk->start, hunk->end - hunk->start);
",,
implicit_predicate,add-patch.c,732,+,-,"if (colored){
    const char* p = s->colored.buf;
    strbuf_add(out, p + head->colored_start, first->colored_start - head->colored_start);
    strbuf_add(out, p + first->colored_end, head->colored_end - first->colored_end);
}else{
    const char* p = s->plain.buf;
    strbuf_add(out, p + head->start, first->start - head->start);
    strbuf_add(out, p + first->end, head->end - first->end);
}
",,
implicit_predicate,add-patch.c,949,+,-,"if (colored)
    colored_current = hunk->colored_start;
",,
implicit_predicate,add-patch.c,967,+,-,"if (colored)
    hunk[1].colored_start = colored_current;
",,
implicit_predicate,add-patch.c,983,+,+,marker ? marker : ' ',10,				ch = marker ? marker : ' ';
implicit_predicate,add-patch.c,996,+,-,"if (colored)
    colored_current = find_next_line(&s->colored, colored_current);
",,
implicit_predicate,add-patch.c,1010,+,-,"if (first){
    if (header->old_count || header->new_count)
        BUG(""counts are off: %d/%d"", (int)header->old_count, (int)header->new_count);

    header->old_count = context_line_count;
    header->new_count = context_line_count;
    context_line_count = 0;
    first = 0;
    goto next_hunk_line;
}
",,
implicit_predicate,add-patch.c,1039,+,-,"if (colored)
    hunk->colored_end = colored_current;
",,
implicit_predicate,add-patch.c,1064,+,-,"if (colored)
    hunk->colored_end = colored_end;
",,
implicit_predicate,add-patch.c,1117,+,+,s->mode->is_reverse ? '+' : '-',10,"			      s->mode->is_reverse ? '+' : '-',"
implicit_predicate,add-patch.c,1118,+,+,s->mode->is_reverse ? '-' : '+',10,"			      s->mode->is_reverse ? '-' : '+',"
implicit_predicate,add-patch.c,1285,+,+,"is_reverse ? ""-R"" : NULL",24,"	const char *reverse = is_reverse ? ""-R"" : NULL;"
implicit_predicate,add-patch.c,1286,+,-,"is_reverse ? ""-R"" : NULL",,
implicit_predicate,add-patch.c,1423,-,+,,10,"		hunk = file_diff->hunk_nr
				? file_diff->hunk + hunk_index
				: &file_diff->head;"
implicit_predicate,add-patch.c,1499,-,+,,22,"			      (uintmax_t)(file_diff->hunk_nr
						? file_diff->hunk_nr
						: 1));"
implicit_predicate,add-patch.c,1546,+,-,"if (permitted & ALLOW_GOTO_PREVIOUS_HUNK)
    hunk_index--;
else
    err(s, _(""No previous hunk""));
",,
implicit_predicate,add-patch.c,1551,+,-,"if (permitted & ALLOW_GOTO_NEXT_HUNK)
    hunk_index++;
else
    err(s, _(""No next hunk""));
",,
implicit_predicate,add-patch.c,1553,+,-,"if (permitted & ALLOW_GOTO_PREVIOUS_HUNK)
    hunk_index--;
else
    err(s, _(""No previous hunk""));
",,
implicit_predicate,add-patch.c,1556,+,-,"if (permitted & ALLOW_GOTO_PREVIOUS_UNDECIDED_HUNK)
    hunk_index = undecided_previous;
else
    err(s, _(""No previous hunk""));
",,
implicit_predicate,add-patch.c,1558,+,-,"if (permitted & ALLOW_GOTO_NEXT_HUNK)
    hunk_index++;
else
    err(s, _(""No next hunk""));
",,
implicit_predicate,add-patch.c,1561,+,-,"if (permitted & ALLOW_GOTO_NEXT_UNDECIDED_HUNK)
    hunk_index = undecided_next;
else
    err(s, _(""No next hunk""));
",,
implicit_predicate,add-patch.c,1563,+,-,"if (permitted & ALLOW_GOTO_PREVIOUS_UNDECIDED_HUNK)
    hunk_index = undecided_previous;
else
    err(s, _(""No previous hunk""));
",,
implicit_predicate,add-patch.c,1568,+,-,"if (permitted & ALLOW_GOTO_NEXT_UNDECIDED_HUNK)
    hunk_index = undecided_next;
else
    err(s, _(""No next hunk""));
",,
implicit_predicate,add-patch.c,1624,+,-,"if (ret){
    char errbuf[1024];
    regerror(ret, &regex, errbuf, sizeof (errbuf));
    err(s, _(""Malformed search regexp %s: %s""), s->answer.buf, errbuf);
    continue;
}
",,
implicit_predicate,add-patch.c,1631,+,-,"if (ret){
    char errbuf[1024];
    regerror(ret, &regex, errbuf, sizeof (errbuf));
    err(s, _(""Malformed search regexp %s: %s""), s->answer.buf, errbuf);
    continue;
}
",,
implicit_predicate,add-patch.c,1712,+,-,"if (s->mode->apply_for_checkout)
    apply_for_checkout(s, &s->buf, s->mode->is_reverse);
else{
    setup_child_process(s, &cp, ""apply"", NULL);
    strvec_pushv(&cp.args, s->mode->apply_args);
    if (pipe_command(&cp, s->buf.buf, s->buf.len, NULL, 0, NULL, 0))
        error(_(""'git apply' failed""));
}
",,
implicit_predicate,add-patch.c,1719,+,-,"if (s->mode->apply_for_checkout)
    apply_for_checkout(s, &s->buf, s->mode->is_reverse);
else{
    setup_child_process(s, &cp, ""apply"", NULL);
    strvec_pushv(&cp.args, s->mode->apply_args);
    if (pipe_command(&cp, s->buf.buf, s->buf.len, NULL, 0, NULL, 0))
        error(_(""'git apply' failed""));
}
",,
implicit_predicate,add.c,119,+,+,verbose ? REFRESH_IN_PORCELAIN : REFRESH_QUIET,8,		    (verbose ? REFRESH_IN_PORCELAIN : REFRESH_QUIET);
implicit_predicate,add.c,165,+,-,"if (patch)
    ret = !!run_add_p(the_repository, ADD_P_ADD, NULL, &pathspec);
else
    ret = !!run_add_i(the_repository, &pathspec);
",,
implicit_predicate,add.c,381,+,-,"if (patch_interactive)
    add_interactive = 1;
",,
implicit_predicate,add.c,383,+,-,"if (add_interactive){
    if (show_only)
        die(_(""options '%s' and '%s' cannot be used together""), ""--dry-run"", ""--interactive/--patch"");

    if (pathspec_from_file)
        die(_(""options '%s' and '%s' cannot be used together""), ""--pathspec-from-file"", ""--interactive/--patch"");

    exit(interactive_add(argv + 1, prefix, patch_interactive));
}
",,
implicit_predicate,add.c,384,+,-,"if (show_only)
    die(_(""options '%s' and '%s' cannot be used together""), ""--dry-run"", ""--interactive/--patch"");
",,
implicit_predicate,add.c,391,+,-,"if (edit_interactive){
    if (pathspec_from_file)
        die(_(""options '%s' and '%s' cannot be used together""), ""--pathspec-from-file"", ""--edit"");

    return (edit_patch(argc, argv, prefix));
}
",,
implicit_predicate,add.c,439,+,-,"if (pathspec_file_nul){
    die(_(""the option '%s' requires '%s'""), ""--pathspec-file-nul"", ""--pathspec-from-file"");
}
",,
implicit_predicate,add.c,454,+,+,verbose ? ADD_CACHE_VERBOSE : 0,12,	flags = ((verbose ? ADD_CACHE_VERBOSE : 0) |
implicit_predicate,add.c,455,+,+,show_only ? ADD_CACHE_PRETEND : 0,5,		 (show_only ? ADD_CACHE_PRETEND : 0) |
implicit_predicate,add.c,456,+,+,intent_to_add ? ADD_CACHE_INTENT : 0,5,		 (intent_to_add ? ADD_CACHE_INTENT : 0) |
implicit_predicate,add.c,457,+,+,ignore_add_errors ? ADD_CACHE_IGNORE_ERRORS : 0,5,		 (ignore_add_errors ? ADD_CACHE_IGNORE_ERRORS : 0) |
implicit_predicate,add.c,467,+,-,"if (add_new_files){
    int baselen;
    if (!ignored_too){
        dir.flags |= DIR_COLLECT_IGNORED;
        setup_standard_excludes(&dir);
    }
    baselen = fill_directory(&dir, the_repository->index, &pathspec);
    if (pathspec.nr)
        seen = prune_directory(&dir, &pathspec, baselen);
}
",,
implicit_predicate,add.c,482,+,-,"if (refresh_only){
    exit_status |= refresh(verbose, &pathspec);
    goto finish;
}
",,
implicit_predicate,add.c,512,+,-,"if (seen[i])
    continue;
",,
implicit_predicate,add.c,528,+,-,"if (ignore_missing){
    int dtype = DT_UNKNOWN;
    if (is_excluded(&dir, the_repository->index, path, &dtype))
        dir_add_ignored(&dir, the_repository->index, path, pathspec.items[i].len);
}else
    die(_(""pathspec '%s' did not match any files""), pathspec.items[i].original);
",,
implicit_predicate,add.c,553,+,-,"if (add_renormalize)
    exit_status |= renormalize_tracked_files(&pathspec, flags);
else
    exit_status |= add_files_to_cache(the_repository, prefix, &pathspec, ps_matched, include_sparse, flags);
",,
implicit_predicate,add.c,564,+,-,"if (add_new_files)
    exit_status |= add_files(&dir, flags);
",,
implicit_predicate,advice.c,104,+,-,"if (display_instructions)
    strbuf_addf(&buf, turn_off_instructions, key);
",,
implicit_predicate,advice.c,183,-,+,,29,"		advice_setting[i].level = git_config_bool(var, value)
					  ? ADVICE_LEVEL_ENABLED
					  : ADVICE_LEVEL_DISABLED;"
implicit_predicate,alias.c,116,+,-,"if (quoted){
    FREE_AND_NULL(*argv);
    return -SPLIT_CMDLINE_UNCLOSED_QUOTE;
}
",,
implicit_predicate,am.c,176,+,+,"gpgsign ? """" : NULL",24,"		state->sign_commit = gpgsign ? """" : NULL;"
implicit_predicate,am.c,247,+,+,"value ? ""t"" : ""f""",32,"	write_state_text(state, name, value ? ""t"" : ""f"");"
implicit_predicate,am.c,294,+,-,"if (trim)
    strbuf_trim(sb);
",,
implicit_predicate,am.c,429,-,+,,36,"		state->allow_rerere_autoupdate = strcmp(sb.buf, ""t"") ?
			RERERE_NOAUTOUPDATE : RERERE_AUTOUPDATE;"
implicit_predicate,am.c,708,+,-,"if (keep_cr)
    strvec_push(&cp.args, ""--keep-cr"");
",,
implicit_predicate,am.c,710,+,-,"if (mboxrd)
    strvec_push(&cp.args, ""--mboxrd"");
",,
implicit_predicate,am.c,716,+,-,"if (ret)
    goto exit;
",,
implicit_predicate,am.c,724,+,+,ret ? -1 : 0,9,	return ret ? -1 : 0;
implicit_predicate,am.c,779,+,-,"if (ret)
    return error(_(""could not parse patch '%s'""), *paths);
",,
implicit_predicate,am.c,1012,+,-,"if (state->rebasing)
    state->threeway = 1;
",,
implicit_predicate,am.c,1020,+,-,"if (state->allow_rerere_autoupdate)
    write_state_bool(state, ""rerere-autoupdate"", state->allow_rerere_autoupdate == RERERE_AUTOUPDATE);
",,
implicit_predicate,am.c,1077,+,-,"if (state->rebasing)
    write_state_text(state, ""rebasing"", """");
else
    write_state_text(state, ""applying"", """");
",,
implicit_predicate,am.c,1160,-,+,,25,"		const char *cmdline = state->interactive ? ""git am -i"" : ""git am"";"
implicit_predicate,am.c,1214,+,-,"if (state->utf8)
    mi.metainfo_charset = get_commit_output_encoding();
else
    mi.metainfo_charset = NULL;
",,
implicit_predicate,am.c,1232,+,-,"if (state->message_id)
    mi.add_message_id = 1;
",,
implicit_predicate,am.c,1540,+,-,"if (res)
    return res;
",,
implicit_predicate,am.c,1585,+,-,"if (build_fake_ancestor(state, index_path))
    return error(""could not build fake ancestor"");
",,
implicit_predicate,am.c,1613,+,-,"if (run_apply(state, index_path))
    return error(_(""Did you hand edit your patch?\nIt does not apply to blobs recorded in its index.""));
",,
implicit_predicate,am.c,1683,-,+,,4,"			state->ignore_date ? NULL : state->author_date,"
implicit_predicate,am.c,1690,-,+,,11,"				      state->ignore_date ? NULL
							 : state->author_date,"
implicit_predicate,am.c,1829,+,-,"if (resume){
    validate_resume_state(state);
}else{
    int skip;
    if (state->rebasing)
        skip = parse_mail_rebase(state, mail);
    else
        skip = parse_mail(state, mail);

    if (skip)
        goto next;

    if (state->signoff)
        am_append_signoff(state);

    write_author_script(state);
    write_commit_msg(state);
}
",,
implicit_predicate,am.c,1834,+,-,"if (state->rebasing)
    skip = parse_mail_rebase(state, mail);
else
    skip = parse_mail(state, mail);
",,
implicit_predicate,am.c,1839,+,-,"if (skip)
    goto next;
",,
implicit_predicate,am.c,1842,+,-,"if (state->signoff)
    am_append_signoff(state);
",,
implicit_predicate,am.c,1871,+,-,"if (run_applypatch_msg_hook(state))
    exit(1);
",,
implicit_predicate,am.c,1873,+,-,"if (to_keep)
    goto commit;
",,
implicit_predicate,am.c,1898,+,-,"if (apply_status){
    printf_ln(_(""Patch failed at %s %.*s""), msgnum(state), linelen(state->msg), state->msg);
    if (advice_enabled (ADVICE_AM_WORK_DIR))
        advise(_(""Use 'git am --show-current-patch=diff' to see the failed patch""));

    die_user_resolve(state);
}
",,
implicit_predicate,am.c,1914,+,-,"if (resume)
    am_load(state);
",,
implicit_predicate,am.c,1965,+,-,"if (state->interactive){
    write_index_patch(state);
    if (do_interactive(state))
        goto next;
}
",,
implicit_predicate,am.c,1967,+,-,"if (do_interactive(state))
    goto next;
",,
implicit_predicate,am.c,2005,+,+,reset ? UNPACK_RESET_PROTECT_UNTRACKED : 0,15,	opts.reset = reset ? UNPACK_RESET_PROTECT_UNTRACKED : 0;
implicit_predicate,am.c,2075,+,-,"if (fast_forward_to(head_tree, head_tree, 1))
    return -1;
",,
implicit_predicate,am.c,2085,+,-,"if (fast_forward_to(index_tree, remote_tree, 0))
    return -1;
",,
implicit_predicate,am.c,2088,+,-,"if (merge_tree(remote_tree))
    return -1;
",,
implicit_predicate,am.c,2118,+,-,"if (clean_index(&head, &head))
    die(_(""failed to clean index""));
",,
implicit_predicate,am.c,2121,+,-,"if (state->rebasing){
    FILE* fp = xfopen(am_path(state, ""rewritten""), ""a"");
    assert(!is_null_oid(&state->orig_commit));
    fprintf(fp, ""%s "", oid_to_hex(&state->orig_commit));
    fprintf(fp, ""%s\n"", oid_to_hex(&head));
    fclose(fp);
}
",,
implicit_predicate,am.c,2195,+,-,"if (clean_index(&curr_head, &orig_head))
    die(_(""failed to clean index""));
",,
implicit_predicate,am.c,2198,+,-,"if (has_orig_head)
    refs_update_ref(get_main_ref_store(the_repository), ""am --abort"", ""HEAD"", &orig_head, has_curr_head ? &curr_head : NULL, 0, UPDATE_REFS_DIE_ON_ERR);
else
    if (curr_branch)
        refs_delete_ref(get_main_ref_store(the_repository), NULL, curr_branch, NULL, REF_NO_DEREF);
",,
implicit_predicate,am.c,2201,+,+,has_curr_head ? &curr_head : NULL,5,"				has_curr_head ? &curr_head : NULL, 0,"
implicit_predicate,am.c,2255,+,-,"if (unset)
    *opt_value = PATCH_FORMAT_UNKNOWN;
else
    if (!strcmp(arg, ""mbox""))
        *opt_value = PATCH_FORMAT_MBOX;
    else
        if (!strcmp(arg, ""stgit""))
            *opt_value = PATCH_FORMAT_STGIT;
        else
            if (!strcmp(arg, ""stgit-series""))
                *opt_value = PATCH_FORMAT_STGIT_SERIES;
            else
                if (!strcmp(arg, ""hg""))
                    *opt_value = PATCH_FORMAT_HG;
                else
                    if (!strcmp(arg, ""mboxrd""))
                        *opt_value = PATCH_FORMAT_MBOXRD;
                    else
                        return error(_(""invalid value for '%s': '%s'""), ""--patch-format"", arg);
",,
implicit_predicate,am.c,2424,+,-,"if (in_progress)
    am_load(&state);
",,
implicit_predicate,am.c,2439,+,-,"if (in_progress){
    if (argc || (resume_mode == RESUME_FALSE && !isatty(0)))
        die(_(""previous rebase directory %s still exists but mbox given.""), state.dir);

    if (resume_mode == RESUME_FALSE)
        resume_mode = RESUME_APPLY;

    if (state.signoff == SIGNOFF_EXPLICIT)
        am_append_signoff(&state);
}else{
    struct strvec paths = STRVEC_INIT;
    int i;
    if (file_exists(state.dir) && !state.rebasing){
        if (resume_mode == RESUME_ABORT || resume_mode == RESUME_QUIT){
            am_destroy(&state);
            am_state_release(&state);
            return 0;
        }
        die(_(""Stray %s directory found.\nUse \""git am --abort\"" to remove it.""), state.dir);
    }
    if (resume_mode)
        die(_(""Resolve operation not in progress, we are not resuming.""));

    for (i = 0;i < argc;i++){
        if (is_absolute_path(argv[i]) || !prefix)
            strvec_push(&paths, argv[i]);
        else
            strvec_push(&paths, mkpath(""%s/%s"", prefix, argv[i]));
    }
    if (state.interactive && !paths.nr)
        die(_(""interactive mode requires patches on the command line""));

    am_setup(&state, patch_format, paths.v, keep_cr);
    strvec_clear(&paths);
}
",,
implicit_predicate,anonymously-parsed-code.c,3,+,-,<!!!>,,
implicit_predicate,anonymously-parsed-code.c,11,+,-,"do{
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,12,+,-,"do{
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,13,+,-,"do{
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,15,+,-,"do{
    if (c != 0){
        fflush (stderr);
        fflush (stdout);
        fprintf(stderr, ""%s: %d: error == %d (%s), want 0\n"", __FILE__, __LINE__, c, reftable_error_str(c));
        abort();
    }
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,26,+,-,<!!!>,,
implicit_predicate,anonymously-parsed-code.c,30,+,-,"do{
    if (err){
        die(pattern, (long )CFErrorGetCode(err));
    }
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,31,+,-,"do{
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,33,+,-,"do{
    if ((nr) <= 2)
        (x) = xalloca((nr) * sizeof (*(x)));
    else
        ALLOC_ARRAY((x), nr);
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,37,+,-,"do{
    unsigned char* __p = (unsigned char*)(p);
    *__p++ = (unsigned char)(v);
    *__p++ = (unsigned char)((v) >> 8);
    *__p++ = (unsigned char)((v) >> 16);
    *__p = (unsigned char)((v) >> 24);
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,38,+,-,"do{
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,39,+,-,"do{
    W (x) = (val);

    asm("""" :: : ""memory"");
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,43,+,-,"do{
    if (cmd& (bit)){
        if (data >= top)
            goto bad_length;

        var |= ((unsigned )*data++ << (shift));
    }
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,45,+,-,"do{
    const unsigned char* __p = (const unsigned char*)(p);
    (v) = (unsigned long )__p[0] | ((unsigned long )__p[1]) << 8 | ((unsigned long )__p[2]) << 16 | ((unsigned long )__p[3]) << 24;
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,52,+,-,"do{
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,53,+,-,"do{
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,54,+,-,"do{
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,58,+,-,"do{
    if ((ps)->magic & ~(mask))
        BUG(""unsupported magic %x"", (ps)->magic & ~(mask));
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,60,+,-,"do{
    if ((nr) > alloc){
        alloc = 2 * (alloc) + 1;
        if (alloc < (nr))
            alloc = (nr);

        REFTABLE_REALLOC_ARRAY(x, alloc);
    }
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,90,+,-,"do;

 while (0);
",,
implicit_predicate,anonymously-parsed-code.c,92,+,-,"do{
    r((a), (f));
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,93,+,-,"do{
    int __i__, __C__ = (c);
    for (__i__ = 0;__i__ < __C__;__i__++)
        r(&(a)[__i__], f);
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,97,+,-,"do{
    int __i__, __C__ = (c), __S__ = (s);
    for (__i__ = 0;__i__ < __C__;__i__++)
        r(&(a)[__i__ * __S__], f, __S__);
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,98,+,-,"do{
    (a)->commonattr = (a)->volattr = (a)->dirattr = (a)->fileattr = (a)->forkattr = 0;
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,99,+,-,"do{
    if (((t1)->tv_nsec += (t2)->tv_nsec) >= (long )NSEC_PER_SEC){
        (t1)->tv_nsec -= (long )NSEC_PER_SEC;
        (t1)->tv_sec += 1;
    }
    (t1)->tv_sec += (t2)->tv_sec;
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,104,+,-,"do{
    *(a) = rs(a);
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,107,+,-,"do{
    struct kevent* __kevp__ = (kevp);
    __kevp__->ident = (a);
    __kevp__->filter = (b);
    __kevp__->flags = (c);
    __kevp__->fflags = (d);
    __kevp__->data = (e);
    __kevp__->udata = (f);
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,109,+,-,"do{
    if (((t1)->tv_nsec -= (t2)->tv_nsec) < 0){
        (t1)->tv_nsec += (long )NSEC_PER_SEC;
        (t1)->tv_sec -= 1;
    }
    (t1)->tv_sec -= (t2)->tv_sec;
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,112,+,-,"do{
    if ((prefix))
        BUG(""unexpected prefix in builtin: %s"", (prefix));
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,117,+,-,"do{
    struct kevent64_s* __kevp__ = (kevp);
    __kevp__->ident = (a);
    __kevp__->filter = (b);
    __kevp__->flags = (c);
    __kevp__->fflags = (d);
    __kevp__->data = (e);
    __kevp__->udata = (f);
    __kevp__->ext[0] = (g);
    __kevp__->ext[1] = (h);
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,118,+,-,"do{
    if ((h)->use_extra_arg)
        (*(h)->freefun.extra)((h)->extra_arg, (old_chunk));
    else
        (*(h)->freefun.plain)((old_chunk));
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,149,+,-,"do{
    (vvp)->tv_sec = (tvp)->tv_sec + (uvp)->tv_sec;
    (vvp)->tv_usec = (tvp)->tv_usec + (uvp)->tv_usec;
    if ((vvp)->tv_usec >= 1000000){
        (vvp)->tv_sec++;
        (vvp)->tv_usec -= 1000000;
    }
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,156,+,-,"do{
    (q)->queue = NULL;
    (q)->nr = (q)->alloc = 0;
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,157,+,-,"do{
    (x) = (void*)-1;
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,158,+,-,"do{
    (vvp)->tv_sec = (tvp)->tv_sec - (uvp)->tv_sec;
    (vvp)->tv_usec = (tvp)->tv_usec - (uvp)->tv_usec;
    if ((vvp)->tv_usec < 0){
        (vvp)->tv_sec--;
        (vvp)->tv_usec += 1000000;
    }
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,159,+,-,"do{
    (head)->trace.prevline = (head)->trace.lastline;
    (head)->trace.prevfile = (head)->trace.lastfile;
    (head)->trace.lastline = __LINE__;
    (head)->trace.lastfile = __FILE__;
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,166,+,-,"do{
    (elem)->trace.prevline = (elem)->trace.lastline;
    (elem)->trace.prevfile = (elem)->trace.lastfile;
    (elem)->trace.lastline = __LINE__;
    (elem)->trace.lastfile = __FILE__;
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,170,+,-,"do{
    if (trace_pass_fl (key))
        trace_printf_key_fl(TRACE_CONTEXT, __LINE__, key, __VA_ARGS__);
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,182,+,-,"do{
    if (trace_pass_fl (&trace_default_key))
        trace_argv_printf_fl(TRACE_CONTEXT, __LINE__, argv, __VA_ARGS__);
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,195,+,-,"do{
    if (trace_pass_fl (key))
        trace_strbuf_fl(TRACE_CONTEXT, __LINE__, key, data);
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,198,+,-,"do{
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,217,+,-,"do{
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,218,+,-,"do{
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,219,+,-,"do{
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,238,+,-,"do{
    if (trace_pass_fl (&trace_perf_key))
        trace_performance_fl(TRACE_CONTEXT, __LINE__, getnanotime() - (start), __VA_ARGS__);
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,249,+,-,"do{
    if (trace_pass_fl (&trace_perf_key))
        trace_performance_leave_fl(TRACE_CONTEXT, __LINE__, getnanotime(), __VA_ARGS__);
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,269,+,-,"do{
    if (sb)
        strbuf_addch(sb, (c));

    if (fp)
        fputc((c), fp);

    count++;
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,275,+,-,"do{
    if (sb)
        strbuf_add(sb, (s), (l));

    if (fp)
        fwrite((s), (l), 1, fp);

    count += (l);
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,277,+,-,"do{
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,279,+,-,"do{
    SLIST_FIRST ((head)) = NULL;
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,283,+,-,"do{
    SLIST_NEXT((elm), field) = SLIST_NEXT((slistelm), field);
    SLIST_NEXT((slistelm), field) = (elm);
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,288,+,-,"do{
    SLIST_NEXT((elm), field) = SLIST_FIRST((head));
    SLIST_FIRST ((head)) = (elm);
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,302,+,-,<!!!>,,
implicit_predicate,anonymously-parsed-code.c,313,+,-,"do{
    SLIST_NEXT(elm, field) = SLIST_NEXT(SLIST_NEXT(elm, field), field);
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,318,+,-,"do{
    SLIST_FIRST ((head)) = SLIST_NEXT(SLIST_FIRST((head)), field);
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,326,+,-,"do{
    if (dst == end)
        BUG(""color parsing ran out of space"");

    *dst++ = (x);
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,337,+,-,<!!!>,,
implicit_predicate,anonymously-parsed-code.c,338,+,-,<!!!>,,
implicit_predicate,anonymously-parsed-code.c,340,+,-,<!!!>,,
implicit_predicate,anonymously-parsed-code.c,350,+,-,"do{
    if (!STAILQ_EMPTY((head2))){
        *(head1)->stqh_last = (head2)->stqh_first;
        (head1)->stqh_last = (head2)->stqh_last;
        STAILQ_INIT ((head2));
    }
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,373,+,-,"do{
    STAILQ_FIRST ((head)) = NULL;
    (head)->stqh_last = &STAILQ_FIRST((head));
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,375,+,-,<!!!>,,
implicit_predicate,anonymously-parsed-code.c,378,+,-,"do{
    if ((STAILQ_NEXT((elm), field) = STAILQ_NEXT((tqelm), field)) == NULL)
        (head)->stqh_last = &STAILQ_NEXT((elm), field);

    STAILQ_NEXT((tqelm), field) = (elm);
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,384,+,-,"do{
    if ((STAILQ_NEXT((elm), field) = STAILQ_FIRST((head))) == NULL)
        (head)->stqh_last = &STAILQ_NEXT((elm), field);

    STAILQ_FIRST ((head)) = (elm);
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,390,+,-,"do{
    STAILQ_NEXT((elm), field) = NULL;
    *(head)->stqh_last = (elm);
    (head)->stqh_last = &STAILQ_NEXT((elm), field);
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,411,+,-,<!!!>,,
implicit_predicate,anonymously-parsed-code.c,426,+,-,"do{
    if ((unset))
        BUG(""option callback does not expect negation"");
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,430,+,-,"do{
    if ((arg))
        BUG(""option callback does not expect an argument"");
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,432,+,-,"do{
    if ((STAILQ_FIRST((head)) = STAILQ_NEXT((elm), field)) == NULL)
        (head)->stqh_last = &STAILQ_FIRST((head));
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,437,+,-,"do{
    if ((STAILQ_NEXT(elm, field) = STAILQ_NEXT(STAILQ_NEXT(elm, field), field)) == NULL)
        (head)->stqh_last = &STAILQ_NEXT((elm), field);
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,440,+,-,"do{
    BUG_ON_OPT_NEG (unset);
    if (!(arg))
        BUG(""option callback expects an argument"");
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,442,+,-,"do{
    if (!(assertion)){
    }
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,450,+,-,<!!!>,,
implicit_predicate,anonymously-parsed-code.c,487,+,-,"do{
    if (!(assertion)){
    }
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,495,+,-,<!!!>,,
implicit_predicate,anonymously-parsed-code.c,497,+,-,"do{
    int e = (err);
    if (e)
        BUG(""%s: %s"", msg, strerror(e));
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,509,+,-,"do{
    LIST_FIRST ((head)) = NULL;
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,513,+,-,"do{
    LIST_CHECK_NEXT(listelm, field);
    if ((LIST_NEXT((elm), field) = LIST_NEXT((listelm), field)) != NULL)
        LIST_NEXT((listelm), field)->field.le_prev = &LIST_NEXT((elm), field);

    LIST_NEXT((listelm), field) = (elm);
    (elm)->field.le_prev = &LIST_NEXT((listelm), field);
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,522,+,-,"do{
    LIST_CHECK_PREV(listelm, field);
    (elm)->field.le_prev = (listelm)->field.le_prev;
    LIST_NEXT((elm), field) = (listelm);
    *(listelm)->field.le_prev = (elm);
    (listelm)->field.le_prev = &LIST_NEXT((elm), field);
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,529,+,-,"do{
    if (0 != (errorCode)){
    }
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,530,+,-,"do{
    LIST_CHECK_HEAD((head), field);
    if ((LIST_NEXT((elm), field) = LIST_FIRST((head))) != NULL)
        LIST_FIRST((head))->field.le_prev = &LIST_NEXT((elm), field);

    LIST_FIRST ((head)) = (elm);
    (elm)->field.le_prev = &LIST_FIRST((head));
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,537,+,-,<!!!>,,
implicit_predicate,anonymously-parsed-code.c,540,+,-,"do{
    LIST_CHECK_NEXT(elm, field);
    LIST_CHECK_PREV(elm, field);
    if (LIST_NEXT((elm), field) != NULL)
        LIST_NEXT((elm), field)->field.le_prev = (elm)->field.le_prev;

    *(elm)->field.le_prev = LIST_NEXT((elm), field);
    TRASHIT((elm)->field.le_next);
    TRASHIT((elm)->field.le_prev);
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,571,+,-,"do{
    if (0 != (errorCode)){
    }
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,579,+,-,<!!!>,,
implicit_predicate,anonymously-parsed-code.c,581,+,-,"do{
    uint64_t _n = (n);
    if ((_n & (SPARSE_PROGRESS_INTERVAL - 1)) == 0)
        display_progress(progress, _n);
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,601,+,-,"do{
    if (!TAILQ_EMPTY(head2)){
        *(head1)->tqh_last = (head2)->tqh_first;
        (head2)->tqh_first->field.tqe_prev = (head1)->tqh_last;
        (head1)->tqh_last = (head2)->tqh_last;
        TAILQ_INIT ((head2));
        QMD_TRACE_HEAD (head1);
        QMD_TRACE_HEAD(head2);
    }
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,620,+,-,<!!!>,,
implicit_predicate,anonymously-parsed-code.c,622,+,-,"do{
    (ci) = (!(mi) || (mi)->clean) ? NULL : (struct conflict_info*)(mi);
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,626,+,-,"do{
    (ci) = (struct conflict_info*)(mi);
    assert((ci) && !(mi)->clean);
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,637,+,-,"do{
    TAILQ_FIRST ((head)) = NULL;
    (head)->tqh_last = &TAILQ_FIRST((head));
    QMD_TRACE_HEAD(head);
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,644,+,-,"do{
    TAILQ_CHECK_NEXT(listelm, field);
    if ((TAILQ_NEXT((elm), field) = TAILQ_NEXT((listelm), field)) != NULL)
        TAILQ_NEXT((elm), field)->field.tqe_prev = &TAILQ_NEXT((elm), field);
    else{
        (head)->tqh_last = &TAILQ_NEXT((elm), field);
        QMD_TRACE_HEAD (head);
    }
    TAILQ_NEXT((listelm), field) = (elm);
    (elm)->field.tqe_prev = &TAILQ_NEXT((listelm), field);
    QMD_TRACE_ELEM(&(elm)->field);
    QMD_TRACE_ELEM(&listelm->field);
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,659,+,-,"do{
    TAILQ_CHECK_PREV(listelm, field);
    (elm)->field.tqe_prev = (listelm)->field.tqe_prev;
    TAILQ_NEXT((elm), field) = (listelm);
    *(listelm)->field.tqe_prev = (elm);
    (listelm)->field.tqe_prev = &TAILQ_NEXT((elm), field);
    QMD_TRACE_ELEM(&(elm)->field);
    QMD_TRACE_ELEM(&listelm->field);
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,669,+,-,"do{
    TAILQ_CHECK_HEAD(head, field);
    if ((TAILQ_NEXT((elm), field) = TAILQ_FIRST((head))) != NULL)
        TAILQ_FIRST((head))->field.tqe_prev = &TAILQ_NEXT((elm), field);
    else
        (head)->tqh_last = &TAILQ_NEXT((elm), field);

    TAILQ_FIRST ((head)) = (elm);
    (elm)->field.tqe_prev = &TAILQ_FIRST((head));
    QMD_TRACE_HEAD(head);
    QMD_TRACE_ELEM(&(elm)->field);
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,682,+,-,"do{
    TAILQ_NEXT((elm), field) = NULL;
    (elm)->field.tqe_prev = (head)->tqh_last;
    *(head)->tqh_last = (elm);
    (head)->tqh_last = &TAILQ_NEXT((elm), field);
    QMD_TRACE_HEAD (head);
    QMD_TRACE_ELEM(&(elm)->field);
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,691,+,-,"do{
    if (__builtin_expect(!(assertion), 0)){
        goto exceptionLabel;
    }
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,700,+,-,<!!!>,,
implicit_predicate,anonymously-parsed-code.c,707,+,-,"do{
    TAILQ_CHECK_NEXT(elm, field);
    TAILQ_CHECK_PREV(elm, field);
    if ((TAILQ_NEXT((elm), field)) != NULL)
        TAILQ_NEXT((elm), field)->field.tqe_prev = (elm)->field.tqe_prev;
    else{
        (head)->tqh_last = (elm)->field.tqe_prev;
        QMD_TRACE_HEAD (head);
    }
    *(elm)->field.tqe_prev = TAILQ_NEXT((elm), field);
    TRASHIT((elm)->field.tqe_next);
    TRASHIT((elm)->field.tqe_prev);
    QMD_TRACE_ELEM(&(elm)->field);
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,713,+,-,"do{
    mstate m = GetMSpace((p), (tc), (ms), (s));
    action;
    RELEASE_LOCK(&m->mutex);
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,742,+,-,"do{
    if (__builtin_expect(!(assertion), 0)){
        {
            action;
        }
        goto exceptionLabel;
    }
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,754,+,-,<!!!>,,
implicit_predicate,anonymously-parsed-code.c,773,+,-,"do{
    void* _swap_a_ptr = &(a);
    void* _swap_b_ptr = &(b);
    unsigned char _swap_buffer[sizeof (a)];
    memcpy(_swap_buffer, _swap_a_ptr, sizeof (a));
    memcpy(_swap_a_ptr, _swap_b_ptr, sizeof (a) + BUILD_ASSERT_OR_ZERO(sizeof (a) == sizeof (b)));
    memcpy(_swap_b_ptr, _swap_buffer, sizeof (a));
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,787,+,-,"do{
    (head)->cqh_first = (void*)(head);
    (head)->cqh_last = (void*)(head);
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,791,+,-,"do{
    if (__builtin_expect(!(assertion), 0)){
        goto exceptionLabel;
    }
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,792,+,-,"do{
    CIRCLEQ_CHECK_NEXT(head, listelm, field);
    (elm)->field.cqe_next = (listelm)->field.cqe_next;
    (elm)->field.cqe_prev = (listelm);
    if ((listelm)->field.cqe_next == (void*)(head))
        (head)->cqh_last = (elm);
    else
        (listelm)->field.cqe_next->field.cqe_prev = (elm);

    (listelm)->field.cqe_next = (elm);
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,803,+,-,"do{
    CIRCLEQ_CHECK_PREV(head, listelm, field);
    (elm)->field.cqe_next = (listelm);
    (elm)->field.cqe_prev = (listelm)->field.cqe_prev;
    if ((listelm)->field.cqe_prev == (void*)(head))
        (head)->cqh_first = (elm);
    else
        (listelm)->field.cqe_prev->field.cqe_next = (elm);

    (listelm)->field.cqe_prev = (elm);
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,814,+,-,"do{
    CIRCLEQ_CHECK_HEAD(head, field);
    (elm)->field.cqe_next = (head)->cqh_first;
    (elm)->field.cqe_prev = (void*)(head);
    if ((head)->cqh_last == (void*)(head))
        (head)->cqh_last = (elm);
    else
        (head)->cqh_first->field.cqe_prev = (elm);

    (head)->cqh_first = (elm);
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,824,+,-,"do{
    if (__builtin_expect(!(assertion), 0)){
        {
            action;
        }
        goto exceptionLabel;
    }
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,825,+,-,"do{
    (elm)->field.cqe_next = (void*)(head);
    (elm)->field.cqe_prev = (head)->cqh_last;
    if ((head)->cqh_first == (void*)(head))
        (head)->cqh_first = (elm);
    else
        (head)->cqh_last->field.cqe_next = (elm);

    (head)->cqh_last = (elm);
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,841,+,-,"do{
    CIRCLEQ_CHECK_NEXT(head, elm, field);
    CIRCLEQ_CHECK_PREV(head, elm, field);
    if ((elm)->field.cqe_next == (void*)(head))
        (head)->cqh_last = (elm)->field.cqe_prev;
    else
        (elm)->field.cqe_next->field.cqe_prev = (elm)->field.cqe_prev;

    if ((elm)->field.cqe_prev == (void*)(head))
        (head)->cqh_first = (elm)->field.cqe_next;
    else
        (elm)->field.cqe_prev->field.cqe_next = (elm)->field.cqe_next;
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,865,+,-,"do{
    if (__builtin_expect(!(assertion), 0)){
        goto exceptionLabel;
    }
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,867,+,-,"do{
    (buf)->theString = str;
    (buf)->rangeToBuffer = range;
    (buf)->directCStringBuffer = ((buf)->directUniCharBuffer = CFStringGetCharactersPtr(str)) ? NULL : CFStringGetCStringPtr(str, kCFStringEncodingASCII);
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,874,+,-,<!!!>,,
implicit_predicate,anonymously-parsed-code.c,921,+,-,"do{
    if (__builtin_expect(!(assertion), 0)){
        {
            action;
        }
        goto exceptionLabel;
    }
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,933,+,-,<!!!>,,
implicit_predicate,anonymously-parsed-code.c,975,+,-,"do{
    if (__builtin_expect(0 != (errorCode), 0)){
        goto exceptionLabel;
    }
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,984,+,-,<!!!>,,
implicit_predicate,anonymously-parsed-code.c,1024,+,-,"do{
    if (__builtin_expect(0 != (errorCode), 0)){
        {
            action;
        }
        goto exceptionLabel;
    }
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,1036,+,-,<!!!>,,
implicit_predicate,anonymously-parsed-code.c,1070,+,-,"do{
    if (__builtin_expect(0 != (errorCode), 0)){
        goto exceptionLabel;
    }
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,1073,+,-,"do{
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,1083,+,-,"do{
    free (p);
    (p) = NULL;
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,1100,+,-,"do{
    if (__builtin_expect(0 != (errorCode), 0)){
        {
            action;
        }
        goto exceptionLabel;
    }
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,1105,+,-,"do{
    size_t dup_array_n_ = (n);
    COPY_ARRAY(ALLOC_ARRAY((dst), dup_array_n_), (src), dup_array_n_);
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,1136,+,-,"do{
    if (__builtin_expect(0 != (errorCode), 0)){
        goto exceptionLabel;
    }
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,1145,+,-,<!!!>,,
implicit_predicate,anonymously-parsed-code.c,1151,+,-,"do{
    size_t flex_array_len_ = (len);
    (x) = xcalloc(1, st_add3(sizeof (*(x)), flex_array_len_, 1));
    memcpy((void*)(x)->flexname, (buf), flex_array_len_);
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,1156,+,-,"do{
    size_t flex_array_len_ = (len);
    (x) = xcalloc(1, st_add3(sizeof (*(x)), flex_array_len_, 1));
    memcpy((x) + 1, (buf), flex_array_len_);
    (x)->ptrname = (void*)((x) + 1);
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,1188,+,-,"do{
    if (__builtin_expect(0 != (errorCode), 0)){
        {
            action;
        }
        goto exceptionLabel;
    }
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,1200,+,-,<!!!>,,
implicit_predicate,anonymously-parsed-code.c,1212,+,-,"do{
    if ((nr) > alloc){
        if (alloc_nr(alloc) < (nr))
            alloc = (nr);
        else
            alloc = alloc_nr(alloc);

        REALLOC_ARRAY(x, alloc);
    }
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,1230,+,-,"do{
    if (increase){
        size_t new_nr = nr + (increase);
        if (new_nr < nr)
            BUG(""negative growth in ALLOC_GROW_BY"");

        ALLOC_GROW(x, new_nr, alloc);
        memset((x) + nr, 0, sizeof (*(x)) * (increase));
        nr = new_nr;
    }
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,1348,+,-,"do{
    if (qsort_s((base), (n), sizeof (*(base)), compar, ctx))
        BUG(""qsort_s() failed"");
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,1422,+,-,"do{
    if (bug_called_must_BUG)
        BUG_fl(__FILE__, __LINE__, __VA_ARGS__);
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,1515,+,-,"do{
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,2980,+,-,"do{
    __m128 tmp3, tmp2, tmp1, tmp0;
    tmp0 = _mm_unpacklo_ps((row0), (row1));
    tmp2 = _mm_unpacklo_ps((row2), (row3));
    tmp1 = _mm_unpackhi_ps((row0), (row1));
    tmp3 = _mm_unpackhi_ps((row2), (row3));
    (row0) = _mm_movelh_ps(tmp0, tmp2);
    (row1) = _mm_movehl_ps(tmp2, tmp0);
    (row2) = _mm_movelh_ps(tmp1, tmp3);
    (row3) = _mm_movehl_ps(tmp3, tmp1);
} while (0);
",,
implicit_predicate,anonymously-parsed-code.c,3563,+,-,"do{
    if (BE(trans != NULL, 0)){
        for (i = 0;i < SBC_MAX;++i)
            if (ctype_func (i))
                bitset_set(sbcset, trans[i]);
    }else{
        for (i = 0;i < SBC_MAX;++i)
            if (ctype_func (i))
                bitset_set(sbcset, i);
    }
} while (0);
",,
implicit_predicate,apply.c,154,+,-,"if (is_not_gitdir)
    return error(_(""'%s' outside a repository""), ""--3way"");
",,
implicit_predicate,apply.c,168,+,-,"if (is_not_gitdir)
    return error(_(""'%s' outside a repository""), ""--cached"");
",,
implicit_predicate,apply.c,190,-,+,,29,		state->ws_error_action = (state->apply ? warn_on_ws_error : nowarn_ws_error);
implicit_predicate,apply.c,229,+,-,"if (list->free_patch)
    free((char*)list->patch);
",,
implicit_predicate,apply.c,432,+,-,"while (size--){
    len++;
    if (*buffer++ == '\n')
        break;
}
",,
implicit_predicate,apply.c,466,+,-,"while (name[i]){
    if ((name[j++] = name[i++]) == '/')
        while (name[i] == '/')
            i++;
}
",,
implicit_predicate,apply.c,491,+,-,"for (cp = name.buf;p_value;p_value--){
    cp = strchr(cp, '/');
    if (!cp){
        strbuf_release(&name);
        return NULL;
    }
    cp++;
}
",,
implicit_predicate,apply.c,683,+,-,"if (name_terminate(c, terminate))
    break;
",,
implicit_predicate,apply.c,763,+,-,"if (is_dev_null(nameline))
    return -1;
",,
implicit_predicate,apply.c,839,+,-,"if (status){
    if (status != REG_NOMATCH)
        warning(_(""regexec returned %d for input: %s""), status, timestamp);

    return 0;
}
",,
implicit_predicate,apply.c,886,+,-,"if (is_dev_null(first)){
    patch->is_new = 1;
    patch->is_delete = 0;
    name = find_name_traditional(&state->root, second, NULL, state->p_value);
    patch->new_name = name;
}else
    if (is_dev_null(second)){
        patch->is_new = 0;
        patch->is_delete = 1;
        name = find_name_traditional(&state->root, first, NULL, state->p_value);
        patch->old_name = name;
    }else{
        char* first_name;
        first_name = find_name_traditional(&state->root, first, NULL, state->p_value);
        name = find_name_traditional(&state->root, second, first_name, state->p_value);
        free(first_name);
        if (has_epoch_timestamp(first)){
            patch->is_new = 1;
            patch->is_delete = 0;
            patch->new_name = name;
        }else
            if (has_epoch_timestamp(second)){
                patch->is_new = 0;
                patch->is_delete = 1;
                patch->old_name = name;
            }else{
                patch->old_name = name;
                patch->new_name = xstrdup_or_null(name);
            }
    }
",,
implicit_predicate,apply.c,891,+,-,"if (is_dev_null(second)){
    patch->is_new = 0;
    patch->is_delete = 1;
    name = find_name_traditional(&state->root, first, NULL, state->p_value);
    patch->old_name = name;
}else{
    char* first_name;
    first_name = find_name_traditional(&state->root, first, NULL, state->p_value);
    name = find_name_traditional(&state->root, second, first_name, state->p_value);
    free(first_name);
    if (has_epoch_timestamp(first)){
        patch->is_new = 1;
        patch->is_delete = 0;
        patch->new_name = name;
    }else
        if (has_epoch_timestamp(second)){
            patch->is_new = 0;
            patch->is_delete = 1;
            patch->old_name = name;
        }else{
            patch->old_name = name;
            patch->new_name = xstrdup_or_null(name);
        }
}
",,
implicit_predicate,apply.c,901,+,-,"if (has_epoch_timestamp(first)){
    patch->is_new = 1;
    patch->is_delete = 0;
    patch->new_name = name;
}else
    if (has_epoch_timestamp(second)){
        patch->is_new = 0;
        patch->is_delete = 1;
        patch->old_name = name;
    }else{
        patch->old_name = name;
        patch->new_name = xstrdup_or_null(name);
    }
",,
implicit_predicate,apply.c,905,+,-,"if (has_epoch_timestamp(second)){
    patch->is_new = 0;
    patch->is_delete = 1;
    patch->old_name = name;
}else{
    patch->old_name = name;
    patch->new_name = xstrdup_or_null(name);
}
",,
implicit_predicate,apply.c,952,+,-,"if (isnull)
    return error(_(""git apply: bad git-diff - expected /dev/null, got %s on line %d""), *name, state->linenr);
",,
implicit_predicate,apply.c,1038,+,+,state->p_value ? state->p_value - 1 : 0,55,"	patch->old_name = find_name(state->root, line, NULL, state->p_value ? state->p_value - 1 : 0, 0);"
implicit_predicate,apply.c,1048,+,+,state->p_value ? state->p_value - 1 : 0,55,"	patch->new_name = find_name(state->root, line, NULL, state->p_value ? state->p_value - 1 : 0, 0);"
implicit_predicate,apply.c,1058,+,+,state->p_value ? state->p_value - 1 : 0,55,"	patch->old_name = find_name(state->root, line, NULL, state->p_value ? state->p_value - 1 : 0, 0);"
implicit_predicate,apply.c,1068,+,+,state->p_value ? state->p_value - 1 : 0,55,"	patch->new_name = find_name(state->root, line, NULL, state->p_value ? state->p_value - 1 : 0, 0);"
implicit_predicate,apply.c,1518,+,-,"if (ret){
    warning(_(""recount: unexpected line: %.*s""), (int)linelen(line, size), line);
    return;
}
",,
implicit_predicate,apply.c,1626,+,-,"if (parse_traditional_patch(state, line, line + len, patch))
    return -128;
",,
implicit_predicate,apply.c,1960,+,-,"while (1){
    int byte_length, max_byte_length, newsize;
    llen = linelen(buffer, size);
    used += llen;
    state->linenr++;
    if (llen == 1){
        buffer++;
        size--;
        break;
    }
    if ((llen < 7) || (llen - 2) % 5)
        goto corrupt;

    max_byte_length = (llen - 2) / 5 * 4;
    byte_length = *buffer;
    if ('A' <= byte_length && byte_length <= 'Z')
        byte_length = byte_length - 'A' + 1;
    else
        if ('a' <= byte_length && byte_length <= 'z')
            byte_length = byte_length - 'a' + 27;
        else
            goto corrupt;

    if (max_byte_length < byte_length || byte_length <= max_byte_length - 4)
        goto corrupt;

    newsize = hunk_size + byte_length;
    data = xrealloc(data, newsize);
    if (decode_85(data + hunk_size, buffer + 1, byte_length))
        goto corrupt;

    hunk_size = newsize;
    buffer += llen;
    size -= llen;
}
",,
implicit_predicate,apply.c,2055,+,-,"if (status)
    return status;
",,
implicit_predicate,apply.c,2062,+,-,"if (status){
    free((void*)forward->patch);
    free(forward);
    return status;
}
",,
implicit_predicate,apply.c,2105,+,+,exclude ? NULL : (void*)1,13,	it->util = exclude ? NULL : (void *) 1;
implicit_predicate,apply.c,2110,-,+,,25,	const char *pathname = p->new_name ? p->new_name : p->old_name;
implicit_predicate,apply.c,2186,+,-,"if (used)
    patchsize = used + llen;
else
    patchsize = 0;
",,
implicit_predicate,apply.c,2251,-,+,,13,	char *cp = patch->new_name ? patch->new_name : patch->old_name;
implicit_predicate,apply.c,2298,-,+,,19,"	int conv_flags = patch->crlf_in_old ?
		CONV_EOL_KEEP_CRLF : CONV_EOL_RENORMALIZE;"
implicit_predicate,apply.c,2407,-,+,,6,"	if (postlen
	    ? postlen < new_buf - postimage->buf
	    : postimage->len < new_buf - postimage->buf)"
implicit_predicate,apply.c,2444,+,-,"if (preimage->line[i].flag & LINE_COMMON)
    postlen += imglen - prelen;
",,
implicit_predicate,apply.c,2544,+,+,match_end ? (current + preimage->len == img->len) : (current + preimage->len <= img->len),8,"		if ((match_end
		     ? (current + preimage->len == img->len)
		     : (current + preimage->len <= img->len)) &&"
implicit_predicate,apply.c,2642,+,-,"if (preimage->line[i].flag & LINE_COMMON)
    postlen += tgtfix.len;
",,
implicit_predicate,apply.c,2719,+,-,"if (match_beginning)
    line = 0;
else
    if (match_end)
        line = img->nr - preimage->nr;
",,
implicit_predicate,apply.c,2721,+,-,"if (match_end)
    line = img->nr - preimage->nr;
",,
implicit_predicate,apply.c,2747,+,-,"if (match_fragment(state, img, preimage, postimage, current, current_lno, ws_rule, match_beginning, match_end))
    return current_lno;
",,
implicit_predicate,apply.c,2756,+,-,"if (i & 1){
    if (backwards_lno == 0){
        i++;
        goto again;
    }
    backwards_lno--;
    backwards -= img->line[backwards_lno].len;
    current = backwards;
    current_lno = backwards_lno;
}else{
    if (forwards_lno == img->nr){
        i++;
        goto again;
    }
    forwards += img->line[forwards_lno].len;
    forwards_lno++;
    current = forwards;
    current_lno = forwards_lno;
}
",,
implicit_predicate,apply.c,2980,+,-,"if (added_blank_line){
    if (!new_blank_lines_at_end)
        found_new_blank_lines_at_end = hunk_linenr;

    new_blank_lines_at_end++;
}else
    if (is_blank_context);

    else
        new_blank_lines_at_end = 0;
",,
implicit_predicate,apply.c,2985,+,-,"if (is_blank_context);

else
    new_blank_lines_at_end = 0;
",,
implicit_predicate,apply.c,3028,+,+,frag->newpos ? (frag->newpos - 1) : 0,8,	pos = frag->newpos ? (frag->newpos - 1) : 0;
implicit_predicate,apply.c,3078,+,-,"while (new_blank_lines_at_end--)
    remove_last_line(&postimage);
",,
implicit_predicate,apply.c,3180,-,+,,21,	const char *name = patch->old_name ? patch->old_name : patch->new_name;
implicit_predicate,apply.c,3242,+,-,"if (apply_binary_fragment(state, img, patch))
    return error(_(""binary patch does not apply to '%s'""), name);
",,
implicit_predicate,apply.c,3260,-,+,,21,	const char *name = patch->old_name ? patch->old_name : patch->new_name;
implicit_predicate,apply.c,3270,+,-,"if (apply_one_fragment(state, img, frag, inaccurate_eof, ws_rule, nth)){
    error(_(""patch failed: %s:%ld""), name, frag->oldpos);
    if (!state->apply_with_reject)
        return -1;

    frag->rejected = 1;
}
",,
implicit_predicate,apply.c,3413,+,-,"if (to_be_deleted(previous))
    return NULL;
",,
implicit_predicate,apply.c,3416,+,-,"if (was_deleted(previous))
    *gone = 1;
",,
implicit_predicate,apply.c,3446,+,-,"if (read_file_or_gitlink(ce, buf))
    return error(_(""failed to read %s""), name);
",,
implicit_predicate,apply.c,3457,+,-,"if (read_old_data(st, patch, name, buf))
    return error(_(""failed to read %s""), name);
",,
implicit_predicate,apply.c,3483,+,-,"if (status)
    return error(_(""path %s has been renamed/deleted""), patch->old_name);
",,
implicit_predicate,apply.c,3503,+,-,"if (status){
    return error(_(""failed to read %s""), patch->old_name);
}
",,
implicit_predicate,apply.c,3603,+,-,"if (verify_index_match(state, ce, &st))
    return error(_(""%s: does not match index""), name);
",,
implicit_predicate,apply.c,3609,+,-,"if (status)
    return -1;
",,
implicit_predicate,apply.c,3659,+,-,"if (load_current(state, &tmp_image, patch))
    return error(_(""cannot read the current contents of '%s'""), patch->new_name);
",,
implicit_predicate,apply.c,3663,+,-,"if (load_preimage(state, &tmp_image, patch, st, ce))
    return error(_(""cannot read the current contents of '%s'""), patch->old_name);
",,
implicit_predicate,apply.c,3680,+,-,"if (status){
    patch->conflicted_threeway = 1;
    if (patch->is_new)
        oidclr(&patch->threeway_stage[0]);
    else
        oidcpy(&patch->threeway_stage[0], &pre_oid);

    oidcpy(&patch->threeway_stage[1], &our_oid);
    oidcpy(&patch->threeway_stage[2], &post_oid);
    if (state->apply_verbosity > verbosity_silent)
        fprintf(stderr, _(""Applied patch to '%s' with conflicts.\n""), patch->new_name);
}else{
    if (state->apply_verbosity > verbosity_silent)
        fprintf(stderr, _(""Applied patch to '%s' cleanly.\n""), patch->new_name);
}
",,
implicit_predicate,apply.c,3758,+,-,"if (status)
    return error(_(""path %s has been renamed/deleted""), old_name);
",,
implicit_predicate,apply.c,3890,+,-,"do{
    while (--name->len && name->buf[name->len] != '/');

    if (!name->len)
        break;

    name->buf[name->len] = '\0';
    if (strset_contains(&state->kept_symlinks, name->buf))
        return 1;

    if (strset_contains(&state->removed_symlinks, name->buf))
        continue;

    if (state->check_index){
        struct cache_entry* ce;
        ce = index_file_exists(state->repo->index, name->buf, name->len, ignore_case);
        if (ce && S_ISLNK(ce->ce_mode))
            return 1;
    }else{
        struct stat st;
        if (!lstat(name->buf, &st) && S_ISLNK(st.st_mode))
            return 1;
    }
} while (1);
",,
implicit_predicate,apply.c,3962,-,+,,21,	const char *name = old_name ? old_name : new_name;
implicit_predicate,apply.c,3971,+,-,"if (status)
    return status;
",,
implicit_predicate,apply.c,4028,+,-,"if (same)
    return error(_(""new mode (%o) of %s does not match old mode (%o)""), patch->new_mode, new_name, patch->old_mode);
else
    return error(_(""new mode (%o) of %s does not match old mode (%o) of %s""), patch->new_mode, new_name, patch->old_mode, old_name);
",,
implicit_predicate,apply.c,4157,-,+,,10,		name = patch->old_name ? patch->old_name : patch->new_name;
implicit_predicate,apply.c,4193,+,-,"if (res)
    return error(_(""could not write temporary index to %s""), state->fake_ancestor);
",,
implicit_predicate,apply.c,4219,-,+,,10,		name = patch->new_name ? patch->new_name : patch->old_name;
implicit_predicate,apply.c,4230,+,-,"if (mode)
    printf("" %s mode %06o %s\n"", newdelete, mode, name);
else
    printf("" %s %s\n"", newdelete, name);
",,
implicit_predicate,apply.c,4239,+,-,"if (show_name)
    printf("" mode change %06o => %06o %s\n"", p->old_mode, p->new_mode, p->new_name);
else
    printf("" mode change %06o => %06o\n"", p->old_mode, p->new_mode);
",,
implicit_predicate,apply.c,4250,-,+,,27,"	const char *renamecopy = p->is_rename ? ""rename"" : ""copy"";"
implicit_predicate,apply.c,4256,+,-,"while (1){
    const char *slash_old, *slash_new;
    slash_old = strchr(old_name, '/');
    slash_new = strchr(new_name, '/');
    if (!slash_old || !slash_new || slash_old - old_name != slash_new - new_name || memcmp(old_name, new_name, slash_new - new_name))
        break;

    old_name = slash_old + 1;
    new_name = slash_new + 1;
}
",,
implicit_predicate,apply.c,4418,+,+,(mode & 0100) ? 0777 : 0666,47,"	fd = open(path, O_CREAT | O_EXCL | O_WRONLY, (mode & 0100) ? 0777 : 0666);"
implicit_predicate,apply.c,4428,+,-,"if (res)
    error_errno(_(""failed to write to '%s'""), path);
",,
implicit_predicate,apply.c,4435,+,+,res ? -1 : 0,9,	return res ? -1 : 0;
implicit_predicate,apply.c,4483,+,-,"if (path_is_beyond_symlink(state, path))
    return error(_(""affected file '%s' is beyond a symbolic link""), path);
",,
implicit_predicate,apply.c,4547,-,+,,9,	mode = patch->new_mode ? patch->new_mode : (S_IFREG | 0644);
implicit_predicate,apply.c,4578,+,-,"if (create_one_file(state, path, mode, buf, size))
    return -1;
",,
implicit_predicate,apply.c,4721,+,-,"if (write_out_one_result(state, l, phase)){
    string_list_clear(&cpath, 0);
    return -1;
}
",,
implicit_predicate,apply.c,4726,+,-,"if (write_out_one_reject(state, l))
    errs = 1;
",,
implicit_predicate,apply.c,4802,+,-,"if (use_patch(state, patch)){
    patch_stats(state, patch);
    if (!list || !state->apply_in_reverse){
        *listp = patch;
        listp = &patch->next;
    }else{
        patch->next = list;
        list = patch;
    }
    if ((patch->new_name && ends_with_path_components(patch->new_name, GITATTRIBUTES_FILE)) || (patch->old_name && ends_with_path_components(patch->old_name, GITATTRIBUTES_FILE)))
        flush_attributes = 1;
}else{
    if (state->apply_verbosity > verbosity_normal)
        say_patch_name(stderr, _(""Skipped patch '%s'.""), patch);

    free_patch(patch);
    skipped_patch++;
}
",,
implicit_predicate,apply.c,4877,-,+,,10,			res = state->apply_with_reject ? -1 : 1;
implicit_predicate,apply.c,4897,+,-,"if (flush_attributes)
    reset_parsed_attributes();
",,
implicit_predicate,apply.c,4949,+,-,"if (unset)
    state->ws_ignore_action = ignore_ws_none;
else
    state->ws_ignore_action = ignore_ws_change;
",,
implicit_predicate,apply.c,4964,+,-,"if (parse_whitespace_option(state, arg))
    return -1;
",,
implicit_predicate,apply.c,5024,+,-,"if (read_stdin){
    res = apply_patch(state, 0, ""<stdin>"", options);
    if (res < 0)
        goto end;

    errs |= res;
}
",,
implicit_predicate,apply.c,5065,+,-,"if (res){
    error(_(""Unable to write new index file""));
    res = -128;
    goto end;
}
",,
implicit_predicate,archive-tar.c,70,+,-,"if (offset){
    unsigned long chunk = BLOCKSIZE - offset;
    if (size < chunk)
        chunk = size;

    memcpy(block + offset, buf, chunk);
    size -= chunk;
    offset += chunk;
    buf += chunk;
    write_if_needed();
}
",,
implicit_predicate,archive-tar.c,85,+,-,"if (size){
    memcpy(block + offset, buf, size);
    offset += size;
}
",,
implicit_predicate,archive-tar.c,95,+,-,"if (tail){
    memset(block + offset, 0, RECORDSIZE - tail);
    offset += RECORDSIZE - tail;
}
",,
implicit_predicate,archive-tar.c,275,+,+,(mode & 0100) ? 0777 : 0666,19,		mode = (mode | ((mode & 0100) ? 0777 : 0666)) & ~tar_umask;
implicit_predicate,archive-zip.c,340,+,+,(mode & 0111) ? ((mode) << 16) : 0,4,			(mode & 0111) ? ((mode) << 16) : 0;
implicit_predicate,archive-zip.c,392,+,-,"if (need_zip64_extra)
    version_needed = 45;
",,
implicit_predicate,archive-zip.c,401,+,-,<!!!>,,
implicit_predicate,archive-zip.c,415,+,-,<!!!>,,
implicit_predicate,archive-zip.c,593,-,+,,36,"	copy_le16(trailer.comment_length, oid ? the_hash_algo->hexsz : 0);"
implicit_predicate,archive-zip.c,596,+,-,"if (clamped)
    write_zip64_trailer();
",,
implicit_predicate,archive.c,89,-,+,,32,	const struct commit *commit = args->convert ? args->commit : NULL;
implicit_predicate,archive.c,93,-,+,,11,"			       args->commit_oid ? args->commit_oid :
			       (args->tree ? &args->tree->object.oid : NULL), oid);"
implicit_predicate,archive.c,94,-,+,,12,"			       (args->tree ? &args->tree->object.oid : NULL), oid);"
implicit_predicate,archive.c,174,+,-,"if (check_attr_export_ignore(check))
    return 0;
",,
implicit_predicate,archive.c,207,+,-,"if (err)
    return err;
",,
implicit_predicate,archive.c,256,+,+,ret ? -1 : 0,9,	return ret ? -1 : 0;
implicit_predicate,archive.c,283,+,-,"if (check_attr_export_ignore(check))
    return 0;
",,
implicit_predicate,archive.c,289,+,-,"if (write_directory(c))
    return -1;
",,
implicit_predicate,archive.c,324,+,-,"if (err)
    return err;
",,
implicit_predicate,archive.c,389,+,-,"if (err)
    break;
",,
implicit_predicate,archive.c,565,+,-,"if (unset){
    string_list_clear_func(&args->extra_files, extra_file_info_clear);
    return 0;
}
",,
implicit_predicate,archive.c,599,-,+,,10,"		path = buf.len ?
			strbuf_detach(&buf, NULL) : xstrndup(arg, p - arg);"
implicit_predicate,archive.c,688,+,-,"if (list){
    if (argc)
        die(_(""extra command line parameter '%s'""), *argv);

    for (i = 0;i < nr_archivers;i++)
        if (!is_remote || archivers[i]->flags & ARCHIVER_REMOTE)
            printf(""%s\n"", archivers[i]->name);
    exit(0);
}
",,
implicit_predicate,archive.c,689,+,-,"if (argc)
    die(_(""extra command line parameter '%s'""), *argv);
",,
implicit_predicate,attr.c,108,-,+,,9,	return e ? e->value : NULL;
implicit_predicate,attr.c,411,+,-,is_macro ? 0 : namelen + 1,,
implicit_predicate,attr.c,412,+,-,"if (is_macro){
    res->u.attr = git_attr_internal(name, namelen);
}else{
    char* p = (char*)&(res->state[num_attr]);
    memcpy(p, name, namelen);
    res->u.pat.pattern = p;
    parse_path_pattern(&res->u.pat.pattern, &res->u.pat.patternlen, &res->u.pat.flags, &res->u.pat.nowildcardlen);
    if (res->u.pat.flags & PATTERN_FLAG_NEGATIVE){
        warning(_(""Negative patterns are ignored in git attributes\nUse '\\!' for literal leading exclamation.""));
        goto fail_return;
    }
}
",,
implicit_predicate,attr.c,735,+,-,"if (flags & READ_ATTR_NOFOLLOW)
    fd = open_nofollow(path, O_RDONLY);
else
    fd = open(path, O_RDONLY);
",,
implicit_predicate,attr.c,784,+,-,"for (sp = buf;*sp;){
    char* ep;
    int more;
    ep = strchrnul(sp, '\n');
    more = (*ep == '\n');
    *ep = '\0';
    handle_attr_line(res, sp, path, ++lineno, flags);
    sp = ep + more;
}
",,
implicit_predicate,attr.c,956,+,-,"if (git_attr_system_is_enabled()){
    e = read_attr_from_file(git_attr_system_file(), flags);
    push_stack(stack, e, NULL, 0);
}
",,
implicit_predicate,attr.c,1126,-,+,,22,"		const char *base = stack->origin ? stack->origin : """";"
implicit_predicate,base85.c,33,+,-,"if (de85['Z'])
    return;
",,
implicit_predicate,base85.c,45,+,-,"say2(""decode 85 <%.*s>"", len / 4 * 5, buffer);
",,
implicit_predicate,base85.c,46,+,-,"while (len){
    unsigned acc = 0;
    int de, cnt = 4;
    unsigned char ch;
    do{
        ch = *buffer++;
        de = de85[ch];
        if (--de < 0)
            return error(""invalid base85 alphabet %c"", ch);

        acc = acc * 85 + de;
    } while (--cnt);
    ch = *buffer++;
    de = de85[ch];
    if (--de < 0)
        return error(""invalid base85 alphabet %c"", ch);

    if (0xffffffff / 85 < acc || 0xffffffff - de < (acc *= 85))
        return error(""invalid base85 sequence %.5s"", buffer - 5);

    acc += de;
    say1("" %08x"", acc);
    cnt = (len < 4) ? len : 4;
    len -= cnt;
    do{
        acc = (acc << 8) | (acc >> 24);
        *dst++ = acc;
    } while (--cnt);
}
",,
implicit_predicate,base85.c,50,+,-,"do{
    ch = *buffer++;
    de = de85[ch];
    if (--de < 0)
        return error(""invalid base85 alphabet %c"", ch);

    acc = acc * 85 + de;
} while (--cnt);
",,
implicit_predicate,base85.c,66,+,-,"say1("" %08x"", acc);
",,
implicit_predicate,base85.c,70,+,-,"do{
    acc = (acc << 8) | (acc >> 24);
    *dst++ = acc;
} while (--cnt);
",,
implicit_predicate,base85.c,75,+,-,"say(""\n"");
",,
implicit_predicate,base85.c,82,+,-,"say(""encode 85"");
",,
implicit_predicate,base85.c,83,+,-,"while (bytes){
    unsigned acc = 0;
    int cnt;
    for (cnt = 24;cnt >= 0;cnt -= 8){
        unsigned ch = *data++;
        acc |= ch << cnt;
        if (--bytes == 0)
            break;
    }
    say1("" %08x"", acc);
    for (cnt = 4;cnt >= 0;cnt--){
        int val = acc % 85;
        acc /= 85;
        buf[cnt] = en85[val];
    }
    buf += 5;
}
",,
implicit_predicate,base85.c,92,+,-,"say1("" %08x"", acc);
",,
implicit_predicate,base85.c,100,+,-,"say(""\n"");
",,
implicit_predicate,basename.c,15,+,-,"for (base = path;*path;path++){
    if (!is_dir_sep(*path))
        continue;

    do{
        path++;
    } while (is_dir_sep(*path));
    if (*path)
        base = path;
    else
        while (--path != base && is_dir_sep(*path))
            *path = '\0';
}
",,
implicit_predicate,basename.c,21,+,-,"if (*path)
    base = path;
else
    while (--path != base && is_dir_sep(*path))
        *path = '\0';
",,
implicit_predicate,basename.c,51,+,-,"while ((c = *(p++)))
    if (is_dir_sep(c)){
        char* tentative = p - 1;
        while (is_dir_sep(*p))
            p++;
        if (*p)
            slash = tentative;
    }
",,
implicit_predicate,basename.c,58,+,-,"if (*p)
    slash = tentative;
",,
implicit_predicate,basics.c,55,+,+,"f(0, args) ? 0 : 1",9,"	return f(0, args) ? 0 : 1;"
implicit_predicate,bisect.c,116,+,-,"if (DEBUG_BISECT)
    return 0;
",,
implicit_predicate,bisect.c,165,-,+,,4,"			(commit_flags & TREESAME) ? ' ' : 'T',"
implicit_predicate,bisect.c,166,-,+,,4,"			(commit_flags & UNINTERESTING) ? 'U' : ' ',"
implicit_predicate,bisect.c,167,+,+,(commit_flags & COUNTED) ? 'C' : ' ',4,			(commit_flags & COUNTED) ? 'C' : ' ');
implicit_predicate,bisect.c,178,+,-,"if (subject_len)
    fprintf(stderr, "" %.*s"", subject_len, subject_start);
",,
implicit_predicate,bisect.c,194,+,-,"if (res)
    return error(_(""'%s' is not a valid term""), term);
",,
implicit_predicate,bisect.c,197,+,-,"if (one_of(term, ""help"", ""start"", ""skip"", ""next"", ""reset"", ""visualize"", ""view"", ""replay"", ""log"", ""run"", ""terms"", NULL))
    return error(_(""can't use the builtin command '%s' as a term""), term);
",,
implicit_predicate,bisect.c,293,+,-,"if (one_of(state, terms->term_good, ""skip"", NULL)){
    strbuf_addf(&tag, ""refs/bisect/%s-%s"", state, rev);
}else{
    res = error(_(""Bad bisect_write argument: %s""), state);
    goto finish;
}
",,
implicit_predicate,bisect.c,334,+,-,"if (one_of(cmd, ""skip"", ""start"", ""terms"", NULL))
    return 0;
",,
implicit_predicate,bisect.c,344,+,-,"if (one_of(cmd, ""bad"", ""good"", NULL)){
    set_terms(terms, ""bad"", ""good"");
    return write_terms(terms->term_bad, terms->term_good);
}
",,
implicit_predicate,bisect.c,348,+,-,"if (one_of(cmd, ""new"", ""old"", NULL)){
    set_terms(terms, ""new"", ""old"");
    return write_terms(terms->term_bad, terms->term_good);
}
",,
implicit_predicate,bisect.c,359,-,+,,13,			     q = bisect_flags & FIND_BISECTION_FIRST_PARENT_ONLY ? NULL : q->next) {
implicit_predicate,bisect.c,501,+,-,"if (get_terms(terms))
    return error(_(""no terms defined""));
",,
implicit_predicate,bisect.c,510,+,-,"if (one_of(option, ""--term-good"", ""--term-old"", NULL))
    printf(""%s\n"", terms->term_good);
else
    if (one_of(option, ""--term-bad"", ""--term-new"", NULL))
        printf(""%s\n"", terms->term_bad);
    else
        return error(_(""invalid argument %s for 'git bisect terms'.\nSupported options are: --term-good|--term-old and --term-bad|--term-new.""), option);
",,
implicit_predicate,bisect.c,512,+,-,"if (one_of(option, ""--term-bad"", ""--term-new"", NULL))
    printf(""%s\n"", terms->term_bad);
else
    return error(_(""invalid argument %s for 'git bisect terms'.\nSupported options are: --term-good|--term-old and --term-bad|--term-new.""), option);
",,
implicit_predicate,bisect.c,601,+,-,"if (res)
    return res;
",,
implicit_predicate,bisect.c,660,+,-,"if (bisect_autostart(terms))
    return BISECT_FAILED;
",,
implicit_predicate,bisect.c,663,+,-,"if (bisect_next_check(terms, terms->term_good))
    return BISECT_FAILED;
",,
implicit_predicate,bisect.c,671,-,+,,10,		return res ? res : BISECT_INTERNAL_SUCCESS_1ST_BAD_FOUND;
implicit_predicate,bisect.c,674,-,+,,10,		return res ? res : BISECT_ONLY_SKIPPED_LEFT;
implicit_predicate,bisect.c,677,+,-,"if (read_paths)
    read_bisect_paths(rev_argv);
",,
implicit_predicate,bisect.c,729,+,-,"if (no_checkout){
    refs_update_ref(get_main_ref_store(the_repository), NULL, ""BISECT_HEAD"", bisect_rev, NULL, 0, UPDATE_REFS_DIE_ON_ERR);
}else{
    struct child_process cmd = CHILD_PROCESS_INIT;
    cmd.git_cmd = 1;
    strvec_pushl(&cmd.args, ""checkout"", ""-q"", oid_to_hex(bisect_rev), ""--"", NULL);
    if (run_command(&cmd))
        return BISECT_FAILED;
}
",,
implicit_predicate,bisect.c,756,+,-,"if (has_double_dash){
    die(_(""'%s' does not appear to be a valid revision""), arg);
}else{
    break;
}
",,
implicit_predicate,bisect.c,774,+,-,"if (bad_seen){
    string_list_append(&states, terms->term_good);
}else{
    bad_seen = 1;
    string_list_append(&states, terms->term_bad);
}
",,
implicit_predicate,bisect.c,783,+,-,"if (is_expected_rev(current_bad_oid)){
    char* bad_hex = oid_to_hex(current_bad_oid);
    char* good_hex = join_oid_array_hex(&good_revs, ' ');
    if (!strcmp(term_bad, ""bad"") && !strcmp(term_good, ""good"")){
        fprintf(stderr, _(""The merge base %s is bad.\nThis means the bug has been fixed between %s and [%s].\n""), bad_hex, bad_hex, good_hex);
    }else
        if (!strcmp(term_bad, ""new"") && !strcmp(term_good, ""old"")){
            fprintf(stderr, _(""The merge base %s is new.\nThe property has changed between %s and [%s].\n""), bad_hex, bad_hex, good_hex);
        }else{
            fprintf(stderr, _(""The merge base %s is %s.\nThis means the first '%s' commit is between %s and [%s].\n""), bad_hex, term_bad, term_good, bad_hex, good_hex);
        }

    return BISECT_MERGE_BASE_CHECK;
}
",,
implicit_predicate,bisect.c,837,+,-,"if (first_parent_only)
    write_file(git_path_bisect_first_parent(), ""\n"");
",,
implicit_predicate,bisect.c,840,+,-,"if (no_checkout){
    if (repo_get_oid(the_repository, start_head.buf, &oid) < 0){
        res = error(_(""invalid ref: '%s'""), start_head.buf);
        goto finish;
    }
    if (refs_update_ref(get_main_ref_store(the_repository), NULL, ""BISECT_HEAD"", &oid, NULL, 0, UPDATE_REFS_MSG_ON_ERR)){
        res = BISECT_FAILED;
        goto finish;
    }
}
",,
implicit_predicate,bisect.c,927,+,-,"if (check_ancestors(r, rev_nr, rev, prefix))
    res = check_merge_bases(rev_nr, rev, no_checkout);
",,
implicit_predicate,bisect.c,930,+,-,"if (bisect_autostart(terms))
    return BISECT_FAILED;
",,
implicit_predicate,bisect.c,963,+,-,"for (;argc;argc--, argv++){
    struct commit* commit;
    if (repo_get_oid(the_repository, *argv, &oid)){
        error(_(""Bad rev input: %s""), *argv);
        oid_array_clear(&revs);
        return BISECT_FAILED;
    }
    commit = lookup_commit_reference(the_repository, &oid);
    if (!commit)
        die(_(""Bad rev input (not a commit): %s""), *argv);

    oid_array_append(&revs, &commit->object.oid);
}
",,
implicit_predicate,bisect.c,1014,+,+,status ? BISECT_FAILED : BISECT_OK,9,	return status ? BISECT_FAILED : BISECT_OK;
implicit_predicate,bisect.c,1032,+,-,"if (check_and_set_terms(terms, p))
    return -1;
",,
implicit_predicate,bisect.c,1039,+,-,"if (read_bisect_refs())
    die(_(""reading bisect refs failed""));
",,
implicit_predicate,bisect.c,1044,+,-,"if (one_of(p, terms->term_good, terms->term_bad, ""skip"", NULL))
    return bisect_write(p, rev, terms, 0);
",,
implicit_predicate,bisect.c,1196,+,+,"no_checkout ? ""BISECT_HEAD"" : ""HEAD""",56,"	if (refs_read_ref(get_main_ref_store(the_repository), no_checkout ? ""BISECT_HEAD"" : ""HEAD"", &current_rev))"
implicit_predicate,bisect.c,1230,+,-,"while (1){
    res = do_bisect_run(command.buf);
    if (is_first_run && (res == 126 || res == 127)){
        int rc = verify_good(terms, command.buf);
        is_first_run = 0;
        if (rc < 0 || 128 <= rc){
            error(_(""unable to verify %s on good revision""), command.buf);
            res = BISECT_FAILED;
            break;
        }
        if (rc == res){
            error(_(""bogus exit code %d for good revision""), rc);
            res = BISECT_FAILED;
            break;
        }
    }
    if (res < 0 || 128 <= res){
        error(_(""bisect run failed: exit code %d from %s is < 0 or >= 128""), res, command.buf);
        break;
    }
    if (res == 125)
        new_state = ""skip"";
    else
        if (!res)
            new_state = terms->term_good;
        else
            new_state = terms->term_bad;

    temporary_stdout_fd = open(git_path_bisect_run(), O_CREAT | O_WRONLY | O_TRUNC, 0666);
    if (temporary_stdout_fd < 0){
        res = error_errno(_(""cannot open file '%s' for writing""), git_path_bisect_run());
        break;
    }
    fflush (stdout);
    saved_stdout = dup(1);
    dup2(temporary_stdout_fd, 1);
    res = bisect_state(terms, 1, &new_state);
    fflush(stdout);
    dup2(saved_stdout, 1);
    close(saved_stdout);
    close(temporary_stdout_fd);
    print_file_to_stdout (git_path_bisect_run());
    if (res == BISECT_ONLY_SKIPPED_LEFT)
        error(_(""bisect run cannot continue any more""));
    else
        if (res == BISECT_INTERNAL_SUCCESS_MERGE_BASE){
            puts(_(""bisect run success""));
            res = BISECT_OK;
        }else
            if (res == BISECT_INTERNAL_SUCCESS_1ST_BAD_FOUND){
                puts(_(""bisect found first bad commit""));
                res = BISECT_OK;
            }else
                if (res){
                    error(_(""bisect run failed: 'git bisect %s' exited with error code %d""), new_state, res);
                }else{
                    continue;
                }

    break;
}
",,
implicit_predicate,bisect.c,1298,+,-,"if (res){
    error(_(""bisect run failed: 'git bisect %s' exited with error code %d""), new_state, res);
}else{
    continue;
}
",,
implicit_predicate,bisect.c,1316,-,+,,22,	return bisect_reset(argc ? argv[0] : NULL);
implicit_predicate,bisect.c,1439,+,-,"if (check_and_set_terms(&terms, argv[0]))
    usage_msg_optf(_(""unknown command: '%s'""), git_bisect_usage, options, argv[0]);
",,
implicit_predicate,bisect.c,1450,-,+,,9,
implicit_predicate,blame.c,33,-,+,,9,	return result ? *result : NULL;
implicit_predicate,blame.c,223,+,-,"if (len)
    strbuf_add(&ret->summary, subject, len);
else
    strbuf_addf(&ret->summary, ""(%s)"", oid_to_hex(&commit->object.oid));
",,
implicit_predicate,blame.c,291,+,-,"if (incremental){
    struct blame_origin* suspect = ent->suspect;
    printf(""%s %d %d %d\n"", oid_to_hex(&suspect->commit->object.oid), ent->s_lno + 1, ent->lno + 1, ent->num_lines);
    emit_one_suspect_detail(suspect, 0);
    write_filename_info(suspect);
    maybe_flush_or_die(stdout, ""stdout"");
}
",,
implicit_predicate,blame.c,311,+,-,<!!!>,,
implicit_predicate,blame.c,330,-,+,,9,	return nl ? nl + 1 : end;
implicit_predicate,blame.c,373,+,-,"if (cnt){
    printf(""%s %d %d\n"", hex, ent->s_lno + 1 + cnt, ent->lno + 1 + cnt);
    if (repeat)
        emit_porcelain_details(suspect, 1);
}
",,
implicit_predicate,blame.c,377,+,-,"if (repeat)
    emit_porcelain_details(suspect, 1);
",,
implicit_predicate,blame.c,463,+,-,"if (opt & OUTPUT_SHOW_AGE_WITH_COLOR){
    determine_line_heat(&ci, &default_color);
    color = default_color;
    reset = GIT_COLOR_RESET;
}
",,
implicit_predicate,blame.c,471,+,+,(opt & OUTPUT_LONG_OBJECT_NAME) ? the_hash_algo->hexsz : abbrev,16,		int length = (opt & OUTPUT_LONG_OBJECT_NAME) ? the_hash_algo->hexsz : abbrev;
implicit_predicate,blame.c,473,+,-,"if (opt & OUTPUT_COLOR_LINE){
    if (cnt > 0){
        color = repeated_meta_color;
        reset = GIT_COLOR_RESET;
    }else{
        color = default_color ? default_color : NULL;
        reset = default_color ? GIT_COLOR_RESET : NULL;
    }
}
",,
implicit_predicate,blame.c,478,-,+,,13,				color = default_color ? default_color : NULL;
implicit_predicate,blame.c,479,-,+,,13,				reset = default_color ? GIT_COLOR_RESET : NULL;
implicit_predicate,blame.c,486,+,-,"if (blank_boundary)
    memset(hex, ' ', length);
else
    if (!(opt & OUTPUT_ANNOTATE_COMPAT)){
        length--;
        putchar('^');
    }
",,
implicit_predicate,blame.c,503,+,-,"if (opt & OUTPUT_ANNOTATE_COMPAT){
    const char* name;
    if (opt & OUTPUT_SHOW_EMAIL)
        name = ci.author_mail.buf;
    else
        name = ci.author.buf;

    printf(""\t(%10s\t%10s\t%d)"", name, format_time(ci.author_time, ci.author_tz.buf, show_raw_time), ent->lno + 1 + cnt);
}else{
    if (opt & OUTPUT_SHOW_SCORE)
        printf("" %*d %02d"", max_score_digits, ent->score, ent->suspect->refcnt);

    if (opt & OUTPUT_SHOW_NAME)
        printf("" %-*.*s"", longest_file, longest_file, suspect->path);

    if (opt & OUTPUT_SHOW_NUMBER)
        printf("" %*d"", max_orig_digits, ent->s_lno + 1 + cnt);

    if (!(opt & OUTPUT_NO_AUTHOR)){
        const char* name;
        int pad;
        if (opt & OUTPUT_SHOW_EMAIL)
            name = ci.author_mail.buf;
        else
            name = ci.author.buf;

        pad = longest_author - utf8_strwidth(name);
        printf("" (%s%*s %10s"", name, pad, """", format_time(ci.author_time, ci.author_tz.buf, show_raw_time));
    }
    printf("" %*d) "", max_digits, ent->lno + 1 + cnt);
}
",,
implicit_predicate,blame.c,505,+,-,"if (opt & OUTPUT_SHOW_EMAIL)
    name = ci.author_mail.buf;
else
    name = ci.author.buf;
",,
implicit_predicate,blame.c,514,+,-,"if (opt & OUTPUT_SHOW_SCORE)
    printf("" %*d %02d"", max_score_digits, ent->score, ent->suspect->refcnt);
",,
implicit_predicate,blame.c,518,+,-,"if (opt & OUTPUT_SHOW_NAME)
    printf("" %-*.*s"", longest_file, longest_file, suspect->path);
",,
implicit_predicate,blame.c,521,+,-,"if (opt & OUTPUT_SHOW_NUMBER)
    printf("" %*d"", max_orig_digits, ent->s_lno + 1 + cnt);
",,
implicit_predicate,blame.c,528,+,-,"if (opt & OUTPUT_SHOW_EMAIL)
    name = ci.author_mail.buf;
else
    name = ci.author.buf;
",,
implicit_predicate,blame.c,561,+,-,"if (option & OUTPUT_PORCELAIN){
    for (ent = sb->ent;ent;ent = ent->next){
        int count = 0;
        struct blame_origin* suspect;
        struct commit* commit = ent->suspect->commit;
        if (commit->object.flags & MORE_THAN_ONE_PATH)
            continue;

        for (suspect = get_blame_suspects(commit);suspect;suspect = suspect->next){
            if (suspect->guilty && count++){
                commit->object.flags |= MORE_THAN_ONE_PATH;
                break;
            }
        }
    }
}
",,
implicit_predicate,blame.c,578,+,-,"if (option & OUTPUT_PORCELAIN)
    emit_porcelain(sb, ent, option);
else{
    emit_other(sb, ent, option);
}
",,
implicit_predicate,blame.c,636,+,-,"if (compute_auto_abbrev)
    auto_abbrev = update_auto_abbrev(auto_abbrev, suspect);
",,
implicit_predicate,blame.c,647,+,-,"if (*option & OUTPUT_SHOW_EMAIL)
    num = utf8_strwidth(ci.author_mail.buf);
else
    num = utf8_strwidth(ci.author.buf);
",,
implicit_predicate,blame.c,668,+,-,"if (compute_auto_abbrev)
    abbrev = auto_abbrev + 1;
",,
implicit_predicate,blame.c,685,+,-,"if (*end)
    return 0;
",,
implicit_predicate,blame.c,692,-,+,,29,"	return prefix_path(prefix, prefix ? strlen(prefix) : 0, path);"
implicit_predicate,blame.c,725,+,-,"if (ret)
    return ret;
",,
implicit_predicate,blame.c,826,+,-,"while (1){
    struct object* obj;
    int kind = oid_object_info(r, &oid, NULL);
    if (kind == OBJ_COMMIT){
        oidcpy(oid_ret, &oid);
        return 0;
    }
    if (kind != OBJ_TAG)
        return -1;

    obj = deref_tag(r, parse_object(r, &oid), NULL, 0);
    if (!obj)
        return -1;

    oidcpy(&oid, &obj->oid);
}
",,
implicit_predicate,blame.c,920,+,+,cmd_is_annotate ? annotate_usage : blame_usage,26,	const char *str_usage = cmd_is_annotate ? annotate_usage : blame_usage;
implicit_predicate,blame.c,921,+,+,cmd_is_annotate ? annotate_opt_usage : blame_opt_usage,27,	const char **opt_usage = cmd_is_annotate ? annotate_opt_usage : blame_opt_usage;
implicit_predicate,blame.c,959,+,+,length_a ? length_a - 1 : 0,27,		max_search_distance_a = length_a ? length_a - 1 : 0;
implicit_predicate,blame.c,985,+,-,"if (cmd_is_annotate){
    output_option |= OUTPUT_ANNOTATE_COMPAT;
    blame_date_mode.type = DATE_ISO8601;
}else{
    blame_date_mode = revs.date_mode;
}
",,
implicit_predicate,blame.c,1054,+,-,"if (fill_fingerprints)
    fill_origin_fingerprints(o);
",,
implicit_predicate,blame.c,1059,+,-,"if (dashdash_pos){
    switch (argc - dashdash_pos - 1){
        case 2:
            if (argc != 4)
                usage_with_options(opt_usage, options);

            argv[1] = argv[3];
            argv[3] = argv[2];
            argv[2] = ""--"";
        case 1:
            path = add_prefix(prefix, argv[--argc]);
            argv[argc] = NULL;
            break;
        default:
            usage_with_options(opt_usage, options);
    }
}else{
    if (argc < 2)
        usage_with_options(opt_usage, options);

    if (argc == 3 && is_a_rev(argv[argc - 1])){
        path = add_prefix(prefix, argv[1]);
        argv[1] = argv[2];
    }else{
        if (argc == 2 && is_a_rev(argv[1]) && !get_git_work_tree())
            die(""missing <path> to blame"");

        path = add_prefix(prefix, argv[argc - 1]);
    }
    argv[argc - 1] = ""--"";
}
",,
implicit_predicate,blame.c,1169,+,-,"if (blame_move_score)
    sb.move_score = blame_move_score;
",,
implicit_predicate,blame.c,1171,+,-,"if (blame_copy_score)
    sb.copy_score = blame_copy_score;
",,
implicit_predicate,blame.c,1173,+,-,"if (baa)
    sb->on_sanity_fail(sb, baa);
",,
implicit_predicate,blame.c,1185,+,-,"if (show_progress)
    pi.progress = start_delayed_progress(_(""Blaming lines""), num_lines);
",,
implicit_predicate,blame.c,1212,+,-,"if (output_option & OUTPUT_ANNOTATE_COMPAT)
    output_option &= ~(OUTPUT_COLOR_LINE | OUTPUT_SHOW_AGE_WITH_COLOR);
",,
implicit_predicate,blame.c,1223,+,-,"if (show_stats){
    printf(""num read blob: %d\n"", sb.num_read_blob);
    printf(""num get patch: %d\n"", sb.num_get_patch);
    printf(""num commits: %d\n"", sb.num_commits);
}
",,
implicit_predicate,blame.c,1362,+,-,"if (compute_diff)
    diff_tree_oid(get_commit_tree_oid(parent), get_commit_tree_oid(origin->commit), """", &diff_opts);
",,
implicit_predicate,blame.c,1386,-,+,,11,			name = p->one->path ? p->one->path : p->two->path;
implicit_predicate,blame.c,1755,+,-,"if (are_lines_adjacent(&line_blames[i], &line_blames[i + 1])){
    entry_len++;
    continue;
}
",,
implicit_predicate,blame.c,1763,+,-,"if (line_blames[i].is_parent){
    e->ignored = 1;
    blame_origin_decref(e->suspect);
    e->suspect = blame_origin_incref(parent);
    e->s_lno = line_blames[i - entry_len + 1].s_lno;
    e->next = *ignoredp;
    *ignoredp = e;
}else{
    e->unblamable = 1;
    e->next = *diffp;
    *diffp = e;
}
",,
implicit_predicate,blame.c,1880,+,-,"if (ignore_diffs){
    ignore_blame_entry(e, parent, &diffp, &ignoredp, line_blames + e->s_lno - tlno);
}else{
    e->next = diffp;
    diffp = e;
}
",,
implicit_predicate,blame.c,1968,+,-,"if (ignore_diffs)
    sort_blame_entries(&newdest, compare_blame_suspect);
",,
implicit_predicate,blame.c,2215,+,-,"if (num_ents){
    CALLOC_ARRAY(blame_list, num_ents);
    for (e = unblamed, i = 0;e;e = e->next)
        blame_list[i++].ent = e;
}
",,
implicit_predicate,blame.c,2433,+,+,pass ? find_rename : find_origin,25,		blame_find_alg find = pass ? find_rename : find_origin;
implicit_predicate,block.c,48,+,-,"if (is_restart){
    rlen++;
}
",,
implicit_predicate,block.c,53,+,-,"if (is_restart){
    REFTABLE_ALLOC_GROW(w->restarts, w->restart_len + 1, w->restart_cap);
    w->restarts[w->restart_len++] = w->next;
}
",,
implicit_predicate,block.c,380,+,-,"if (n)
    return n < 0;
",,
implicit_predicate,block.c,454,+,-,"if (args.error){
    err = REFTABLE_FORMAT_ERROR;
    goto done;
}
",,
implicit_predicate,block.c,494,+,-,"while (1){
    size_t prev_off = it->next_off;
    err = block_iter_next(it, &rec);
    if (err < 0)
        goto done;

    if (err > 0){
        it->next_off = prev_off;
        err = 0;
        goto done;
    }
    reftable_record_key(&rec, &it->last_key);
    if (strbuf_cmp(&it->last_key, want) >= 0){
        it->next_off = prev_off;
        goto done;
    }
}
",,
implicit_predicate,block_test.c,74,+,-,"while (1){
    int r = block_iter_next(&it, &rec);
    EXPECT(r >= 0);
    if (r > 0){
        break;
    }
    EXPECT_STREQ(names[j], rec.u.ref.refname);
    j++;
}
",,
implicit_predicate,branch.c,117,-,+,,37,"	if (git_config_set_gently(key.buf, origin ? origin : ""."") < 0)"
implicit_predicate,branch.c,134,+,-,"if (rebasing){
    strbuf_reset(&key);
    strbuf_addf(&key, ""branch.%s.rebase"", local);
    if (git_config_set_gently(key.buf, ""true"") < 0)
        goto out_err;
}
",,
implicit_predicate,branch.c,159,-,+,,11,"	merged = reference_rev ? repo_in_merge_bases(the_repository, rev,
						     reference_rev) : 0;"
implicit_predicate,branch.c,166,+,+,"rebasing ? _(""branch '%s' set up to track '%s' by rebasing."") : _(""branch '%s' set up to track '%s'."")",14,"			printf_ln(rebasing ?
				_(""branch '%s' set up to track '%s' by rebasing."") :
				_(""branch '%s' set up to track '%s'.""),"
implicit_predicate,branch.c,172,-,+,,16,"		int expect = head_rev ? repo_in_merge_bases(the_repository, rev, head_rev) : 0;"
implicit_predicate,branch.c,177,+,-,"if (merged)
    warning(_(""deleting branch '%s' that has been merged to\n         '%s', but not yet merged to HEAD""), name, reference_name);
else
    warning(_(""not deleting branch '%s' that is not yet merged to\n         '%s', even though it is merged to HEAD""), name, reference_name);
",,
implicit_predicate,branch.c,189,-,+,,4,"			origin ? origin : """","
implicit_predicate,branch.c,190,-,+,,4,"			origin ? ""/"" : """","
implicit_predicate,branch.c,194,-,+,,11,"			local, origin ? origin : ""."");"
implicit_predicate,branch.c,255,+,+,quiet ? 0 : BRANCH_CONFIG_VERBOSE,21,	int config_flags = quiet ? 0 : BRANCH_CONFIG_VERBOSE;
implicit_predicate,branch.c,269,+,-,"if (inherit_tracking(&tracking, orig_ref))
    goto cleanup;
",,
implicit_predicate,branch.c,282,+,-,"if (remote_branch){
    error(_(""remote-tracking branch '%s' not found""), bname.buf);
}else{
    char* virtual_name = mkpathdup(fmt_remotes, bname.buf);
    char* virtual_target = refs_resolve_refdup(get_main_ref_store(the_repository), virtual_name, RESOLVE_REF_READING | RESOLVE_REF_NO_RECURSE | RESOLVE_REF_ALLOW_BAD_NAME, &oid, &flags);
    FREE_AND_NULL(virtual_name);
    if (virtual_target)
        error(_(""branch '%s' not found.\nDid you forget --remote?""), bname.buf);
    else
        error(_(""branch '%s' not found""), bname.buf);

    FREE_AND_NULL(virtual_target);
}
",,
implicit_predicate,branch.c,315,-,+,,24,"		item->util = xstrdup((flags & REF_ISBROKEN) ? ""broken""
				    : (flags & REF_ISSYMREF) ? target
				    : repo_find_unique_abbrev(the_repository, &oid, DEFAULT_ABBREV));"
implicit_predicate,branch.c,316,-,+,,11,"				    : (flags & REF_ISSYMREF) ? target
				    : repo_find_unique_abbrev(the_repository, &oid, DEFAULT_ABBREV));"
implicit_predicate,branch.c,332,+,+,"remote_branch ? _(""Deleted remote-tracking branch %s (was %s).\n"") : _(""Deleted branch %s (was %s).\n"")",12,"				printf(remote_branch
					? _(""Deleted remote-tracking branch %s (was %s).\n"")
					: _(""Deleted branch %s (was %s).\n""),"
implicit_predicate,branch.c,391,+,-,"if (initialized_checked_out_branches)
    return;
",,
implicit_predicate,branch.c,548,+,-,"if (explicit_tracking){
    int code = die_message(_(upstream_missing), start_name);
    advise_if_enabled(ADVICE_SET_UPSTREAM_FAILURE, _(upstream_advice));
    exit(code);
}
",,
implicit_predicate,branch.c,561,+,-,"if (explicit_tracking)
    die(_(upstream_not_branch), start_name);
",,
implicit_predicate,branch.c,568,+,-,"if (explicit_tracking)
    die(_(upstream_not_branch), start_name);
else
    FREE_AND_NULL(real_ref);
",,
implicit_predicate,branch.c,609,+,+,"if (clobber_head_ok ? validate_branchname(name, &ref) : validate_new_branchname(name, &ref, force)){
    forcing = 1;
}
",6,"	if (clobber_head_ok ?
			  validate_branchname(name, &ref) :
			  validate_new_branchname(name, &ref, force)) {"
implicit_predicate,branch.c,616,+,-,"if (dry_run)
    goto cleanup;
",,
implicit_predicate,branch.c,619,+,-,"if (reflog)
    log_all_ref_updates = LOG_REFS_NORMAL;
",,
implicit_predicate,branch.c,622,+,-,"if (forcing)
    msg = xstrfmt(""branch: Reset to %s"", start_name);
else
    msg = xstrfmt(""branch: Created from %s"", start_name);
",,
implicit_predicate,branch.c,630,+,+,forcing ? NULL : null_oid(),12,"					&oid, forcing ? NULL : null_oid(),"
implicit_predicate,branch.c,631,+,-,"if (copy)
    strbuf_addf(&logmsg, ""Branch: copied %s to %s"", oldref.buf, newref.buf);
else
    strbuf_addf(&logmsg, ""Branch: renamed %s to %s"", oldref.buf, newref.buf);
",,
implicit_predicate,branch.c,644,+,-,"if (recovery){
    if (copy)
        warning(_(""created a copy of a misnamed branch '%s'""), interpreted_oldname);
    else
        warning(_(""renamed a misnamed branch '%s' away""), interpreted_oldname);
}
",,
implicit_predicate,branch.c,645,+,-,"if (copy)
    warning(_(""created a copy of a misnamed branch '%s'""), interpreted_oldname);
else
    warning(_(""renamed a misnamed branch '%s' away""), interpreted_oldname);
",,
implicit_predicate,branch.c,691,+,-,"if (dry_run)
    strvec_push(&child.args, ""--dry-run"");
",,
implicit_predicate,branch.c,693,+,-,"if (force)
    strvec_push(&child.args, ""--force"");
",,
implicit_predicate,branch.c,695,+,-,"if (quiet)
    strvec_push(&child.args, ""--quiet"");
",,
implicit_predicate,branch.c,697,+,-,"if (reflog)
    strvec_push(&child.args, ""--create-reflog"");
",,
implicit_predicate,branch.c,699,-,+,,28,"		git_config_set(name.buf, buf.len ? buf.buf : NULL);"
implicit_predicate,branch.c,731,+,-,"if (ret)
    fprintf(stderr, ""%s"", out_buf.buf);
else
    printf(""%s"", out_buf.buf);
",,
implicit_predicate,branch.c,793,+,-,"if (dry_run)
    return;
",,
implicit_predicate,branch.c,915,-,+,,8,"			die(copy? _(""cannot copy the current branch while not on any"")
				: _(""cannot rename the current branch while not on any""));"
implicit_predicate,branch.c,922,-,+,,8,"			die(copy? _(""too many branches for a copy operation"")
				: _(""too many arguments for a rename operation""));"
implicit_predicate,bugreport.c,45,-,+,,7,"		    shell ? shell : ""<unset>"");"
implicit_predicate,bugreport.c,52,+,-,"if (nongit){
    strbuf_addstr(hook_info, _(""not run from a git repository - no hooks to show\n""));
    return;
}
",,
implicit_predicate,bugreport.c,130,+,-,"if (argc){
    error(_(""unknown argument `%s'""), argv[0]);
    usage(bugreport_usage[0]);
}
",,
implicit_predicate,bugreport.c,137,-,+,,10,"					    option_output ? option_output : """");"
implicit_predicate,bulk-checkin.c,199,-,+,,28,"		status = git_deflate(&s, size ? 0 : Z_FINISH);"
implicit_predicate,bulk-checkin.c,202,+,-,"if (write_object){
    size_t written = s.next_out - obuf;
    if (state->nr_written && pack_size_limit_cfg && pack_size_limit_cfg < state->offset + written){
        git_deflate_abort(&s);
        return -1;
    }
    hashwrite(state->f, obuf, written);
    state->offset += written;
}
",,
implicit_predicate,bulk-checkin.c,277,+,-,"while (1){
    prepare_to_stream(state, flags);
    if (idx){
        hashfile_checkpoint(state->f, &checkpoint);
        idx->offset = state->offset;
        crc32_begin(state->f);
    }
    if (!stream_blob_to_pack(state, &ctx, &already_hashed_to, fd, size, path, flags))
        break;

    if (!idx)
        BUG(""should not happen"");

    hashfile_truncate(state->f, &checkpoint);
    state->offset = checkpoint.offset;
    flush_bulk_checkin_packfile(state);
    if (lseek(fd, seekback, SEEK_SET) == (off_t) - 1)
        return error(""cannot seek back"");
}
",,
implicit_predicate,bulk-checkin.c,305,+,-,"if (already_written(state, result_oid)){
    hashfile_truncate(state->f, &checkpoint);
    state->offset = checkpoint.offset;
    free(idx);
}else{
    oidcpy(&idx->oid, result_oid);
    ALLOC_GROW(state->written, state->nr_written + 1, state->alloc_written);
    state->written[state->nr_written++] = idx;
}
",,
implicit_predicate,bulk-checkin.c,380,+,-,"if (odb_transaction_nesting)
    return;
",,
implicit_predicate,bundle-uri.c,32,-,+,,24,"	return strcmp(e1->id, id ? (const char *)id : e2->id);"
implicit_predicate,bundle-uri.c,76,+,-,"if (result)
    return result;
",,
implicit_predicate,bundle-uri.c,402,+,+,has_old ? &old_oid : NULL,5,"				has_old ? &old_oid : NULL,"
implicit_predicate,bundle-uri.c,564,+,-,"if (fetch_bundle_uri_internal(ctx.r, bundle, ctx.depth + 1, ctx.list)){
    bundle->unbundled = 1;
    move_direction = 1;
    goto move;
}
",,
implicit_predicate,bundle-uri.c,679,+,-,"if ((result = download_bundle_list(r, &list_from_bundle, global_list, depth)))
    goto cleanup;
",,
implicit_predicate,bundle-uri.c,725,+,-,"if ((result = !is_bundle(bundle->file, 1))){
    result = fetch_bundle_list_in_config_format(r, list, bundle, depth);
    if (result)
        warning(_(""file at URI '%s' is not a bundle or bundle list""), bundle->uri);

    goto cleanup;
}
",,
implicit_predicate,bundle-uri.c,728,+,-,"if (result)
    warning(_(""file at URI '%s' is not a bundle or bundle list""), bundle->uri);
",,
implicit_predicate,bundle-uri.c,814,+,-,"if ((result = fetch_bundle_uri_internal(r, &bundle, 0, &list)))
    goto cleanup;
",,
implicit_predicate,bundle-uri.c,846,+,-,"if ((result = download_bundle_list(r, list, &global_list, 0)))
    goto cleanup;
",,
implicit_predicate,bundle.c,124,+,-,"is_prereq ? ""-"" : """"",,
implicit_predicate,bundle.c,129,+,-,"if (is_prereq)
    string_list_append(&header->prerequisites, """")->util = dup;
else
    string_list_append(&header->references, p + 1)->util = dup;
",,
implicit_predicate,bundle.c,137,+,-,"if (status){
    close(fd);
    fd = -1;
}
",,
implicit_predicate,bundle.c,149,+,+,quiet ? VERIFY_BUNDLE_QUIET : VERIFY_BUNDLE_VERBOSE,6,			  quiet ? VERIFY_BUNDLE_QUIET : VERIFY_BUNDLE_VERBOSE)) {
implicit_predicate,bundle.c,161,+,+,quiet ? NULL : path,42,"	fd = read_bundle_header_fd(fd, &header, quiet ? NULL : path);"
implicit_predicate,bundle.c,211,+,-,"if (progress)
    strvec_pushl(&extra_index_pack_args, ""-v"", ""--progress-title"", _(""Unbundling objects""), NULL);
",,
implicit_predicate,bundle.c,245,+,-,"if (ret)
    goto cleanup;
",,
implicit_predicate,bundle.c,307,-,+,,27,"	line = memchr(line, '>', lineend ? lineend - line : buf + size - line);"
implicit_predicate,bundle.c,394,-,+,,17,		display_ref = (flag & REF_ISSYMREF) ? e->name : ref;
implicit_predicate,bundle.c,533,+,-,"if (bundle_to_stdout)
    bundle_fd = 1;
else
    bundle_fd = hold_lock_file_for_update(&lock, path, LOCK_DIE_ON_ERROR);
",,
implicit_predicate,bundle.c,600,+,-,"if (write_pack_data(bundle_fd, &revs_copy, pack_options))
    goto err;
",,
implicit_predicate,cache-tree.c,171,+,-,"if (silent)
    return -1;
",,
implicit_predicate,cache-tree.c,181,+,-,"if (funny)
    return -1;
",,
implicit_predicate,cache-tree.c,210,+,-,"if (funny)
    return -1;
",,
implicit_predicate,cache-tree.c,379,+,-,"if (contains_ita){
    to_invalidate = 1;
    expected_missing = 1;
}
",,
implicit_predicate,cache-tree.c,396,+,-,"if (expected_missing)
    return -1;
",,
implicit_predicate,cache-tree.c,438,+,-,"if (repair){
    struct object_id oid;
    hash_object_file(the_hash_algo, buffer.buf, buffer.len, OBJ_TREE, &oid);
    if (repo_has_object_file_with_flags(the_repository, &oid, OBJECT_INFO_SKIP_FETCH_OBJECT))
        oidcpy(&it->oid, &oid);
    else
        to_invalidate = 1;
}else
    if (dryrun){
        hash_object_file(the_hash_algo, buffer.buf, buffer.len, OBJ_TREE, &it->oid);
    }else
        if (write_object_file_flags(buffer.buf, buffer.len, OBJ_TREE, &it->oid, NULL, flags & WRITE_TREE_SILENT ? HASH_SILENT : 0)){
            strbuf_release(&buffer);
            return -1;
        }
",,
implicit_predicate,cache-tree.c,446,+,-,"if (dryrun){
    hash_object_file(the_hash_algo, buffer.buf, buffer.len, OBJ_TREE, &it->oid);
}else
    if (write_object_file_flags(buffer.buf, buffer.len, OBJ_TREE, &it->oid, NULL, flags & WRITE_TREE_SILENT ? HASH_SILENT : 0)){
        strbuf_release(&buffer);
        return -1;
    }
",,
implicit_predicate,cache-tree.c,450,-,+,,25,"					   &it->oid, NULL, flags & WRITE_TREE_SILENT
					   ? HASH_SILENT : 0)) {"
implicit_predicate,cache-tree.c,457,+,+,to_invalidate ? -1 : i - *skip_count,20,	it->entry_count = to_invalidate ? -1 : i - *skip_count;
implicit_predicate,cache-tree.c,472,+,-,"if (i)
    return i;
",,
implicit_predicate,cache-tree.c,525,+,-,"if (i){
    struct cache_tree_sub* prev = it->down[i - 1];
    if (subtree_name_cmp(down->name, down->namelen, prev->name, prev->namelen) <= 0)
        die(""fatal - unsorted cache subtree"");
}
",,
implicit_predicate,cat-file.c,118,+,-,"if (unknown_type)
    flags |= OBJECT_INFO_ALLOW_UNKNOWN_TYPE;
",,
implicit_predicate,cat-file.c,147,+,-,"if (use_mailmap){
    oi.typep = &type;
    oi.contentp = (void**)&buf;
}
",,
implicit_predicate,cat-file.c,206,+,-,"if (use_mailmap){
    size_t s = size;
    buf = replace_idents_using_mailmap(buf, &s);
    size = cast_size_t_to_ulong(s);
}
",,
implicit_predicate,cat-file.c,253,+,-,"if (use_mailmap){
    size_t s = size;
    buf = replace_idents_using_mailmap(buf, &s);
    size = cast_size_t_to_ulong(s);
}
",,
implicit_predicate,cat-file.c,320,+,-,"if (is_atom(""objectname"", atom, len)){
    if (!data->mark_query)
        strbuf_addstr(sb, oid_to_hex(&data->oid));
}else
    if (is_atom(""objecttype"", atom, len)){
        if (data->mark_query)
            data->info.typep = &data->type;
        else
            strbuf_addstr(sb, type_name(data->type));
    }else
        if (is_atom(""objectsize"", atom, len)){
            if (data->mark_query)
                data->info.sizep = &data->size;
            else
                strbuf_addf(sb, ""%"", (uintmax_t)data->size);
        }else
            if (is_atom(""objectsize:disk"", atom, len)){
                if (data->mark_query)
                    data->info.disk_sizep = &data->disk_size;
                else
                    strbuf_addf(sb, ""%"", (uintmax_t)data->disk_size);
            }else
                if (is_atom(""rest"", atom, len)){
                    if (data->mark_query)
                        data->split_on_whitespace = 1;
                    else
                        if (data->rest)
                            strbuf_addstr(sb, data->rest);
                }else
                    if (is_atom(""deltabase"", atom, len)){
                        if (data->mark_query)
                            data->info.delta_base_oid = &data->delta_base_oid;
                        else
                            strbuf_addstr(sb, oid_to_hex(&data->delta_base_oid));
                    }else
                        return 0;
",,
implicit_predicate,cat-file.c,323,+,-,"if (is_atom(""objecttype"", atom, len)){
    if (data->mark_query)
        data->info.typep = &data->type;
    else
        strbuf_addstr(sb, type_name(data->type));
}else
    if (is_atom(""objectsize"", atom, len)){
        if (data->mark_query)
            data->info.sizep = &data->size;
        else
            strbuf_addf(sb, ""%"", (uintmax_t)data->size);
    }else
        if (is_atom(""objectsize:disk"", atom, len)){
            if (data->mark_query)
                data->info.disk_sizep = &data->disk_size;
            else
                strbuf_addf(sb, ""%"", (uintmax_t)data->disk_size);
        }else
            if (is_atom(""rest"", atom, len)){
                if (data->mark_query)
                    data->split_on_whitespace = 1;
                else
                    if (data->rest)
                        strbuf_addstr(sb, data->rest);
            }else
                if (is_atom(""deltabase"", atom, len)){
                    if (data->mark_query)
                        data->info.delta_base_oid = &data->delta_base_oid;
                    else
                        strbuf_addstr(sb, oid_to_hex(&data->delta_base_oid));
                }else
                    return 0;
",,
implicit_predicate,cat-file.c,324,+,-,"if (data->mark_query)
    data->info.typep = &data->type;
else
    strbuf_addstr(sb, type_name(data->type));
",,
implicit_predicate,cat-file.c,328,+,-,"if (is_atom(""objectsize"", atom, len)){
    if (data->mark_query)
        data->info.sizep = &data->size;
    else
        strbuf_addf(sb, ""%"", (uintmax_t)data->size);
}else
    if (is_atom(""objectsize:disk"", atom, len)){
        if (data->mark_query)
            data->info.disk_sizep = &data->disk_size;
        else
            strbuf_addf(sb, ""%"", (uintmax_t)data->disk_size);
    }else
        if (is_atom(""rest"", atom, len)){
            if (data->mark_query)
                data->split_on_whitespace = 1;
            else
                if (data->rest)
                    strbuf_addstr(sb, data->rest);
        }else
            if (is_atom(""deltabase"", atom, len)){
                if (data->mark_query)
                    data->info.delta_base_oid = &data->delta_base_oid;
                else
                    strbuf_addstr(sb, oid_to_hex(&data->delta_base_oid));
            }else
                return 0;
",,
implicit_predicate,cat-file.c,329,+,-,"if (data->mark_query)
    data->info.sizep = &data->size;
else
    strbuf_addf(sb, ""%"", (uintmax_t)data->size);
",,
implicit_predicate,cat-file.c,333,+,-,"if (is_atom(""objectsize:disk"", atom, len)){
    if (data->mark_query)
        data->info.disk_sizep = &data->disk_size;
    else
        strbuf_addf(sb, ""%"", (uintmax_t)data->disk_size);
}else
    if (is_atom(""rest"", atom, len)){
        if (data->mark_query)
            data->split_on_whitespace = 1;
        else
            if (data->rest)
                strbuf_addstr(sb, data->rest);
    }else
        if (is_atom(""deltabase"", atom, len)){
            if (data->mark_query)
                data->info.delta_base_oid = &data->delta_base_oid;
            else
                strbuf_addstr(sb, oid_to_hex(&data->delta_base_oid));
        }else
            return 0;
",,
implicit_predicate,cat-file.c,334,+,-,"if (data->mark_query)
    data->info.disk_sizep = &data->disk_size;
else
    strbuf_addf(sb, ""%"", (uintmax_t)data->disk_size);
",,
implicit_predicate,cat-file.c,338,+,-,"if (is_atom(""rest"", atom, len)){
    if (data->mark_query)
        data->split_on_whitespace = 1;
    else
        if (data->rest)
            strbuf_addstr(sb, data->rest);
}else
    if (is_atom(""deltabase"", atom, len)){
        if (data->mark_query)
            data->info.delta_base_oid = &data->delta_base_oid;
        else
            strbuf_addstr(sb, oid_to_hex(&data->delta_base_oid));
    }else
        return 0;
",,
implicit_predicate,cat-file.c,339,+,-,"if (data->mark_query)
    data->split_on_whitespace = 1;
else
    if (data->rest)
        strbuf_addstr(sb, data->rest);
",,
implicit_predicate,cat-file.c,343,+,-,"if (is_atom(""deltabase"", atom, len)){
    if (data->mark_query)
        data->info.delta_base_oid = &data->delta_base_oid;
    else
        strbuf_addstr(sb, oid_to_hex(&data->delta_base_oid));
}else
    return 0;
",,
implicit_predicate,cat-file.c,344,+,-,"if (data->mark_query)
    data->info.delta_base_oid = &data->delta_base_oid;
else
    strbuf_addstr(sb, oid_to_hex(&data->delta_base_oid));
",,
implicit_predicate,cat-file.c,372,+,-,"if (opt->buffer_output){
    if (fwrite(data, 1, len, stdout) != len)
        die_errno(""unable to write to stdout"");
}else
    write_or_die(1, data, len);
",,
implicit_predicate,cat-file.c,386,+,-,"if (opt->buffer_output)
    fflush (stdout);
",,
implicit_predicate,cat-file.c,388,+,-,"if (opt->transform_mode){
    char* contents;
    unsigned long size;
    if (!data->rest)
        die(""missing path for '%s'"", oid_to_hex(oid));

    if (opt->transform_mode == 'w'){
        if (filter_object(data->rest, 0100644, oid, &contents, &size))
            die(""could not convert '%s' %s"", oid_to_hex(oid), data->rest);
    }else
        if (opt->transform_mode == 'c'){
            enum object_type type;
            if (!textconv_object(the_repository, data->rest, 0100644, oid, 1, &contents, &size))
                contents = repo_read_object_file(the_repository, oid, &type, &size);

            if (!contents)
                die(""could not convert '%s' %s"", oid_to_hex(oid), data->rest);
        }else
            BUG(""invalid transform_mode: %c"", opt->transform_mode);

    batch_write(opt, contents, size);
    free(contents);
}else{
    stream_blob(oid);
}
",,
implicit_predicate,cat-file.c,396,+,-,"if (filter_object(data->rest, 0100644, oid, &contents, &size))
    die(""could not convert '%s' %s"", oid_to_hex(oid), data->rest);
",,
implicit_predicate,cat-file.c,430,+,-,"if (use_mailmap){
    size_t s = size;
    contents = replace_idents_using_mailmap(contents, &s);
    size = cast_size_t_to_ulong(s);
}
",,
implicit_predicate,cat-file.c,469,+,-,"if (use_mailmap)
    data->info.typep = &data->type;
",,
implicit_predicate,cat-file.c,481,-,+,,11,"			       obj_name ? obj_name : oid_to_hex(&data->oid), opt->output_delim);"
implicit_predicate,cat-file.c,526,+,+,opt->follow_symlinks ? GET_OID_FOLLOW_SYMLINKS : 0,4,		(opt->follow_symlinks ? GET_OID_FOLLOW_SYMLINKS : 0);
implicit_predicate,cat-file.c,787,-,+,,9,"		      opt->format ? opt->format : DEFAULT_FORMAT,"
implicit_predicate,cat-file.c,791,+,-,"if (opt->transform_mode)
    data.split_on_whitespace = 1;
",,
implicit_predicate,cat-file.c,803,+,-,"if (opt->all_objects){
    struct object_cb_data cb;
    struct object_info empty = OBJECT_INFO_INIT;
    if (!memcmp(&data.info, &empty, sizeof (empty)))
        data.skip_object_info = 1;

    if (repo_has_promisor_remote (the_repository))
        warning(""This repository uses promisor remotes. Some objects may not be loaded."");

    disable_replace_refs();
    cb.opt = opt;
    cb.expand = &data;
    cb.scratch = &output;
    if (opt->unordered){
        struct oidset seen = OIDSET_INIT;
        cb.seen = &seen;
        for_each_loose_object(batch_unordered_loose, &cb, 0);
        for_each_packed_object(batch_unordered_packed, &cb, FOR_EACH_OBJECT_PACK_ORDER);
        oidset_clear(&seen);
    }else{
        struct oid_array sa = OID_ARRAY_INIT;
        for_each_loose_object(collect_loose_object, &sa, 0);
        for_each_packed_object(collect_packed_object, &sa, 0);
        oid_array_for_each_unique(&sa, batch_object_cb, &cb);
        oid_array_clear(&sa);
    }
    strbuf_release(&output);
    return 0;
}
",,
implicit_predicate,cat-file.c,819,+,-,"if (opt->unordered){
    struct oidset seen = OIDSET_INIT;
    cb.seen = &seen;
    for_each_loose_object(batch_unordered_loose, &cb, 0);
    for_each_packed_object(batch_unordered_packed, &cb, FOR_EACH_OBJECT_PACK_ORDER);
    oidset_clear(&seen);
}else{
    struct oid_array sa = OID_ARRAY_INIT;
    for_each_loose_object(collect_loose_object, &sa, 0);
    for_each_packed_object(collect_packed_object, &sa, 0);
    oid_array_for_each_unique(&sa, batch_object_cb, &cb);
    oid_array_clear(&sa);
}
",,
implicit_predicate,cat-file.c,860,+,-,"if (data.split_on_whitespace){
    char* p = strpbrk(input.buf, "" \t"");
    if (p){
        while (*p && strchr("" \t"", *p))
            *p++ = '\0';
    }
    data.rest = p;
}
",,
implicit_predicate,cat-file.c,901,+,-,"if (bo->enabled){
    return error(_(""only one batch option may be specified""));
}
",,
implicit_predicate,cat-file.c,1002,+,-,"if (use_mailmap)
    read_mailmap(&mailmap);
",,
implicit_predicate,cat-file.c,1017,+,-,"if (batch.enabled);

else
    if (batch.follow_symlinks)
        usage_msg_optf(_(""'%s' requires a batch mode""), usage, options, ""--follow-symlinks"");
    else
        if (batch.buffer_output >= 0)
            usage_msg_optf(_(""'%s' requires a batch mode""), usage, options, ""--buffer"");
        else
            if (batch.all_objects)
                usage_msg_optf(_(""'%s' requires a batch mode""), usage, options, ""--batch-all-objects"");
            else
                if (input_nul_terminated)
                    usage_msg_optf(_(""'%s' requires a batch mode""), usage, options, ""-z"");
                else
                    if (nul_terminated)
                        usage_msg_optf(_(""'%s' requires a batch mode""), usage, options, ""-Z"");
",,
implicit_predicate,cat-file.c,1019,+,-,"if (batch.follow_symlinks)
    usage_msg_optf(_(""'%s' requires a batch mode""), usage, options, ""--follow-symlinks"");
else
    if (batch.buffer_output >= 0)
        usage_msg_optf(_(""'%s' requires a batch mode""), usage, options, ""--buffer"");
    else
        if (batch.all_objects)
            usage_msg_optf(_(""'%s' requires a batch mode""), usage, options, ""--batch-all-objects"");
        else
            if (input_nul_terminated)
                usage_msg_optf(_(""'%s' requires a batch mode""), usage, options, ""-z"");
            else
                if (nul_terminated)
                    usage_msg_optf(_(""'%s' requires a batch mode""), usage, options, ""-Z"");
",,
implicit_predicate,cat-file.c,1025,+,-,"if (batch.all_objects)
    usage_msg_optf(_(""'%s' requires a batch mode""), usage, options, ""--batch-all-objects"");
else
    if (input_nul_terminated)
        usage_msg_optf(_(""'%s' requires a batch mode""), usage, options, ""-z"");
    else
        if (nul_terminated)
            usage_msg_optf(_(""'%s' requires a batch mode""), usage, options, ""-Z"");
",,
implicit_predicate,cat-file.c,1028,+,-,"if (input_nul_terminated)
    usage_msg_optf(_(""'%s' requires a batch mode""), usage, options, ""-z"");
else
    if (nul_terminated)
        usage_msg_optf(_(""'%s' requires a batch mode""), usage, options, ""-Z"");
",,
implicit_predicate,cat-file.c,1031,+,-,"if (nul_terminated)
    usage_msg_optf(_(""'%s' requires a batch mode""), usage, options, ""-Z"");
",,
implicit_predicate,cat-file.c,1036,+,-,"if (input_nul_terminated)
    batch.input_delim = '\0';
",,
implicit_predicate,cat-file.c,1038,+,-,"if (nul_terminated)
    batch.input_delim = batch.output_delim = '\0';
",,
implicit_predicate,cat-file.c,1046,+,-,"if (batch.enabled){
    if (opt_cw)
        batch.transform_mode = opt;
    else
        if (opt && opt != 'b')
            usage_msg_optf(_(""'-%c' is incompatible with batch mode""), usage, options, opt);
        else
            if (argc)
                usage_msg_opt(_(""batch modes take no arguments""), usage, options);

    return batch_objects(&batch);
}
",,
implicit_predicate,cat-file.c,1047,+,-,"if (opt_cw)
    batch.transform_mode = opt;
else
    if (opt && opt != 'b')
        usage_msg_optf(_(""'-%c' is incompatible with batch mode""), usage, options, opt);
    else
        if (argc)
            usage_msg_opt(_(""batch modes take no arguments""), usage, options);
",,
implicit_predicate,cat-file.c,1052,+,-,"if (argc)
    usage_msg_opt(_(""batch modes take no arguments""), usage, options);
",,
implicit_predicate,cat-file.c,1059,+,-,"if (opt){
    if (!argc && opt == 'c')
        usage_msg_optf(_(""<rev> required with '%s'""), usage, options, ""--textconv"");
    else
        if (!argc && opt == 'w')
            usage_msg_optf(_(""<rev> required with '%s'""), usage, options, ""--filters"");
        else
            if (!argc && opt_epts)
                usage_msg_optf(_(""<object> required with '-%c'""), usage, options, opt);
            else
                if (argc == 1)
                    obj_name = argv[0];
                else
                    usage_msg_opt(_(""too many arguments""), usage, options);
}else
    if (!argc){
        usage_with_options(usage, options);
    }else
        if (argc != 2){
            usage_msg_optf(_(""only two arguments allowed in <type> <object> mode, not %d""), usage, options, argc);
        }else
            if (argc){
                exp_type = argv[0];
                obj_name = argv[1];
            }
",,
implicit_predicate,cat-file.c,1078,+,-,"if (argc){
    exp_type = argv[0];
    obj_name = argv[1];
}
",,
implicit_predicate,check-attr.c,50,+,-,"if (nul_term_line){
    printf(""%s%c%s%c%s%c"", file, 0, git_attr_name(check->items[j].attr), 0, value, 0);
}else{
    quote_c_style(file, NULL, stdout, 0);
    printf("": %s: %s\n"", git_attr_name(check->items[j].attr), value);
}
",,
implicit_predicate,check-attr.c,70,-,+,,23,"		prefix_path(prefix, prefix ? strlen(prefix) : 0, file);"
implicit_predicate,check-attr.c,72,+,-,"if (collect_all){
    git_all_attrs(the_repository->index, full_path, check);
}else{
    git_check_attr(the_repository->index, full_path, check);
}
",,
implicit_predicate,check-attr.c,89,+,+,nul_term_line ? strbuf_getline_nul : strbuf_getline_lf,15,	getline_fn = nul_term_line ? strbuf_getline_nul : strbuf_getline_lf;
implicit_predicate,check-attr.c,131,+,-,"if (cached_attrs)
    git_attr_set_direction (GIT_ATTR_INDEX);
",,
implicit_predicate,check-attr.c,141,+,-,"if (all_attrs){
    if (doubledash >= 1)
        error_with_usage(""Attributes and --all both specified"");

    cnt = 0;
    filei = doubledash + 1;
}else
    if (doubledash == 0){
        error_with_usage(""No attribute specified"");
    }else
        if (doubledash < 0){
            if (!argc)
                error_with_usage(""No attribute specified"");

            if (stdin_paths){
                cnt = argc;
                filei = argc;
            }else{
                cnt = 1;
                filei = 1;
            }
        }else{
            cnt = doubledash;
            filei = doubledash + 1;
        }
",,
implicit_predicate,check-attr.c,153,+,-,"if (stdin_paths){
    cnt = argc;
    filei = argc;
}else{
    cnt = 1;
    filei = 1;
}
",,
implicit_predicate,check-attr.c,168,+,-,"if (stdin_paths){
    if (filei < argc)
        error_with_usage(""Can't specify files with --stdin"");
}else{
    if (filei >= argc)
        error_with_usage(""No file specified"");
}
",,
implicit_predicate,check-attr.c,194,+,-,"if (stdin_paths)
    check_attr_stdin_paths(prefix, check, all_attrs);
else{
    for (i = filei;i < argc;i++)
        check_attr(prefix, check, all_attrs, argv[i]);
    maybe_flush_or_die(stdout, ""attribute to stdout"");
}
",,
implicit_predicate,check-ignore.c,136,+,+,nul_term_line ? strbuf_getline_nul : strbuf_getline_lf,15,	getline_fn = nul_term_line ? strbuf_getline_nul : strbuf_getline_lf;
implicit_predicate,check-ignore.c,164,+,-,"if (stdin_paths){
    if (argc > 0)
        die(_(""cannot specify pathnames with --stdin""));
}else{
    if (nul_term_line)
        die(_(""-z only makes sense with --stdin""));

    if (argc == 0)
        die(_(""no path specified""));
}
",,
implicit_predicate,check-ignore.c,168,+,-,"if (nul_term_line)
    die(_(""-z only makes sense with --stdin""));
",,
implicit_predicate,check-ignore.c,173,+,-,"if (quiet){
    if (argc > 1)
        die(_(""--quiet is only valid with a single pathname""));

    if (verbose)
        die(_(""cannot have both --quiet and --verbose""));
}
",,
implicit_predicate,check-ignore.c,176,+,-,"if (verbose)
    die(_(""cannot have both --quiet and --verbose""));
",,
implicit_predicate,check-ignore.c,188,+,-,"if (stdin_paths){
    num_ignored = check_ignore_stdin_paths(&dir, prefix);
}else{
    num_ignored = check_ignore(&dir, prefix, argc, argv);
    maybe_flush_or_die(stdout, ""ignore to stdout"");
}
",,
implicit_predicate,check-mailmap.c,60,+,-,"if (use_stdin){
    struct strbuf buf = STRBUF_INIT;
    while (strbuf_getline_lf(&buf, stdin) != EOF){
        check_mailmap(&mailmap, buf.buf);
        maybe_flush_or_die(stdout, ""stdout"");
    }
    strbuf_release(&buf);
}
",,
implicit_predicate,check-ref-format.c,87,+,-,"if (normalize)
    refname = to_free = collapse_slashes(refname);
",,
implicit_predicate,check-ref-format.c,91,+,-,"if (normalize)
    printf(""%s\n"", refname);
",,
implicit_predicate,checkout--worker.c,86,+,-,"while (1){
    int len = packet_read(0, packet_buffer, sizeof (packet_buffer), 0);
    if (len < 0)
        BUG(""packet_read() returned negative value"");
    else
        if (!len)
            break;

    ALLOC_GROW(items, nr + 1, alloc);
    packet_to_pc_item(packet_buffer, len, &items[nr++]);
}
",,
implicit_predicate,checkout-index.c,38,+,-,"if (topath[i][0]){
    have_tempname = 1;
    break;
}
",,
implicit_predicate,checkout-index.c,43,+,-,"if (have_tempname){
    for (i = 1;i < 4;i++){
        if (i > 1)
            putchar(' ');

        if (topath[i][0])
            fputs(topath[i], stdout);
        else
            putchar('.');
    }
}
",,
implicit_predicate,checkout-index.c,47,+,-,"if (topath[i][0])
    fputs(topath[i], stdout);
else
    putchar('.');
",,
implicit_predicate,checkout-index.c,53,+,-,"if (topath[checkout_stage][0]){
    have_tempname = 1;
    fputs(topath[checkout_stage], stdout);
}
",,
implicit_predicate,checkout-index.c,58,+,-,"if (have_tempname){
    putchar('\t');
    write_name_quoted_relative(name, prefix, stdout, nul_term_line ? '\0' : '\n');
}
",,
implicit_predicate,checkout-index.c,61,+,+,nul_term_line ? '\0' : '\n',9,					   nul_term_line ? '\0' : '\n');
implicit_predicate,checkout-index.c,100,+,+,to_tempfile ? topath[ce_stage(ce)] : NULL,8,"				   to_tempfile ? topath[ce_stage(ce)] : NULL,"
implicit_predicate,checkout-index.c,105,+,-,"if (did_checkout){
    if (to_tempfile)
        write_tempfile_record(name, prefix);

    return errs > 0 ? -1 : 0;
}
",,
implicit_predicate,checkout-index.c,106,+,-,"if (to_tempfile)
    write_tempfile_record(name, prefix);
",,
implicit_predicate,checkout-index.c,125,+,-,"if (is_skipped)
    fprintf(stderr, ""has skip-worktree enabled; use '--ignore-skip-worktree-bits' to checkout"");
else
    if (checkout_stage)
        fprintf(stderr, ""does not exist at stage %d"", checkout_stage);
    else
        fprintf(stderr, ""is unmerged"");
",,
implicit_predicate,checkout-index.c,128,+,-,"if (checkout_stage)
    fprintf(stderr, ""does not exist at stage %d"", checkout_stage);
else
    fprintf(stderr, ""is unmerged"");
",,
implicit_predicate,checkout-index.c,156,+,-,"if (ignore_skip_worktree){
    ensure_full_index(the_repository->index);
    ce = the_repository->index->cache[i];
}
",,
implicit_predicate,checkout-index.c,177,+,+,to_tempfile ? topath[ce_stage(ce)] : NULL,8,"				   to_tempfile ? topath[ce_stage(ce)] : NULL,"
implicit_predicate,checkout-index.c,252,-,+,,18,	prefix_length = prefix ? strlen(prefix) : 0;
implicit_predicate,checkout-index.c,297,+,-,"if (all)
    die(""git checkout-index: don't mix '--all' and explicit filenames"");
",,
implicit_predicate,checkout-index.c,299,+,-,"if (read_from_stdin)
    die(""git checkout-index: don't mix '--stdin' and explicit filenames"");
",,
implicit_predicate,checkout-index.c,306,+,-,"if (read_from_stdin){
    struct strbuf buf = STRBUF_INIT;
    struct strbuf unquoted = STRBUF_INIT;
    strbuf_getline_fn getline_fn;
    if (all)
        die(""git checkout-index: don't mix '--all' and '--stdin'"");

    getline_fn = nul_term_line ? strbuf_getline_nul : strbuf_getline_lf;
    while (getline_fn(&buf, stdin) != EOF){
        char* p;
        if (!nul_term_line && buf.buf[0] == '""'){
            strbuf_reset(&unquoted);
            if (unquote_c_style(&unquoted, buf.buf, NULL))
                die(""line is badly quoted"");

            strbuf_swap(&buf, &unquoted);
        }
        p = prefix_path(prefix, prefix_length, buf.buf);
        err |= checkout_file(p, prefix);
        free(p);
    }
    strbuf_release(&unquoted);
    strbuf_release(&buf);
}
",,
implicit_predicate,checkout-index.c,311,+,-,"if (all)
    die(""git checkout-index: don't mix '--all' and '--stdin'"");
",,
implicit_predicate,checkout-index.c,314,+,+,nul_term_line ? strbuf_getline_nul : strbuf_getline_lf,16,		getline_fn = nul_term_line ? strbuf_getline_nul : strbuf_getline_lf;
implicit_predicate,checkout-index.c,331,+,-,"if (all)
    err |= checkout_all(prefix, prefix_length);
",,
implicit_predicate,checkout-index.c,338,+,-,"if (err)
    return 1;
",,
implicit_predicate,checkout.c,129,-,+,,18,"			   oid_to_hex(old_commit ? &old_commit->object.oid : null_oid()),"
implicit_predicate,checkout.c,130,-,+,,18,"			   oid_to_hex(new_commit ? &new_commit->object.oid : null_oid()),"
implicit_predicate,checkout.c,131,+,+,"changed ? ""1"" : ""0""",7,"			   changed ? ""1"" : ""0"", NULL);"
implicit_predicate,checkout.c,398,-,+,,11,"			       info->commit ? &info->commit->object.oid : &info->oid,"
implicit_predicate,checkout.c,436,+,-,"if (nr_unmerged)
    fprintf_ln(stderr, Q_(""Recreated %d merge conflict"", ""Recreated %d merge conflicts"", nr_unmerged), nr_unmerged);
",,
implicit_predicate,checkout.c,617,+,-,"if (errs)
    return 1;
",,
implicit_predicate,checkout.c,635,+,-,"if (checkout_index){
    if (write_locked_index(the_repository->index, &lock_file, COMMIT_LOCK))
        die(_(""unable to write new index file""));
}else{
    rollback_lock_file(&lock_file);
}
",,
implicit_predicate,checkout.c,700,-,+,,15,"	opts.reset = o->force ? UNPACK_RESET_OVERWRITE_UNTRACKED :
				UNPACK_RESET_PROTECT_UNTRACKED;"
implicit_predicate,checkout.c,709,-,+,,11,"			       info->commit ? &info->commit->object.oid : null_oid(),"
implicit_predicate,checkout.c,802,+,-,"if (ret)
    return ret;
",,
implicit_predicate,checkout.c,821,-,+,,12,"				       new_branch_info->commit ?
				       &new_branch_info->commit->object.oid :
				       &new_branch_info->oid, NULL);"
implicit_predicate,checkout.c,825,-,+,,20,"		old_commit_oid = old_branch_info->commit ?
			&old_branch_info->commit->object.oid :
			the_hash_algo->empty_tree;"
implicit_predicate,checkout.c,894,+,-,"if (ret)
    return ret;
",,
implicit_predicate,checkout.c,917,+,-,"if (ret)
    return ret;
",,
implicit_predicate,checkout.c,963,+,-,"if (ret){
    fprintf(stderr, _(""Can not do reflog for '%s': %s\n""), opts->new_orphan_branch, err.buf);
    strbuf_release(&err);
    free(refname);
    return;
}
",,
implicit_predicate,checkout.c,977,-,+,,11,"				      opts->new_branch_force ? 1 : 0,"
implicit_predicate,checkout.c,978,-,+,,11,"				      opts->new_branch_force ? 1 : 0,"
implicit_predicate,checkout.c,996,-,+,,4,"			old_desc ? old_desc : ""(invalid)"", new_branch_info->name);"
implicit_predicate,checkout.c,1200,+,-,"if (do_merge){
    ret = merge_working_tree(opts, &old_branch_info, new_branch_info, &writeout_error);
    if (ret){
        branch_info_release(&old_branch_info);
        return ret;
    }
}
",,
implicit_predicate,checkout.c,1202,+,-,"if (ret){
    branch_info_release(&old_branch_info);
    return ret;
}
",,
implicit_predicate,checkout.c,1418,+,-,"if (recover_with_dwim){
    const char* remote = parse_remote_branch(arg, rev, could_be_checkout_paths);
    if (remote){
        *new_branch = arg;
        arg = remote;
    }else{
        recover_with_dwim = 0;
    }
}
",,
implicit_predicate,checkout.c,1431,+,-,"if (has_dash_dash)
    die(_(""invalid reference: %s""), arg);
",,
implicit_predicate,checkout.c,1454,+,-,"if (argc)
    verify_non_filename(opts->prefix, arg);
",,
implicit_predicate,checkout.c,1456,+,-,"if (opts->accept_pathspec){
    argcount++;
    argv++;
    argc--;
}
",,
implicit_predicate,checkout.c,1561,+,-,"if (opts->ignore_other_worktrees)
    return;
",,
implicit_predicate,checkout.c,1576,+,-,"if (opts->patch_mode)
    die(_(""'%s' cannot be used with switching branches""), ""--patch"");
",,
implicit_predicate,checkout.c,1584,+,-,"if (opts->writeout_stage)
    die(_(""'%s' cannot be used with switching branches""), ""--ours/--theirs"");
",,
implicit_predicate,checkout.c,1603,+,-,"if (opts->force_detach){
    if (opts->track != BRANCH_TRACK_UNSPECIFIED)
        die(_(""'%s' cannot be used with '%s'""), ""--detach"", ""-t"");
}else
    if (opts->track == BRANCH_TRACK_UNSPECIFIED)
        opts->track = git_branch_track;
",,
implicit_predicate,checkout.c,1656,+,-,"if (unset){
    opts->conflict_style = -1;
    return 0;
}
",,
implicit_predicate,checkout.c,1768,+,-,"if (opts->quiet)
    opts->show_progress = 0;
else
    opts->show_progress = isatty(2);
",,
implicit_predicate,checkout.c,1778,+,-,"if (opts->force){
    opts->discard_changes = 1;
    opts->ignore_unmerged_opt = ""--force"";
    opts->ignore_unmerged = 1;
}
",,
implicit_predicate,checkout.c,1873,+,-,"if (argc){
    parse_pathspec(&opts->pathspec, 0, opts->patch_mode ? PATHSPEC_PREFIX_ORIGIN : 0, prefix, argv);
    if (!opts->pathspec.nr)
        die(_(""invalid path specification""));

    if (opts->new_branch && argc == 1 && !new_branch_info.commit)
        die(_(""'%s' is not a commit and a branch '%s' cannot be created from it""), argv[0], opts->new_branch);

    if (opts->force_detach)
        die(_(""git checkout: --detach does not take a path argument '%s'""), argv[0]);
}
",,
implicit_predicate,checkout.c,1875,+,+,opts->patch_mode ? PATHSPEC_PREFIX_ORIGIN : 0,11,"			       opts->patch_mode ? PATHSPEC_PREFIX_ORIGIN : 0,"
implicit_predicate,checkout.c,1889,+,-,"if (opts->force_detach)
    die(_(""git checkout: --detach does not take a path argument '%s'""), argv[0]);
",,
implicit_predicate,checkout.c,1898,+,-,"if (opts->force_detach)
    die(_(""options '%s' and '%s' cannot be used together""), ""--pathspec-from-file"", ""--detach"");
",,
implicit_predicate,checkout.c,1901,+,-,"if (opts->patch_mode)
    die(_(""options '%s' and '%s' cannot be used together""), ""--pathspec-from-file"", ""--patch"");
",,
implicit_predicate,checkout.c,1907,+,-,"if (opts->pathspec_file_nul){
    die(_(""the option '%s' requires '%s'""), ""--pathspec-file-nul"", ""--pathspec-from-file"");
}
",,
implicit_predicate,chunk-format.c,87,+,-,"if (result)
    goto cleanup;
",,
implicit_predicate,chunk-format.c,114,+,-,<!!!>,,
implicit_predicate,clean.c,177,+,+,dry_run ? _(msg_would_skip_git_dir) : _(msg_skip_git_dir),11,"			printf(dry_run ?  _(msg_would_skip_git_dir) : _(msg_skip_git_dir),"
implicit_predicate,clean.c,188,+,+,dry_run ? 0 : rmdir(path->buf),9,		res = dry_run ? 0 : rmdir(path->buf);
implicit_predicate,clean.c,189,+,-,"if (res){
    int saved_errno = errno;
    quote_path(path->buf, prefix, &quoted, 0);
    errno = saved_errno;
    warning_errno(_(msg_warn_remove_failed), quoted.buf);
    *dir_gone = 0;
}
",,
implicit_predicate,clean.c,211,+,-,"if (remove_dirs(path, prefix, force_flag, dry_run, quiet, &gone))
    ret = 1;
",,
implicit_predicate,clean.c,213,+,-,"if (gone){
    quote_path(path->buf, prefix, &quoted, 0);
    string_list_append(&dels, quoted.buf);
}else
    *dir_gone = 0;
",,
implicit_predicate,clean.c,220,+,+,dry_run ? 0 : unlink(path->buf),10,			res = dry_run ? 0 : unlink(path->buf);
implicit_predicate,clean.c,244,+,-,"if (*dir_gone){
    strbuf_realpath(&realpath, path->buf, 1);
    if (startup_info->original_cwd)
        strbuf_realpath(&real_ocwd, startup_info->original_cwd, 1);

    if (!strbuf_cmp(&realpath, &real_ocwd)){
        printf(""%s"", dry_run ? _(msg_would_skip_cwd) : _(msg_skip_cwd));
        *dir_gone = 0;
    }else{
        res = dry_run ? 0 : rmdir(path->buf);
        if (!res)
            *dir_gone = 1;
        else{
            int saved_errno = errno;
            quote_path(path->buf, prefix, &quoted, 0);
            errno = saved_errno;
            warning_errno(_(msg_warn_remove_failed), quoted.buf);
            *dir_gone = 0;
            ret = 1;
        }
    }
}
",,
implicit_predicate,clean.c,261,+,+,dry_run ? _(msg_would_skip_cwd) : _(msg_skip_cwd),17,"			printf(""%s"", dry_run ? _(msg_would_skip_cwd) : _(msg_skip_cwd));"
implicit_predicate,clean.c,264,+,+,dry_run ? 0 : rmdir(path->buf),10,			res = dry_run ? 0 : rmdir(path->buf);
implicit_predicate,clean.c,281,+,+,dry_run ? _(msg_would_remove) : _(msg_remove),11,"			printf(dry_run ?  _(msg_would_remove) : _(msg_remove), dels.items[i].string);"
implicit_predicate,clean.c,332,+,+,"singleton ? _(""Prompt help:\n1          - select a numbered item\nfoo        - select item based on unique prefix\n           - (empty) select nothing\n"") : _(""Prompt help:\n1          - select a single item\n3-5        - select a range of items\n2-3,6-9    - select multiple ranges\nfoo        - select item based on unique prefix\n-...       - unselect specified items\n*          - choose all items\n           - (empty) finish selecting\n"")",9,"	printf(singleton ?
		  _(""Prompt help:\n""
		    ""1          - select a numbered item\n""
		    ""foo        - select item based on unique prefix\n""
		    ""           - (empty) select nothing\n"") :
		  _(""Prompt help:\n""
		    ""1          - select a single item\n""
		    ""3-5        - select a range of items\n""
		    ""2-3,6-9    - select multiple ranges\n""
		    ""foo        - select item based on unique prefix\n""
		    ""-...       - unselect specified items\n""
		    ""*          - choose all items\n""
		    ""           - (empty) finish selecting\n""));"
implicit_predicate,clean.c,370,+,+,menu_item->selected ? 1 : 0,20,				(*chosen)[i] = menu_item->selected ? 1 : 0;
implicit_predicate,clean.c,371,+,+,"(*chosen)[i] ? ""*"" : "" """,34,"			strbuf_addf(&menu, ""%s%2d: "", (*chosen)[i] ? ""*"" : "" "", i+1);"
implicit_predicate,clean.c,392,+,+,"(*chosen)[i] ? ""*"" : "" """,9,"				    (*chosen)[i] ? ""*"" : "" "", i+1, string_list_item->string);"
implicit_predicate,clean.c,425,+,-,"if (found){
    if (len == 1){
        found = -1;
    }else{
        found = 0;
        break;
    }
}else{
    found = i + 1;
}
",,
implicit_predicate,clean.c,443,+,-,"if (found){
    found = 0;
    break;
}
",,
implicit_predicate,clean.c,485,+,-,"if (is_single){
    choice_list = strbuf_split_max(&input, '\n', 0);
}else{
    char* p = input.buf;
    do{
        if (*p == ',')
            *p = ' ';
    } while (*p++);
    choice_list = strbuf_split_max(&input, ' ', 0);
}
",,
implicit_predicate,clean.c,489,+,-,"do{
    if (*p == ',')
        *p = ' ';
} while (*p++);
",,
implicit_predicate,clean.c,514,+,-,"for (p = (*ptr)->buf;*p;p++){
    if ('-' == *p){
        if (!is_range){
            is_range = 1;
            is_number = 0;
        }else{
            is_number = 0;
            is_range = 0;
            break;
        }
    }else
        if (!isdigit(*p)){
            is_number = 0;
            is_range = 0;
            break;
        }
}
",,
implicit_predicate,clean.c,531,+,-,"if (is_number){
    bottom = atoi((*ptr)->buf);
    top = bottom;
}else
    if (is_range){
        bottom = atoi((*ptr)->buf);
        if (!*(strchr((*ptr)->buf, '-') + 1))
            top = menu_stuff->nr;
        else
            top = atoi(strchr((*ptr)->buf, '-') + 1);
    }else
        if (!strcmp((*ptr)->buf, ""*"")){
            bottom = 1;
            top = menu_stuff->nr;
        }else{
            bottom = find_unique((*ptr)->buf, menu_stuff);
            top = bottom;
        }
",,
implicit_predicate,clean.c,534,+,-,"if (is_range){
    bottom = atoi((*ptr)->buf);
    if (!*(strchr((*ptr)->buf, '-') + 1))
        top = menu_stuff->nr;
    else
        top = atoi(strchr((*ptr)->buf, '-') + 1);
}else
    if (!strcmp((*ptr)->buf, ""*"")){
        bottom = 1;
        top = menu_stuff->nr;
    }else{
        bottom = find_unique((*ptr)->buf, menu_stuff);
        top = bottom;
    }
",,
implicit_predicate,clean.c,603,+,-,"if (opts->flags & MENU_OPTS_LIST_ONLY)
    break;
",,
implicit_predicate,clean.c,610,+,+,"opts->flags & MENU_OPTS_SINGLETON ? ""> "" : "">> """,11,"			       opts->flags & MENU_OPTS_SINGLETON ? ""> "" : "">> "","
implicit_predicate,clean.c,634,+,-,"if (opts->flags & MENU_OPTS_SINGLETON){
    if (nr)
        break;
}else
    if (opts->flags & MENU_OPTS_IMMEDIATE){
        break;
    }
",,
implicit_predicate,clean.c,635,+,-,"if (nr)
    break;
",,
implicit_predicate,clean.c,637,+,-,"if (opts->flags & MENU_OPTS_IMMEDIATE){
    break;
}
",,
implicit_predicate,clean.c,642,+,-,"if (eof){
    result = xmalloc(sizeof (int));
    *result = EOF;
}else{
    int j = 0;
    if (!nr){
        for (i = 0;i < stuff->nr;i++)
            nr += chosen[i];
    }
    CALLOC_ARRAY(result, st_add(nr, 1));
    for (i = 0;i < stuff->nr && j < nr;i++){
        if (chosen[i])
            result[j++] = i;
    }
    result[j] = EOF;
}
",,
implicit_predicate,clean.c,659,+,-,"if (chosen[i])
    result[j++] = i;
",,
implicit_predicate,clean.c,688,+,-,"if (changed)
    pretty_print_dels();
",,
implicit_predicate,clean.c,722,+,-,"if (changed){
    string_list_remove_empty_items(&del_list, 0);
}else{
    clean_print_color(CLEAN_COLOR_ERROR);
    printf_ln(_(""WARNING: Cannot find items matched by: %s""), confirm.buf);
    clean_print_color(CLEAN_COLOR_RESET);
}
",,
implicit_predicate,clean.c,800,+,-,"if (changed)
    string_list_remove_empty_items(&del_list, 0);
",,
implicit_predicate,clean.c,966,+,-,"if (ignored_only)
    dir.flags |= DIR_SHOW_IGNORED;
",,
implicit_predicate,clean.c,969,+,-,"if (argc){
    remove_directories = 1;
}
",,
implicit_predicate,clean.c,1067,+,-,"if (remove_dirs(&abs_path, prefix, rm_flags, dry_run, quiet, &gone))
    errors++;
",,
implicit_predicate,clean.c,1071,+,+,dry_run ? _(msg_would_remove) : _(msg_remove),12,"				printf(dry_run ? _(msg_would_remove) : _(msg_remove), qname);"
implicit_predicate,clean.c,1074,+,+,dry_run ? 0 : unlink(abs_path.buf),10,			res = dry_run ? 0 : unlink(abs_path.buf);
implicit_predicate,clean.c,1075,+,-,"if (res){
    int saved_errno = errno;
    qname = quote_path(item->string, NULL, &buf, 0);
    errno = saved_errno;
    warning_errno(_(msg_warn_remove_failed), qname);
    errors++;
}else
    if (!quiet){
        qname = quote_path(item->string, NULL, &buf, 0);
        printf(dry_run ? _(msg_would_remove) : _(msg_remove), qname);
    }
",,
implicit_predicate,clean.c,1083,+,+,dry_run ? _(msg_would_remove) : _(msg_remove),12,"				printf(dry_run ? _(msg_would_remove) : _(msg_remove), qname);"
implicit_predicate,clone.c,95,+,-,"if (unset)
    string_list_clear((struct string_list*)opt->value, 0);
else
    if (arg)
        string_list_append((struct string_list*)opt->value, arg);
    else
        string_list_append((struct string_list*)opt->value, (const char*)opt->defval);
",,
implicit_predicate,clone.c,233,-,+,,10,	canon = raw ? absolute_pathdup(raw) : NULL;
implicit_predicate,clone.c,245,+,-,"if (*required)
    die(""%s"", err.buf);
else
    fprintf(stderr, _(""info: Could not add alternate for '%s': %s\n""), item->string, err.buf);
",,
implicit_predicate,clone.c,429,+,-,"if (option_shared){
    struct strbuf alt = STRBUF_INIT;
    get_common_dir(&alt, src_repo);
    strbuf_addstr(&alt, ""/objects"");
    add_to_alternates_file(alt.buf);
    strbuf_release(&alt);
}else{
    struct strbuf src = STRBUF_INIT;
    struct strbuf dest = STRBUF_INIT;
    get_common_dir(&src, src_repo);
    get_common_dir(&dest, dest_repo);
    strbuf_addstr(&src, ""/objects"");
    strbuf_addstr(&dest, ""/objects"");
    copy_or_link_directory(&src, &dest, src_repo);
    strbuf_release(&src);
    strbuf_release(&dest);
}
",,
implicit_predicate,clone.c,525,-,+,,22,	struct ref **tail = head ? &head->next : &local_refs;
implicit_predicate,clone.c,527,+,-,"if (option_single_branch){
    struct ref* remote_head = NULL;
    if (!option_branch)
        remote_head = guess_remote_head(head, refs, 0);
    else{
        local_refs = NULL;
        tail = &local_refs;
        remote_head = copy_ref(find_remote_branch(refs, option_branch));
    }
    if (!remote_head && option_branch)
        warning(_(""Could not find remote branch %s to clone.""), option_branch);
    else{
        int i;
        for (i = 0;i < refspec->nr;i++)
            get_fetch_map(remote_head, &refspec->items[i], &tail, 0);
        get_fetch_map(remote_head, tag_refspec, &tail, 0);
    }
    free_refs(remote_head);
}else{
    int i;
    for (i = 0;i < refspec->nr;i++)
        get_fetch_map(refs, &refspec->items[i], &tail, 0);
}
",,
implicit_predicate,clone.c,636,+,-,"if (check_connectivity){
    struct check_connected_options opt = CHECK_CONNECTED_INIT;
    opt.transport = transport;
    opt.progress = transport->progress;
    if (check_connected(iterate_ref_map, &rm, &opt))
        die(_(""remote did not send all necessary objects""));
}
",,
implicit_predicate,clone.c,737,+,-,"if (option_no_checkout)
    return 0;
",,
implicit_predicate,clone.c,800,+,-,"if (submodule_progress)
    strvec_push(&cmd.args, ""--progress"");
",,
implicit_predicate,clone.c,806,+,-,"if (option_remote_submodules){
    strvec_push(&cmd.args, ""--remote"");
    strvec_push(&cmd.args, ""--no-fetch"");
}
",,
implicit_predicate,clone.c,816,+,+,"option_single_branch ? ""--single-branch"" : ""--no-single-branch""",27,"			strvec_push(&cmd.args, option_single_branch ?
					       ""--single-branch"" :
					       ""--no-single-branch"");"
implicit_predicate,clone.c,854,+,-,"if (apply_failed)
    return apply_failed;
",,
implicit_predicate,clone.c,858,-,+,,12,"					      value ? value : ""true"","
implicit_predicate,clone.c,913,+,-,"if (option_mirror){
    strbuf_addf(&key, ""remote.%s.mirror"", remote_name);
    git_config_set(key.buf, ""true"");
    strbuf_reset(&key);
}
",,
implicit_predicate,clone.c,1006,+,+,deepen ? 1 : 0,26,		option_single_branch = deepen ? 1 : 0;
implicit_predicate,clone.c,1014,+,-,"if (option_mirror)
    option_bare = 1;
",,
implicit_predicate,clone.c,1017,+,-,"if (option_bare){
    if (real_git_dir)
        die(_(""options '%s' and '%s' cannot be used together""), ""--bare"", ""--separate-git-dir"");

    option_no_checkout = 1;
}
",,
implicit_predicate,clone.c,1064,-,+,,7,		    display_repo ? display_repo : repo);
implicit_predicate,clone.c,1067,+,-,"if (option_bare)
    work_tree = NULL;
else{
    work_tree = getenv(""GIT_WORK_TREE"");
    if (work_tree && path_exists(work_tree))
        die(_(""working tree '%s' already exists.""), work_tree);
}
",,
implicit_predicate,clone.c,1089,+,-,"if (dest_exists)
    junk_work_tree_flags |= REMOVE_DIR_KEEP_TOPLEVEL;
else
    if (mkdir(work_tree, 0777))
        die_errno(_(""could not create work tree dir '%s'""), work_tree);
",,
implicit_predicate,clone.c,1099,+,-,"if (real_dest_exists)
    junk_git_dir_flags |= REMOVE_DIR_KEEP_TOPLEVEL;
",,
implicit_predicate,clone.c,1103,+,-,"if (dest_exists)
    junk_git_dir_flags |= REMOVE_DIR_KEEP_TOPLEVEL;
",,
implicit_predicate,clone.c,1111,+,-,"if (option_bare)
    fprintf(stderr, _(""Cloning into bare repository '%s'...\n""), dir);
else
    fprintf(stderr, _(""Cloning into '%s'...\n""), dir);
",,
implicit_predicate,clone.c,1274,+,-,"if (option_bare){
    if (option_mirror)
        src_ref_prefix = ""refs/"";

    strbuf_addstr(&branch_top, src_ref_prefix);
    git_config_set(""core.bare"", ""true"");
}else{
    strbuf_addf(&branch_top, ""refs/remotes/%s/"", remote_name);
}
",,
implicit_predicate,clone.c,1275,+,-,"if (option_mirror)
    src_ref_prefix = ""refs/"";
",,
implicit_predicate,clone.c,1288,+,-,"if (option_no_tags){
    strbuf_addf(&key, ""remote.%s.tagOpt"", remote_name);
    git_config_set(key.buf, ""--no-tags"");
    strbuf_reset(&key);
}
",,
implicit_predicate,clone.c,1304,+,-,"if (is_local){
    if (option_depth)
        warning(_(""--depth is ignored in local clones; use file:// instead.""));

    if (option_since)
        warning(_(""--shallow-since is ignored in local clones; use file:// instead.""));

    if (option_not.nr)
        warning(_(""--shallow-exclude is ignored in local clones; use file:// instead.""));

    if (filter_options.choice)
        warning(_(""--filter is ignored in local clones; use file:// instead.""));

    if (!access(mkpath(""%s/shallow"", path), F_OK)){
        if (reject_shallow)
            die(_(""source repository is shallow, reject to clone.""));

        if (option_local > 0)
            warning(_(""source repository is shallow, ignoring --local""));

        is_local = 0;
    }
}
",,
implicit_predicate,clone.c,1314,+,-,"if (reject_shallow)
    die(_(""source repository is shallow, reject to clone.""));
",,
implicit_predicate,clone.c,1324,-,+,,36,"	transport = transport_get(remote, path ? path : remote->url[0]);"
implicit_predicate,clone.c,1329,+,-,"if (is_bundle){
    struct bundle_header header = BUNDLE_HEADER_INIT;
    int fd = read_bundle_header(path, &header);
    int has_filter = header.filter.choice != LOFC_DISABLED;
    if (fd > 0)
        close(fd);

    bundle_header_release(&header);
    if (has_filter)
        die(_(""cannot clone from filtered bundle""));
}
",,
implicit_predicate,clone.c,1337,+,-,"if (has_filter)
    die(_(""cannot clone from filtered bundle""));
",,
implicit_predicate,clone.c,1343,+,-,"if (reject_shallow)
    transport_set_option(transport, TRANS_OPT_REJECT_SHALLOW, ""1"");
",,
implicit_predicate,clone.c,1354,+,-,"if (option_single_branch)
    transport_set_option(transport, TRANS_OPT_FOLLOWTAGS, ""1"");
",,
implicit_predicate,clone.c,1409,+,-,"if (has_heuristic)
    git_config_set_gently(""fetch.bundleuri"", bundle_uri);
",,
implicit_predicate,clone.c,1507,+,-,"if (is_local)
    clone_local(path, git_dir);
else
    if (mapped_refs && complete_refs_before_fetch){
        if (transport_fetch_refs(transport, mapped_refs))
            die(_(""remote transport reported error""));
    }
",,
implicit_predicate,clone.c,1531,+,-,"if (option_dissociate){
    close_object_store(the_repository->objects);
    dissociate_from_references();
}
",,
implicit_predicate,color.c,74,+,-,"if (val & ~0xff)
    return -1;
",,
implicit_predicate,color.c,95,+,-,"if (match_word(name, len, ""default"")){
    out->type = COLOR_ANSI;
    out->value = 9 + color_offset;
    return 0;
}
",,
implicit_predicate,color.c,122,+,-,"if (match_word(name, len, color_names[i])){
    out->type = COLOR_ANSI;
    out->value = i + color_offset;
    return 0;
}
",,
implicit_predicate,color.c,137,+,-,"if (match_word(name, len, ""normal"")){
    out->type = COLOR_NORMAL;
    return 0;
}
",,
implicit_predicate,color.c,219,+,+,negate ? attrs[i].neg : attrs[i].val,11,			return negate ? attrs[i].neg : attrs[i].val;
implicit_predicate,color.c,238,+,-,"if (background)
    offset = COLOR_BACKGROUND_OFFSET;
",,
implicit_predicate,color.c,302,+,-,"if (match_word(word, wordlen, ""reset"")){
    has_reset = 1;
    continue;
}
",,
implicit_predicate,color.c,336,+,-,"OUT('\033');
",,
implicit_predicate,color.c,337,+,-,"OUT('[');
",,
implicit_predicate,color.c,339,+,-,"if (has_reset)
    sep++;
",,
implicit_predicate,color.c,342,+,-,"for (i = 0;attr;i++){
    unsigned bit = (1 << i);
    if (!(attr & bit))
        continue;

    attr &= ~bit;
    if (sep++)
        OUT(';');

    dst += xsnprintf(dst, end - dst, ""%d"", i);
}
",,
implicit_predicate,color.c,347,+,-,"if (sep++)
    OUT(';');
",,
implicit_predicate,color.c,348,+,-,"OUT(';');
",,
implicit_predicate,color.c,352,+,-,"if (sep++)
    OUT(';');
",,
implicit_predicate,color.c,353,+,-,"OUT(';');
",,
implicit_predicate,color.c,357,+,-,"if (sep++)
    OUT(';');
",,
implicit_predicate,color.c,358,+,-,"OUT(';');
",,
implicit_predicate,color.c,361,+,-,"OUT('m');
",,
implicit_predicate,color.c,363,+,-,"OUT(0);
",,
implicit_predicate,column.c,50,+,-,"if (argc)
    usage_with_options(builtin_column_usage, options);
",,
implicit_predicate,column.c,140,+,+,newline ? data->opts.nl : empty_cell + len,9,	       newline ? data->opts.nl : empty_cell + len);
implicit_predicate,column.c,171,+,-,"if (display_cell(&data, initial_width, empty_cell, x, y))
    break;
",,
implicit_predicate,column.c,194,-,+,,18,	nopts.padding = opts ? opts->padding : 1;
implicit_predicate,column.c,274,+,-,"if (opts[i].mask)
    *colopts = (*colopts & ~opts[i].mask) | opts[i].value;
else{
    if (set)
        *colopts |= opts[i].value;
    else
        *colopts &= ~opts[i].value;
}
",,
implicit_predicate,column.c,277,+,-,"if (set)
    *colopts |= opts[i].value;
else
    *colopts &= ~opts[i].value;
",,
implicit_predicate,column.c,295,+,-,"if (len){
    if (parse_option(value, len, colopts, &group_set))
        return -1;

    value += len;
}
",,
implicit_predicate,column.c,296,+,-,"if (parse_option(value, len, colopts, &group_set))
    return -1;
",,
implicit_predicate,column.c,321,+,-,"if (parse_config(colopts, value))
    return error(""invalid column.%s mode %s"", key, value);
",,
implicit_predicate,column.c,349,+,-,"if (unset)
    return 0;
",,
implicit_predicate,combine-diff.c,233,+,-,"if (match_string_spaces(baseend->line, baseend->len, newend->line, newend->len, flags)){
    lcs[i][j] = lcs[i - 1][j - 1] + 1;
    directions[i][j] = MATCH;
}else
    if (lcs[i][j - 1] >= lcs[i - 1][j]){
        lcs[i][j] = lcs[i][j - 1];
        directions[i][j] = NEW;
    }else{
        lcs[i][j] = lcs[i - 1][j];
        directions[i][j] = BASE;
    }
",,
implicit_predicate,combine-diff.c,445,+,-,"if (result_deleted)
    return;
",,
implicit_predicate,combine-diff.c,490,+,-,"if (ll->parent_map & nmask)
    p_lno++;
",,
implicit_predicate,combine-diff.c,542,+,+,"if (look_for_uninteresting ? !(sline[i].flag & mark) : (sline[i].flag & mark))
    return i;
else
    i++;
",7,"		if (look_for_uninteresting
		    ? !(sline[i].flag & mark)
		    : (sline[i].flag & mark))"
implicit_predicate,combine-diff.c,625,+,-,"if (interesting(&sline[i], all_mask))
    sline[i].flag |= mark;
else
    sline[i].flag &= ~mark;
",,
implicit_predicate,combine-diff.c,659,+,-,"if (sline[la].flag & mark){
    contin = 1;
    break;
}
",,
implicit_predicate,combine-diff.c,695,+,-,"if (this_diff){
    if (!same_diff)
        same_diff = this_diff;
    else
        if (same_diff != this_diff){
            has_interesting = 1;
            break;
        }
}
",,
implicit_predicate,combine-diff.c,758,+,+,"saw_cr_at_eol ? ""\r"" : """"",9,"	       saw_cr_at_eol ? ""\r"" : """");"
implicit_predicate,combine-diff.c,776,+,-,"if (result_deleted)
    return;
",,
implicit_predicate,combine-diff.c,779,+,-,"while (1){
    unsigned long hunk_end;
    unsigned long rlines;
    const char* hunk_comment = NULL;
    unsigned long null_context = 0;
    while (lno <= cnt && !(sline[lno].flag & mark)){
        if (hunk_comment_line(sline[lno].bol))
            hunk_comment = sline[lno].bol;

        lno++;
    }
    if (cnt < lno)
        break;
    else{
        for (hunk_end = lno + 1;hunk_end <= cnt;hunk_end++)
            if (!(sline[hunk_end].flag & mark))
                break;
    }
    rlines = hunk_end - lno;
    if (cnt < hunk_end)
        rlines--;

    if (!context){
        unsigned long j;
        for (j = lno;j < hunk_end;j++)
            if (!(sline[j].flag & (mark - 1)))
                null_context++;
        rlines -= null_context;
    }
    printf(""%s%s"", line_prefix, c_frag);
    for (i = 0;i <= num_parent;i++)
        putchar(combine_marker);
    for (i = 0;i < num_parent;i++)
        show_parent_lno(sline, lno, hunk_end, i, null_context);
    printf("" +%lu,%lu "", lno + 1, rlines);
    for (i = 0;i <= num_parent;i++)
        putchar(combine_marker);
    if (hunk_comment){
        int comment_end = 0;
        for (i = 0;i < 40;i++){
            int ch = hunk_comment[i] & 0xff;
            if (!ch || ch == '\n')
                break;

            if (!isspace(ch))
                comment_end = i;
        }
        if (comment_end)
            printf(""%s%s %s%s"", c_reset, c_context, c_reset, c_func);

        for (i = 0;i < comment_end;i++)
            putchar(hunk_comment[i]);
    }
    printf(""%s\n"", c_reset);
    while (lno < hunk_end){
        struct lline* ll;
        int j;
        unsigned long p_mask;
        struct sline* sl = &sline[lno++];
        ll = (sl->flag & no_pre_delete) ? NULL : sl->lost;
        while (ll){
            printf(""%s%s"", line_prefix, c_old);
            for (j = 0;j < num_parent;j++){
                if (ll->parent_map & (1UL << j))
                    putchar('-');
                else
                    putchar(' ');
            }
            show_line_to_eol(ll->line, -1, c_reset);
            ll = ll->next;
        }
        if (cnt < lno)
            break;

        p_mask = 1;
        fputs(line_prefix, stdout);
        if (!(sl->flag & (mark - 1))){
            if (!context)
                continue;

            fputs(c_context, stdout);
        }else
            fputs(c_new, stdout);

        for (j = 0;j < num_parent;j++){
            if (p_mask & sl->flag)
                putchar('+');
            else
                putchar(' ');

            p_mask <<= 1;
        }
        show_line_to_eol(sl->bol, sl->len, c_reset);
    }
}
",,
implicit_predicate,combine-diff.c,786,+,-,"if (hunk_comment_line(sline[lno].bol))
    hunk_comment = sline[lno].bol;
",,
implicit_predicate,combine-diff.c,834,+,-,"if (comment_end)
    printf(""%s%s %s%s"", c_reset, c_context, c_reset, c_func);
",,
implicit_predicate,combine-diff.c,848,+,+,(sl->flag & no_pre_delete) ? NULL : sl->lost,9,			ll = (sl->flag & no_pre_delete) ? NULL : sl->lost;
implicit_predicate,combine-diff.c,852,+,-,"if (ll->parent_map & (1UL << j))
    putchar('-');
else
    putchar(' ');
",,
implicit_predicate,combine-diff.c,876,+,-,"if (p_mask & sl->flag)
    putchar('+');
else
    putchar(' ');
",,
implicit_predicate,combine-diff.c,902,+,-,"if (ll->parent_map & jmask)
    ll->parent_map |= imask;
",,
implicit_predicate,combine-diff.c,906,+,-,"if (sline->flag & jmask)
    sline->flag |= imask;
",,
implicit_predicate,combine-diff.c,939,-,+,,15,	int abbrev = opt->flags.full_index ? the_hash_algo->hexsz : DEFAULT_ABBREV;
implicit_predicate,combine-diff.c,940,-,+,,25,"	const char *a_prefix = opt->a_prefix ? opt->a_prefix : ""a/"";"
implicit_predicate,combine-diff.c,941,-,+,,25,"	const char *b_prefix = opt->b_prefix ? opt->b_prefix : ""b/"";"
implicit_predicate,combine-diff.c,953,+,+,"dense ? ""diff --cc "" : ""diff --combined """,19,"	dump_quoted_path(dense ? ""diff --cc "" : ""diff --combined "","
implicit_predicate,combine-diff.c,959,+,+,"i ? "","" : """"",18,"		printf(""%s%s"", i ? "","" : """", abb);"
implicit_predicate,combine-diff.c,964,+,-,"if (mode_differs){
    deleted = !elem->mode;
    added = !deleted;
    for (i = 0;added && i < num_parent;i++)
        if (elem->parent[i].status != DIFF_STATUS_ADDED)
            added = 0;
    if (added)
        printf(""%s%snew file mode %06o"", line_prefix, c_meta, elem->mode);
    else{
        if (deleted)
            printf(""%s%sdeleted file "", line_prefix, c_meta);

        printf(""mode "");
        for (i = 0;i < num_parent;i++){
            printf(""%s%06o"", i ? "","" : """", elem->parent[i].mode);
        }
        if (elem->mode)
            printf(""..%06o"", elem->mode);
    }
    printf(""%s\n"", c_reset);
}
",,
implicit_predicate,combine-diff.c,973,+,-,"if (added)
    printf(""%s%snew file mode %06o"", line_prefix, c_meta, elem->mode);
else{
    if (deleted)
        printf(""%s%sdeleted file "", line_prefix, c_meta);

    printf(""mode "");
    for (i = 0;i < num_parent;i++){
        printf(""%s%06o"", i ? "","" : """", elem->parent[i].mode);
    }
    if (elem->mode)
        printf(""..%06o"", elem->mode);
}
",,
implicit_predicate,combine-diff.c,977,+,-,"if (deleted)
    printf(""%s%sdeleted file "", line_prefix, c_meta);
",,
implicit_predicate,combine-diff.c,982,+,+,"i ? "","" : """"",22,"				printf(""%s%06o"", i ? "","" : """","
implicit_predicate,combine-diff.c,996,-,+,,17,"			char *path = filename_changed(elem->parent[i].status)
				? elem->parent[i].path.buf : elem->path;"
implicit_predicate,combine-diff.c,1006,+,-,"if (added)
    dump_quoted_path(""--- "", """", ""/dev/null"", line_prefix, c_meta, c_reset);
else
    dump_quoted_path(""--- "", a_prefix, elem->path, line_prefix, c_meta, c_reset);
",,
implicit_predicate,combine-diff.c,1013,+,-,"if (deleted)
    dump_quoted_path(""+++ "", """", ""/dev/null"", line_prefix, c_meta, c_reset);
else
    dump_quoted_path(""+++ "", b_prefix, elem->path, line_prefix, c_meta, c_reset);
",,
implicit_predicate,combine-diff.c,1106,+,-,"if (is_file){
    struct strbuf buf = STRBUF_INIT;
    if (convert_to_git(rev->diffopt.repo->index, elem->path, result, len, &buf, global_conv_flags_eol)){
        free(result);
        result = strbuf_detach(&buf, &len);
        result_size = len;
    }
}
",,
implicit_predicate,combine-diff.c,1107,+,-,"if (is_file){
    struct strbuf buf = STRBUF_INIT;
    if (convert_to_git(rev->diffopt.repo->index, elem->path, result, len, &buf, global_conv_flags_eol)){
        free(result);
        result = strbuf_detach(&buf, &len);
        result_size = len;
    }
}
",,
implicit_predicate,combine-diff.c,1154,+,-,"if (is_binary){
    show_combined_header(elem, num_parent, rev, line_prefix, mode_differs, 0);
    printf(""Binary files differ\n"");
    free(result);
    return;
}
",,
implicit_predicate,combine-diff.c,1155,+,-,"if (is_binary){
    show_combined_header(elem, num_parent, rev, line_prefix, mode_differs, 0);
    printf(""Binary files differ\n"");
    free(result);
    return;
}
",,
implicit_predicate,combine-diff.c,1520,+,-,"if (show_log_first){
    show_log(rev);
    if (rev->verbose_header && opt->output_format && opt->output_format != DIFF_FORMAT_NO_OUTPUT && !commit_format_is_empty(rev->commit_format))
        printf(""%s%c"", diff_line_prefix(opt), opt->line_termination);
}
",,
implicit_predicate,combine-diff.c,1521,+,-,"if (show_log_first){
    show_log(rev);
    if (rev->verbose_header && opt->output_format && opt->output_format != DIFF_FORMAT_NO_OUTPUT && !commit_format_is_empty(rev->commit_format))
        printf(""%s%c"", diff_line_prefix(opt), opt->line_termination);
}
",,
implicit_predicate,combine-diff.c,1561,+,-,"if (need_generic_pathscan){
    paths = find_paths_generic(oid, parents, &diffopts, rev->combined_all_paths);
}else{
    int stat_opt;
    paths = find_paths_multitree(oid, parents, &diffopts);
    if (opt->pickaxe_opts & DIFF_PICKAXE_KIND_OBJFIND)
        paths = combined_objfind(opt, paths, num_parent);

    stat_opt = opt->output_format & STAT_FORMAT_MASK;
    if (stat_opt){
        diffopts.output_format = stat_opt;
        diff_tree_oid(&parents->oid[0], oid, """", &diffopts);
        diffcore_std(&diffopts);
        if (opt->orderfile)
            diffcore_order(opt->orderfile);

        diff_flush(&diffopts);
    }
}
",,
implicit_predicate,combine-diff.c,1562,+,-,"if (need_generic_pathscan){
    paths = find_paths_generic(oid, parents, &diffopts, rev->combined_all_paths);
}else{
    int stat_opt;
    paths = find_paths_multitree(oid, parents, &diffopts);
    if (opt->pickaxe_opts & DIFF_PICKAXE_KIND_OBJFIND)
        paths = combined_objfind(opt, paths, num_parent);

    stat_opt = opt->output_format & STAT_FORMAT_MASK;
    if (stat_opt){
        diffopts.output_format = stat_opt;
        diff_tree_oid(&parents->oid[0], oid, """", &diffopts);
        diffcore_std(&diffopts);
        if (opt->orderfile)
            diffcore_order(opt->orderfile);

        diff_flush(&diffopts);
    }
}
",,
implicit_predicate,combine-diff.c,1582,+,-,"if (stat_opt){
    diffopts.output_format = stat_opt;
    diff_tree_oid(&parents->oid[0], oid, """", &diffopts);
    diffcore_std(&diffopts);
    if (opt->orderfile)
        diffcore_order(opt->orderfile);

    diff_flush(&diffopts);
}
",,
implicit_predicate,combine-diff.c,1583,+,-,"if (stat_opt){
    diffopts.output_format = stat_opt;
    diff_tree_oid(&parents->oid[0], oid, """", &diffopts);
    diffcore_std(&diffopts);
    if (opt->orderfile)
        diffcore_order(opt->orderfile);

    diff_flush(&diffopts);
}
",,
implicit_predicate,combine-diff.c,1617,+,-,"if (num_paths){
    if (opt->output_format & (DIFF_FORMAT_RAW | DIFF_FORMAT_NAME | DIFF_FORMAT_NAME_STATUS)){
        for (p = paths;p;p = p->next)
            show_raw_diff(p, num_parent, rev);
        needsep = 1;
    }else
        if (opt->output_format & STAT_FORMAT_MASK)
            needsep = 1;
        else
            if (opt->output_format & DIFF_FORMAT_CALLBACK)
                handle_combined_callback(opt, paths, num_parent, num_paths);

    if (opt->output_format & DIFF_FORMAT_PATCH){
        if (needsep)
            printf(""%s%c"", diff_line_prefix(opt), opt->line_termination);

        for (p = paths;p;p = p->next)
            show_patch_diff(p, num_parent, 0, rev);
    }
}
",,
implicit_predicate,combine-diff.c,1618,+,-,"if (num_paths){
    if (opt->output_format & (DIFF_FORMAT_RAW | DIFF_FORMAT_NAME | DIFF_FORMAT_NAME_STATUS)){
        for (p = paths;p;p = p->next)
            show_raw_diff(p, num_parent, rev);
        needsep = 1;
    }else
        if (opt->output_format & STAT_FORMAT_MASK)
            needsep = 1;
        else
            if (opt->output_format & DIFF_FORMAT_CALLBACK)
                handle_combined_callback(opt, paths, num_parent, num_paths);

    if (opt->output_format & DIFF_FORMAT_PATCH){
        if (needsep)
            printf(""%s%c"", diff_line_prefix(opt), opt->line_termination);

        for (p = paths;p;p = p->next)
            show_patch_diff(p, num_parent, 0, rev);
    }
}
",,
implicit_predicate,combine-diff.c,1631,+,-,"if (needsep)
    printf(""%s%c"", diff_line_prefix(opt), opt->line_termination);
",,
implicit_predicate,combine-diff.c,1632,+,-,"if (needsep)
    printf(""%s%c"", diff_line_prefix(opt), opt->line_termination);
",,
implicit_predicate,commit-graph.c,94,+,-,"if (argc)
    usage_with_options(builtin_commit_graph_verify_usage, options);
",,
implicit_predicate,commit-graph.c,99,+,-,"if (opts.shallow)
    flags |= COMMIT_GRAPH_VERIFY_SHALLOW;
",,
implicit_predicate,commit-graph.c,101,+,-,"if (opts.progress)
    flags |= COMMIT_GRAPH_WRITE_PROGRESS;
",,
implicit_predicate,commit-graph.c,116,-,+,,9,	return data ? data->graph_pos : COMMIT_NOT_FROM_GRAPH;
implicit_predicate,commit-graph.c,134,+,-,"if (incomplete_chain){
    error(""one or more commit-graph chain files could not be loaded"");
    ret |= 1;
}
",,
implicit_predicate,commit-graph.c,193,+,-,"if (unset)
    *to = -1;
else{
    const char* s;
    *to = strtol(arg, (char**)&s, 10);
    if (*s)
        return error(_(""option `%s' expects a numerical value""), ""max-new-filters"");
}
",,
implicit_predicate,commit-graph.c,272,+,-,"if (argc)
    usage_with_options(builtin_commit_graph_write_usage, options);
",,
implicit_predicate,commit-graph.c,279,+,-,"if (opts.append)
    flags |= COMMIT_GRAPH_WRITE_APPEND;
",,
implicit_predicate,commit-graph.c,281,+,-,"if (opts.split)
    flags |= COMMIT_GRAPH_WRITE_SPLIT;
",,
implicit_predicate,commit-graph.c,283,+,-,"if (opts.progress)
    flags |= COMMIT_GRAPH_WRITE_PROGRESS;
",,
implicit_predicate,commit-graph.c,293,+,-,"if (opts.reachable){
    if (write_commit_graph_reachable(odb, flags, &write_opts))
        result = 1;

    goto cleanup;
}
",,
implicit_predicate,commit-graph.c,299,+,-,"if (opts.stdin_packs){
    while (strbuf_getline(&buf, stdin) != EOF)
        string_list_append_nodup(&pack_indexes, strbuf_detach(&buf, NULL));
}else
    if (opts.stdin_commits){
        oidset_init(&commits, 0);
        if (opts.progress)
            progress = start_delayed_progress(_(""Collecting commits from input""), 0);

        while (strbuf_getline(&buf, stdin) != EOF){
            if (read_one_commit(&commits, progress, buf.buf)){
                result = 1;
                goto cleanup;
            }
        }
        stop_progress(&progress);
    }
",,
implicit_predicate,commit-graph.c,303,+,-,"if (opts.stdin_commits){
    oidset_init(&commits, 0);
    if (opts.progress)
        progress = start_delayed_progress(_(""Collecting commits from input""), 0);

    while (strbuf_getline(&buf, stdin) != EOF){
        if (read_one_commit(&commits, progress, buf.buf)){
            result = 1;
            goto cleanup;
        }
    }
    stop_progress(&progress);
}
",,
implicit_predicate,commit-graph.c,305,+,-,"if (opts.progress)
    progress = start_delayed_progress(_(""Collecting commits from input""), 0);
",,
implicit_predicate,commit-graph.c,320,+,+,opts.stdin_packs ? &pack_indexes : NULL,11,"			       opts.stdin_packs ? &pack_indexes : NULL,"
implicit_predicate,commit-graph.c,321,+,+,opts.stdin_commits ? &commits : NULL,11,"			       opts.stdin_commits ? &commits : NULL,"
implicit_predicate,commit-graph.c,535,+,-,"if (read_generation_data)
    return 1;
",,
implicit_predicate,commit-graph.c,563,+,-,"while (n){
    n--;
    if (!cur_g || !oideq(&oids[n], &cur_g->oid) || !hasheq(oids[n].hash, g->chunk_base_graphs + st_mult(g->hash_len, n))){
        warning(_(""commit-graph chain does not match""));
        return 0;
    }
    cur_g = cur_g->base_graph;
}
",,
implicit_predicate,commit-graph.c,651,+,-,"if (add_graph_to_chain(g, graph_chain, oids, i)){
    graph_chain = g;
    valid = 1;
}else{
    free_commit_graph(g);
}
",,
implicit_predicate,commit-graph.c,686,+,-,"if (open_commit_graph_chain(chain_file, &fd, &st)){
    int incomplete;
    g = load_commit_graph_chain_fd_st(r, fd, &st, &incomplete);
}
",,
implicit_predicate,commit-graph.c,1279,+,-,"if (edge_value & GRAPH_EXTRA_EDGES_NEEDED){
    do{
        num_extra_edges++;
        parent = parent->next;
    } while (parent);
}
",,
implicit_predicate,commit-graph.c,1410,-,+,,16,		size_t len = filter ? filter->len : 0;
implicit_predicate,commit-graph.c,1451,-,+,,16,		size_t len = filter ? filter->len : 0;
implicit_predicate,commit-graph.c,1503,-,+,,40,"	enum commit_graph_split_flags flags = ctx->opts ?
		ctx->opts->split_flags : COMMIT_GRAPH_SPLIT_UNSPECIFIED;"
implicit_predicate,commit-graph.c,1506,+,-,"if (ctx->report_progress)
    ctx->progress = start_delayed_progress(_(""Loading known commits in commit graph""), ctx->oids.nr);
",,
implicit_predicate,commit-graph.c,1523,+,-,"if (ctx->report_progress)
    ctx->progress = start_delayed_progress(_(""Expanding reachable commits in commit graph""), 0);
",,
implicit_predicate,commit-graph.c,1533,+,-,"if (ctx->split){
    if ((!repo_parse_commit(ctx->r, commit) && commit_graph_position(commit) == COMMIT_NOT_FROM_GRAPH) || flags == COMMIT_GRAPH_SPLIT_REPLACE)
        add_missing_parents(ctx, commit);
}else
    if (!repo_parse_commit_no_graph(ctx->r, commit))
        add_missing_parents(ctx, commit);
",,
implicit_predicate,commit-graph.c,1543,+,-,"if (ctx->report_progress)
    ctx->progress = start_delayed_progress(_(""Clearing commit marks in commit graph""), ctx->oids.nr);
",,
implicit_predicate,commit-graph.c,1626,+,-,"if (all_parents_computed){
    pop_commit(&list);
    gen = compute_generation_from_max(current, max_gen, generation_version);
    info->set_generation(current, gen, info->data);
}
",,
implicit_predicate,commit-graph.c,1659,+,-,"if (ctx->report_progress)
    info.progress = ctx->progress = start_delayed_progress(_(""Computing commit graph topological levels""), ctx->commits.nr);
",,
implicit_predicate,commit-graph.c,1693,+,-,"if (ctx->report_progress)
    info.progress = ctx->progress = start_delayed_progress(_(""Computing commit graph generation numbers""), ctx->commits.nr);
",,
implicit_predicate,commit-graph.c,1768,+,-,"if (ctx->report_progress)
    progress = start_delayed_progress(_(""Computing commit changed paths Bloom filters""), ctx->commits.nr);
",,
implicit_predicate,commit-graph.c,1775,+,-,"if (ctx->order_by_pack)
    QSORT(sorted_commits, ctx->commits.nr, commit_pos_cmp);
else
    QSORT(sorted_commits, ctx->commits.nr, commit_gen_cmp);
",,
implicit_predicate,commit-graph.c,1800,-,+,,40,"		ctx->total_bloom_filter_data_size += filter
			? sizeof(unsigned char) * filter->len : 0;"
implicit_predicate,commit-graph.c,1871,+,-,<!!!>,,
implicit_predicate,commit-graph.c,1926,+,-,"if (ctx->report_progress)
    ctx->progress = start_delayed_progress(_(""Finding commits for commit graph among packed objects""), ctx->approx_nr_objects);
",,
implicit_predicate,commit-graph.c,1940,-,+,,40,"	enum commit_graph_split_flags flags = ctx->opts ?
		ctx->opts->split_flags : COMMIT_GRAPH_SPLIT_UNSPECIFIED;"
implicit_predicate,commit-graph.c,1944,+,-,"if (ctx->report_progress)
    ctx->progress = start_delayed_progress(_(""Finding extra edges in commit graph""), ctx->oids.nr);
",,
implicit_predicate,commit-graph.c,2013,+,-,"if (ctx->split){
    struct strbuf tmp_file = STRBUF_INIT;
    strbuf_addf(&tmp_file, ""%s/info/commit-graphs/tmp_graph_XXXXXX"", ctx->odb->path);
    ctx->graph_name = strbuf_detach(&tmp_file, NULL);
}else{
    ctx->graph_name = get_commit_graph_filename(ctx->odb);
}
",,
implicit_predicate,commit-graph.c,2031,+,-,"if (ctx->split){
    char* lock_name = get_commit_graph_chain_filename(ctx->odb);
    hold_lock_file_for_update_mode(&lk, lock_name, LOCK_DIE_ON_ERROR, 0444);
    free(lock_name);
    fd = git_mkstemp_mode(ctx->graph_name, 0444);
    if (fd < 0){
        error(_(""unable to create temporary graph layer""));
        return -1;
    }
    if (adjust_shared_perm(ctx->graph_name)){
        error(_(""unable to adjust shared permissions for '%s'""), ctx->graph_name);
        return -1;
    }
    f = hashfd(fd, ctx->graph_name);
}else{
    hold_lock_file_for_update_mode(&lk, ctx->graph_name, LOCK_DIE_ON_ERROR, 0444);
    fd = get_lock_file_fd(&lk);
    f = hashfd(fd, get_lock_file_path(&lk));
}
",,
implicit_predicate,commit-graph.c,2067,+,-,"if (ctx->write_generation_data)
    add_chunk(cf, GRAPH_CHUNKID_GENERATION_DATA, st_mult(sizeof (uint32_t), ctx->commits.nr), write_graph_chunk_generation_data);
",,
implicit_predicate,commit-graph.c,2071,+,-,"if (ctx->num_generation_data_overflows)
    add_chunk(cf, GRAPH_CHUNKID_GENERATION_DATA_OVERFLOW, st_mult(sizeof (timestamp_t), ctx->num_generation_data_overflows), write_graph_chunk_generation_data_overflow);
",,
implicit_predicate,commit-graph.c,2075,+,-,"if (ctx->num_extra_edges)
    add_chunk(cf, GRAPH_CHUNKID_EXTRAEDGES, st_mult(4, ctx->num_extra_edges), write_graph_chunk_extra_edges);
",,
implicit_predicate,commit-graph.c,2079,+,-,"if (ctx->changed_paths){
    add_chunk(cf, GRAPH_CHUNKID_BLOOMINDEXES, st_mult(sizeof (uint32_t), ctx->commits.nr), write_graph_chunk_bloom_indexes);
    add_chunk(cf, GRAPH_CHUNKID_BLOOMDATA, st_add(sizeof (uint32_t) * 3, ctx->total_bloom_filter_data_size), write_graph_chunk_bloom_data);
}
",,
implicit_predicate,commit-graph.c,2100,+,-,"if (ctx->report_progress){
    strbuf_addf(&progress_title, Q_(""Writing out commit graph in %d pass"", ""Writing out commit graph in %d passes"", get_num_chunks(cf)), get_num_chunks(cf));
    ctx->progress = start_delayed_progress(progress_title.buf, st_mult(get_num_chunks(cf), ctx->commits.nr));
}
",,
implicit_predicate,commit-graph.c,2131,+,-,"if (ctx->split){
    FILE* chainf = fdopen_lock_file(&lk, ""w"");
    char* final_graph_name;
    int result;
    close(fd);
    if (!chainf){
        error(_(""unable to open commit-graph chain file""));
        return -1;
    }
    if (ctx->base_graph_name){
        const char* dest;
        int idx = ctx->num_commit_graphs_after - 1;
        if (ctx->num_commit_graphs_after > 1)
            idx--;

        dest = ctx->commit_graph_filenames_after[idx];
        if (strcmp(ctx->base_graph_name, dest)){
            result = rename(ctx->base_graph_name, dest);
            if (result){
                error(_(""failed to rename base commit-graph file""));
                return -1;
            }
        }
    }else{
        char* graph_name = get_commit_graph_filename(ctx->odb);
        unlink(graph_name);
        free(graph_name);
    }
    free(ctx->commit_graph_hash_after[ctx->num_commit_graphs_after - 1]);
    ctx->commit_graph_hash_after[ctx->num_commit_graphs_after - 1] = xstrdup(hash_to_hex(file_hash));
    final_graph_name = get_split_graph_filename(ctx->odb, ctx->commit_graph_hash_after[ctx->num_commit_graphs_after - 1]);
    free(ctx->commit_graph_filenames_after[ctx->num_commit_graphs_after - 1]);
    ctx->commit_graph_filenames_after[ctx->num_commit_graphs_after - 1] = final_graph_name;
    result = rename(ctx->graph_name, final_graph_name);
    for (i = 0;i < ctx->num_commit_graphs_after;i++)
        fprintf(get_lock_file_fp(&lk), ""%s\n"", ctx->commit_graph_hash_after[i]);
    if (result){
        error(_(""failed to rename temporary commit-graph file""));
        return -1;
    }
}
",,
implicit_predicate,commit-graph.c,2154,+,-,"if (result){
    error(_(""failed to rename base commit-graph file""));
    return -1;
}
",,
implicit_predicate,commit-graph.c,2177,+,-,"if (result){
    error(_(""failed to rename temporary commit-graph file""));
    return -1;
}
",,
implicit_predicate,commit-graph.c,2319,+,-,"if (ctx->report_progress)
    ctx->progress = start_delayed_progress(_(""Scanning merged commits""), ctx->commits.nr);
",,
implicit_predicate,commit-graph.c,2364,+,-,"if (ctx->report_progress)
    ctx->progress = start_delayed_progress(_(""Merging commit-graph""), 0);
",,
implicit_predicate,commit-graph.c,2486,-,+,,16,	ctx->append = flags & COMMIT_GRAPH_WRITE_APPEND ? 1 : 0;
implicit_predicate,commit-graph.c,2487,-,+,,25,	ctx->report_progress = flags & COMMIT_GRAPH_WRITE_PROGRESS ? 1 : 0;
implicit_predicate,commit-graph.c,2488,-,+,,15,	ctx->split = flags & COMMIT_GRAPH_WRITE_SPLIT ? 1 : 0;
implicit_predicate,commit-graph.c,2529,+,-,"if (ctx->split){
    struct commit_graph* g = ctx->r->objects->commit_graph;
    while (g){
        ctx->num_commit_graphs_before++;
        g = g->base_graph;
    }
    if (ctx->num_commit_graphs_before){
        ALLOC_ARRAY(ctx->commit_graph_filenames_before, ctx->num_commit_graphs_before);
        i = ctx->num_commit_graphs_before;
        g = ctx->r->objects->commit_graph;
        while (g){
            ctx->commit_graph_filenames_before[--i] = xstrdup(g->filename);
            g = g->base_graph;
        }
    }
    if (ctx->opts)
        replace = ctx->opts->split_flags & COMMIT_GRAPH_SPLIT_REPLACE;
}
",,
implicit_predicate,commit-graph.c,2537,+,-,"if (ctx->num_commit_graphs_before){
    ALLOC_ARRAY(ctx->commit_graph_filenames_before, ctx->num_commit_graphs_before);
    i = ctx->num_commit_graphs_before;
    g = ctx->r->objects->commit_graph;
    while (g){
        ctx->commit_graph_filenames_before[--i] = xstrdup(g->filename);
        g = g->base_graph;
    }
}
",,
implicit_predicate,commit-graph.c,2565,+,-,"if ((res = fill_oids_from_packs(ctx, pack_indexes)))
    goto cleanup;
",,
implicit_predicate,commit-graph.c,2570,+,-,"if ((res = fill_oids_from_commits(ctx, commits)))
    goto cleanup;
",,
implicit_predicate,commit-graph.c,2592,+,-,"if (ctx->split){
    split_graph_merge_strategy(ctx);
    if (!replace)
        merge_commit_graphs(ctx);
}else
    ctx->num_commit_graphs_after = 1;
",,
implicit_predicate,commit-graph.c,2603,+,-,"if (ctx->write_generation_data)
    compute_generation_numbers(ctx);
",,
implicit_predicate,commit-graph.c,2606,+,-,"if (ctx->changed_paths)
    compute_bloom_filters(ctx);
",,
implicit_predicate,commit-graph.c,2611,+,-,"if (ctx->split)
    mark_commit_graphs(ctx);
",,
implicit_predicate,commit-graph.c,2711,+,-,"if (verify_commit_graph_error & ~VERIFY_COMMIT_GRAPH_ERROR_HASH)
    return verify_commit_graph_error;
",,
implicit_predicate,commit-reach.c,78,+,-,<!!!>,,
implicit_predicate,commit-reach.c,119,+,-,"if (ignore_missing_commits)
    return 0;
",,
implicit_predicate,commit-reach.c,230,+,-,"if (redundant[i])
    continue;
",,
implicit_predicate,commit-reach.c,435,+,-,"if (cleanup){
    clear_commit_marks(one, all_flags);
    clear_commit_marks_many(n, twos, all_flags);
}
",,
implicit_predicate,commit-reach.c,515,+,-,"if (ret)
    return ret;
",,
implicit_predicate,commit-reach.c,534,+,+,ignore_missing_commits ? 0 : -1,10,		return ignore_missing_commits ? 0 : -1;
implicit_predicate,commit-reach.c,537,+,+,ignore_missing_commits ? 0 : -1,11,			return ignore_missing_commits ? 0 : -1;
implicit_predicate,commit-reach.c,696,+,-,"if (in_commit_list(want, candidate)){
    *cached = CONTAINS_YES;
    return CONTAINS_YES;
}
",,
implicit_predicate,commit-reach.c,740,+,-,"while (contains_stack.nr){
    struct contains_stack_entry* entry = &contains_stack.contains_stack[contains_stack.nr - 1];
    struct commit* commit = entry->commit;
    struct commit_list* parents = entry->parents;
    if (!parents){
        *contains_cache_at(cache, commit) = CONTAINS_NO;
        contains_stack.nr--;
    }else
        switch (contains_test(parents->item, want, cache, cutoff)){
            case CONTAINS_YES:
                *contains_cache_at(cache, commit) = CONTAINS_YES;
                contains_stack.nr--;
                break;
            case CONTAINS_NO:
                entry->parents = parents->next;
                break;
            case CONTAINS_UNKNOWN:
                push_to_contains_stack(parents->item, &contains_stack);
                break;
        }
}
",,
implicit_predicate,commit-reach.c,884,+,+,cutoff_by_min_date ? from->item->date : 0,27,	time_t min_commit_date = cutoff_by_min_date ? from->item->date : 0;
implicit_predicate,commit-reach.c,1066,+,-,"while (queue_has_nonstale(&queue)){
    struct commit* c = prio_queue_get(&queue);
    struct commit_list* p;
    struct bitmap* bitmap_c = get_bit_array(c, width);
    for (size_t i = 0;i < counts_nr;i++){
        int reach_from_tip = !!bitmap_get(bitmap_c, counts[i].tip_index);
        int reach_from_base = !!bitmap_get(bitmap_c, counts[i].base_index);
        if (reach_from_tip ^ reach_from_base){
            if (reach_from_base)
                counts[i].behind++;
            else
                counts[i].ahead++;
        }
    }
    for (p = c->parents;p;p = p->next){
        struct bitmap* bitmap_p;
        repo_parse_commit(r, p->item);
        bitmap_p = get_bit_array(p->item, width);
        bitmap_or(bitmap_p, bitmap_c);
        if (bitmap_popcount(bitmap_p) == commits_nr)
            p->item->object.flags |= STALE;

        insert_no_dup(&queue, p->item);
    }
    free_bit_array(c);
}
",,
implicit_predicate,commit-reach.c,1075,+,-,"if (reach_from_tip ^ reach_from_base){
    if (reach_from_base)
        counts[i].behind++;
    else
        counts[i].ahead++;
}
",,
implicit_predicate,commit-reach.c,1076,+,-,"if (reach_from_base)
    counts[i].behind++;
else
    counts[i].ahead++;
",,
implicit_predicate,commit-reach.c,1217,+,-,"if (explored_all_parents)
    pop_commit(&stack);
",,
implicit_predicate,commit.c,72,-,+,,9,"	return obj ? object_as_type(obj, OBJ_COMMIT, 0) : NULL;"
implicit_predicate,commit.c,148,+,-,"if (unset)
    *value = STATUS_FORMAT_NONE;
else
    if (!arg)
        *value = STATUS_FORMAT_PORCELAIN;
    else
        if (!strcmp(arg, ""v1"") || !strcmp(arg, ""1""))
            *value = STATUS_FORMAT_PORCELAIN;
        else
            if (!strcmp(arg, ""v2"") || !strcmp(arg, ""2""))
                *value = STATUS_FORMAT_PORCELAIN_V2;
            else
                die(""unsupported porcelain version '%s'"", arg);
",,
implicit_predicate,commit.c,165,+,-,"if (unset){
    have_option_m = 0;
    strbuf_setlen(buf, 0);
}else{
    have_option_m = 1;
    if (buf->len)
        strbuf_addch(buf, '\n');

    strbuf_addstr(buf, arg);
    strbuf_complete_line(buf);
}
",,
implicit_predicate,commit.c,195,+,-,"if (ignore_dups)
    free(graft);
else{
    free(r->parsed_objects->grafts[pos]);
    r->parsed_objects->grafts[pos] = graft;
}
",,
implicit_predicate,commit.c,234,-,+,,9,		oid = graft ? &graft->oid : &dummy_oid;
implicit_predicate,commit.c,238,-,+,,10,			oid = graft ? &graft->parent[i] : &dummy_oid;
implicit_predicate,commit.c,277,+,-,"if (register_commit_graft(r, graft, 1))
    error(""duplicate graft data: %s"", buf.buf);
",,
implicit_predicate,commit.c,351,+,-,"if (is_status)
    refresh_flags |= REFRESH_UNMERGED;
",,
implicit_predicate,commit.c,358,+,-,"if (interactive)
    die(_(""options '%s' and '%s' cannot be used together""), ""--pathspec-from-file"", ""--interactive/--patch"");
",,
implicit_predicate,commit.c,361,+,-,"if (all)
    die(_(""options '%s' and '%s' cannot be used together""), ""--pathspec-from-file"", ""-a"");
",,
implicit_predicate,commit.c,370,+,-,"if (pathspec_file_nul){
    die(_(""the option '%s' requires '%s'""), ""--pathspec-file-nul"", ""--pathspec-from-file"");
}
",,
implicit_predicate,commit.c,381,+,-,"if (interactive){
    char *old_index_env = NULL, *old_repo_index_file;
    repo_hold_locked_index(the_repository, &index_lock, LOCK_DIE_ON_ERROR);
    refresh_cache_or_die(refresh_flags);
    if (write_locked_index(the_repository->index, &index_lock, 0))
        die(_(""unable to create temporary index""));

    old_repo_index_file = the_repository->index_file;
    the_repository->index_file = (char*)get_lock_file_path(&index_lock);
    old_index_env = xstrdup_or_null(getenv(INDEX_ENVIRONMENT));
    setenv(INDEX_ENVIRONMENT, the_repository->index_file, 1);
    if (interactive_add(argv, prefix, patch_interactive) != 0)
        die(_(""interactive add failed""));

    the_repository->index_file = old_repo_index_file;
    if (old_index_env && *old_index_env)
        setenv(INDEX_ENVIRONMENT, old_index_env, 1);
    else
        unsetenv (INDEX_ENVIRONMENT);

    FREE_AND_NULL(old_index_env);
    discard_index(the_repository->index);
    read_index_from(the_repository->index, get_lock_file_path(&index_lock), get_git_dir());
    if (cache_tree_update(the_repository->index, WRITE_TREE_SILENT) == 0){
        if (reopen_lock_file(&index_lock) < 0)
            die(_(""unable to write index file""));

        if (write_locked_index(the_repository->index, &index_lock, 0))
            die(_(""unable to update temporary index""));
    }else
        warning(_(""Failed to update main cache tree""));

    commit_style = COMMIT_NORMAL;
    ret = get_lock_file_path(&index_lock);
    goto out;
}
",,
implicit_predicate,commit.c,433,-,+,,9,	return tree ? &tree->object.oid : NULL;
implicit_predicate,commit.c,439,+,+,also ? prefix : NULL,38,"		add_files_to_cache(the_repository, also ? prefix : NULL,"
implicit_predicate,commit.c,543,+,-,"if (check_graph)
    load_commit_graph_info(r, item);
",,
implicit_predicate,commit.c,551,+,-,"if (amend){
    s->amend = 1;
    s->reference = ""HEAD^1"";
}
",,
implicit_predicate,commit.c,559,-,+,,18,"	s->is_initial = repo_get_oid(the_repository, s->reference, &oid) ? 1 : 0;"
implicit_predicate,commit.c,583,+,+,"quiet_on_missing ? -1 : error(_(""commit %s exists in commit-graph but not in the object database""), oid_to_hex(&item->object.oid))",11,"			return quiet_on_missing ? -1 :
				error(_(""commit %s exists in commit-graph but not in the object database""),
				      oid_to_hex(&item->object.oid));"
implicit_predicate,commit.c,586,+,-,"if (hack)
    strbuf_addch(&buf, hack);
",,
implicit_predicate,commit.c,592,+,+,"quiet_on_missing ? -1 : error(""Could not read %s"", oid_to_hex(&item->object.oid))",10,"		return quiet_on_missing ? -1 :
			error(""Could not read %s"",
			     oid_to_hex(&item->object.oid));"
implicit_predicate,commit.c,600,+,-,"if (errors)
    return -1;
",,
implicit_predicate,commit.c,620,-,+,,7,"		    item ? oid_to_hex(&item->object.oid) : ""(null)"");"
implicit_predicate,commit.c,658,+,-,"if (parse_force_date(force_date, &date_buf))
    die(_(""invalid date format: %s""), force_date);
",,
implicit_predicate,commit.c,721,-,+,,8,"	fmt = starts_with(subject, ""amend!"") ? ""%b"" : ""%B"";"
implicit_predicate,commit.c,788,+,-,"while (nr--){
    clear_commit_marks_1(&list, *commit, mark);
    commit++;
}
",,
implicit_predicate,commit.c,804,-,+,,24,	struct commit *item = top ? top->item : NULL;
implicit_predicate,commit.c,816,+,-,"if (have_option_m)
    die(_(""options '%s' and '%s:%s' cannot be used together""), ""-m"", ""--fixup"", fixup_message);
",,
implicit_predicate,commit.c,889,+,-,"if (clean_message_contents)
    strbuf_stripspace(&sb, NULL);
",,
implicit_predicate,commit.c,892,+,-,"if (signoff)
    append_signoff(&sb, ignored_log_message_bytes(sb.buf, sb.len), 0);
",,
implicit_predicate,commit.c,908,+,+,"allow_empty_message ? _(""Please enter the commit message for your changes. Lines starting\nwith '%s' will be ignored.\n"") : _(""Please enter the commit message for your changes. Lines starting\nwith '%s' will be ignored, and an empty message aborts the commit.\n"")",34,"		const char *hint_cleanup_all = allow_empty_message ?
			_(""Please enter the commit message for your changes.""
			  "" Lines starting\nwith '%s' will be ignored.\n"") :
			_(""Please enter the commit message for your changes.""
			  "" Lines starting\nwith '%s' will be ignored, and an empty""
			  "" message aborts the commit.\n"");"
implicit_predicate,commit.c,914,+,+,"allow_empty_message ? _(""Please enter the commit message for your changes. Lines starting\nwith '%s' will be kept; you may remove them yourself if you want to.\n"") : _(""Please enter the commit message for your changes. Lines starting\nwith '%s' will be kept; you may remove them yourself if you want to.\nAn empty message aborts the commit.\n"")",36,"		const char *hint_cleanup_space = allow_empty_message ?
			_(""Please enter the commit message for your changes.""
			  "" Lines starting\n""
			  ""with '%s' will be kept; you may remove them""
			  "" yourself if you want to.\n"") :
			_(""Please enter the commit message for your changes.""
			  "" Lines starting\n""
			  ""with '%s' will be kept; you may remove them""
			  "" yourself if you want to.\n""
			  ""An empty message aborts the commit.\n"");"
implicit_predicate,commit.c,947,+,-,"if (*pi)
    (*pi)++;
",,
implicit_predicate,commit.c,964,+,+,"ident_shown++ ? """" : ""\n""",5,"				ident_shown++ ? """" : ""\n"","
implicit_predicate,commit.c,968,+,-,"if (author_date_is_interesting())
    status_printf_ln(s, GIT_COLOR_NORMAL, _(""%sDate:      %s""), ident_shown++ ? """" : ""\n"", show_ident_date(&ai, DATE_MODE(NORMAL)));
",,
implicit_predicate,commit.c,972,+,+,"ident_shown++ ? """" : ""\n""",5,"				ident_shown++ ? """" : ""\n"","
implicit_predicate,commit.c,979,+,+,"ident_shown++ ? """" : ""\n""",5,"				ident_shown++ ? """" : ""\n"","
implicit_predicate,commit.c,997,+,-,"if (amend)
    parent = ""HEAD^1"";
",,
implicit_predicate,commit.c,1048,+,-,"if (amend)
    fputs(_(empty_amend_advice), stderr);
else
    if (is_from_cherry_pick(whence) || whence == FROM_REBASE_PICK){
        fputs(_(empty_cherry_pick_advice), stderr);
        if (whence == FROM_CHERRY_PICK_SINGLE)
            fputs(_(empty_cherry_pick_advice_single), stderr);
        else
            if (whence == FROM_CHERRY_PICK_MULTI)
                fputs(_(empty_cherry_pick_advice_multi), stderr);
            else
                fputs(_(empty_rebase_pick_advice), stderr);
    }
",,
implicit_predicate,commit.c,1082,+,-,"if (use_editor){
    struct strvec env = STRVEC_INIT;
    strvec_pushf(&env, ""GIT_INDEX_FILE=%s"", index_file);
    if (launch_editor(git_path_commit_editmsg(), NULL, env.v)){
        fprintf(stderr, _(""Please supply the message using either -m or -F option.\n""));
        exit(1);
    }
    strvec_clear(&env);
}
",,
implicit_predicate,commit.c,1187,-,+,,10,		next = next ? next + 1 : tail;
implicit_predicate,commit.c,1232,-,+,,10,		next = next ? next + 1 : tail;
implicit_predicate,commit.c,1264,+,-,"if (argc)
    die(_(""reword option of '%s' and path '%s' cannot be used together""), ""--fixup"", *argv);
",,
implicit_predicate,commit.c,1333,+,-,"if (patch_interactive)
    interactive = 1;
",,
implicit_predicate,commit.c,1402,+,+,committable ? 0 : 1,9,	return committable ? 0 : 1;
implicit_predicate,commit.c,1477,-,+,,10,		next = next ? next + 1 : eob;
implicit_predicate,commit.c,1540,+,-,"while (len){
    unsigned char c = *buf++;
    int bytes, bad_offset;
    unsigned int codepoint;
    unsigned int min_val, max_val;
    len--;
    offset++;
    if (c < 0x80)
        continue;

    bad_offset = offset - 1;
    bytes = 0;
    while (c & 0x40){
        c <<= 1;
        bytes++;
    }
    if (bytes < 1 || 3 < bytes)
        return bad_offset;

    if (len < bytes)
        return bad_offset;

    codepoint = (c & 0x7f) >> bytes;
    min_val = max_codepoint[bytes - 1] + 1;
    max_val = max_codepoint[bytes];
    offset += bytes;
    len -= bytes;
    do{
        codepoint <<= 6;
        codepoint |= *buf & 0x3f;
        if ((*buf++ & 0xc0) != 0x80)
            return bad_offset;
    } while (--bytes);
    if (codepoint < min_val || codepoint > max_val)
        return bad_offset;

    if ((codepoint & 0x1ff800) == 0xd800)
        return bad_offset;

    if ((codepoint & 0xfffe) == 0xfffe)
        return bad_offset;

    if (codepoint >= 0xfdd0 && codepoint <= 0xfdef)
        return bad_offset;
}
",,
implicit_predicate,commit.c,1560,+,-,"while (c & 0x40){
    c <<= 1;
    bytes++;
}
",,
implicit_predicate,commit.c,1583,-,+,,17,"	s.is_initial = repo_get_oid(the_repository, s.reference, &oid) ? 1 : 0;"
implicit_predicate,commit.c,1588,+,-,"do{
    codepoint <<= 6;
    codepoint |= *buf & 0x3f;
    if ((*buf++ & 0xc0) != 0x80)
        return bad_offset;
} while (--bytes);
",,
implicit_predicate,commit.c,1627,-,+,,17,"		sign_commit = git_config_bool(k, v) ? """" : NULL;"
implicit_predicate,commit.c,1742,+,-,"if (dry_run)
    return dry_run_commit(argv, prefix, current_head, &s);
",,
implicit_predicate,commit.c,1746,+,-,"if (convert_commit_extra_headers(extra, &compat_extra)){
    result = -1;
    free(mapped_parents);
    goto out;
}
",,
implicit_predicate,commit.c,1760,+,-,"if (amend){
    if (!reflog_msg)
        reflog_msg = ""commit (amend)"";

    parents = copy_commit_list(current_head->parents);
}else
    if (whence == FROM_MERGE){
        struct strbuf m = STRBUF_INIT;
        FILE* fp;
        int allow_fast_forward = 1;
        struct commit_list** pptr = &parents;
        if (!reflog_msg)
            reflog_msg = ""commit (merge)"";

        pptr = commit_list_append(current_head, pptr);
        fp = xfopen(git_path_merge_head(the_repository), ""r"");
        while (strbuf_getline_lf(&m, fp) != EOF){
            struct commit* parent;
            parent = get_merge_parent(m.buf);
            if (!parent)
                die(_(""Corrupt MERGE_HEAD file (%s)""), m.buf);

            pptr = commit_list_append(parent, pptr);
        }
        fclose(fp);
        strbuf_release(&m);
        if (!stat(git_path_merge_mode(the_repository), &statbuf)){
            if (strbuf_read_file(&sb, git_path_merge_mode(the_repository), 0) < 0)
                die_errno(_(""could not read MERGE_MODE""));

            if (!strcmp(sb.buf, ""no-ff""))
                allow_fast_forward = 0;
        }
        if (allow_fast_forward)
            reduce_heads_replace(&parents);
    }else{
        if (!reflog_msg)
            reflog_msg = is_from_cherry_pick(whence) ? ""commit (cherry-pick)"" : is_from_rebase(whence) ? ""commit (rebase)"" : ""commit"";

        commit_list_insert(current_head, &parents);
    }
",,
implicit_predicate,commit.c,1790,+,-,"if (allow_fast_forward)
    reduce_heads_replace(&parents);
",,
implicit_predicate,commit.c,1794,-,+,,17,"			reflog_msg = is_from_cherry_pick(whence)
					? ""commit (cherry-pick)""
					: is_from_rebase(whence)
					? ""commit (rebase)""
					: ""commit"";"
implicit_predicate,commit.c,1796,-,+,,8,"					: is_from_rebase(whence)
					? ""commit (rebase)""
					: ""commit"";"
implicit_predicate,commit.c,1836,+,-,"if (amend){
    const char* exclude_gpgsig[3] = {""gpgsig"", ""gpgsig-sha256"", NULL};
    extra = read_commit_extra_headers(current_head, exclude_gpgsig);
}else{
    struct commit_extra_header** tail = &extra;
    append_merge_tag_headers(parents, &tail);
}
",,
implicit_predicate,commit.c,1864,+,-,"if (commit_index_files())
    die(_(""repository has been updated, but unable to write\nnew index file. Check that disk is not full and quota is\nnot exceeded, and then \""git restore --staged :/\"" to recover.""));
",,
implicit_predicate,commit.c,1883,+,-,"if (author_date_is_interesting())
    flags |= SUMMARY_SHOW_AUTHOR_DATE;
",,
implicit_predicate,commit.c,1898,-,+,,10,		line = *eol ? eol + 1 : NULL;
implicit_predicate,commit.c,1951,-,+,,9,	return boc ? len - boc : len - cutoff;
implicit_predicate,config.c,143,+,-,"if (unset){
    *((int*)opt->value) = 0;
    return 0;
}
",,
implicit_predicate,config.c,187,-,+,,8,"			    kvi->filename ? kvi->filename :
			    ""the command line"");"
implicit_predicate,config.c,205,-,+,,20,	const char term = opts->end_nul ? '\0' : '\t';
implicit_predicate,config.c,210,-,+,,22,"		strbuf_addstr(buf, kvi->filename ? kvi->filename : """");"
implicit_predicate,config.c,212,-,+,,17,"		quote_c_style(kvi->filename ? kvi->filename : """", buf, NULL, 0);"
implicit_predicate,config.c,220,-,+,,20,	const char term = opts->end_nul ? '\0' : '\t';
implicit_predicate,config.c,273,-,+,,32,"				    git_config_int64(key_, value_ ? value_ : """", kvi));"
implicit_predicate,config.c,275,-,+,,23,"			strbuf_addstr(buf, git_config_bool(key_, value_) ?
				      ""true"" : ""false"");"
implicit_predicate,config.c,278,+,+,icase ? WM_CASEFOLD : 0,20,			 WM_PATHNAME | (icase ? WM_CASEFOLD : 0));
implicit_predicate,config.c,281,+,-,"if (is_bool)
    strbuf_addstr(buf, v ? ""true"" : ""false"");
else
    strbuf_addf(buf, ""%d"", v);
",,
implicit_predicate,config.c,282,+,+,"v ? ""true"" : ""false""",24,"				strbuf_addstr(buf, v ? ""true"" : ""false"");"
implicit_predicate,config.c,290,+,+,"v ? ""true"" : ""false""",24,"				strbuf_addstr(buf, v ? ""true"" : ""false"");"
implicit_predicate,config.c,348,-,+,,35,"	    strcmp(data->value_pattern, (value_?value_:"""")))"
implicit_predicate,config.c,351,-,+,,53,"	    (data->do_not_match ^ !!regexec(data->regexp, (value_?value_:""""), 0, NULL, 0)))"
implicit_predicate,config.c,377,+,-,"if (get_value_flags & GET_VALUE_KEY_REGEXP){
    char* tl;
    key = xstrdup(key_);
    for (tl = key + strlen(key) - 1;tl >= key && *tl != '.';tl--)
        *tl = tolower(*tl);
    for (tl = key;*tl && *tl != '.';tl++)
        *tl = tolower(*tl);
    data.key_regexp = (regex_t*)xmalloc(sizeof (regex_t));
    if (regcomp(data.key_regexp, key, REG_EXTENDED)){
        error(_(""invalid key pattern: %s""), key_);
        FREE_AND_NULL(data.key_regexp);
        ret = CONFIG_INVALID_PATTERN;
        goto free_strings;
    }
}else{
    if (git_config_parse_key(key_, &key, NULL)){
        ret = CONFIG_INVALID_KEY;
        goto free_strings;
    }
    data.key = key;
}
",,
implicit_predicate,config.c,487,-,+,,18,"		return xstrdup(git_config_bool(key, value) ?  ""true"" : ""false"");"
implicit_predicate,config.c,494,+,+,"v ? ""true"" : ""false""",19,"			return xstrdup(v ? ""true"" : ""false"");"
implicit_predicate,config.c,501,+,+,"v ? ""true"" : ""false""",19,"			return xstrdup(v ? ""true"" : ""false"");"
implicit_predicate,config.c,612,+,-,"if (print){
    printf(""%s\n"", data.get_colorbool_found ? ""true"" : ""false"");
    return 0;
}else
    return data.get_colorbool_found ? 0 : 1;
",,
implicit_predicate,config.c,613,+,+,"data.get_colorbool_found ? ""true"" : ""false""",18,"		printf(""%s\n"", data.get_colorbool_found ? ""true"" : ""false"");"
implicit_predicate,config.c,616,+,+,data.get_colorbool_found ? 0 : 1,10,		return data.get_colorbool_found ? 0 : 1;
implicit_predicate,config.c,646,-,+,,11,"		value = pair[1] ? pair[1]->buf : """";"
implicit_predicate,config.c,704,+,+,matched->value_is_null ? NULL : matched->value.buf,10,"			      matched->value_is_null ? NULL : matched->value.buf,"
implicit_predicate,config.c,731,+,-,"if (*endp){
    ret = error(_(""bogus count in %s""), CONFIG_COUNT_ENVIRONMENT);
    goto out;
}
",,
implicit_predicate,config.c,748,+,-,"if (opts->use_local_config)
    die(_(""--local can only be used inside a git repository""));
",,
implicit_predicate,config.c,752,+,-,"if (opts->use_worktree_config)
    die(_(""--worktree can only be used inside a git repository""));
",,
implicit_predicate,config.c,763,+,-,"if (opts->use_global_config){
    opts->source.file = opts->file_to_free = git_global_config();
    if (!opts->source.file)
        die(_(""$HOME not set""));

    opts->source.scope = CONFIG_SCOPE_GLOBAL;
}else
    if (opts->use_system_config){
        opts->source.file = opts->file_to_free = git_system_config();
        opts->source.scope = CONFIG_SCOPE_SYSTEM;
    }else
        if (opts->use_local_config){
            opts->source.file = opts->file_to_free = git_pathdup(""config"");
            opts->source.scope = CONFIG_SCOPE_LOCAL;
        }else
            if (opts->use_worktree_config){
                struct worktree** worktrees = get_worktrees();
                if (the_repository->repository_format_worktree_config)
                    opts->source.file = opts->file_to_free = git_pathdup(""config.worktree"");
                else
                    if (worktrees[0] && worktrees[1])
                        die(_(""--worktree cannot be used with multiple working trees unless the config\nextension worktreeConfig is enabled. Please read \""CONFIGURATION FILE\""\nsection in \""git help worktree\"" for details""));
                    else
                        opts->source.file = opts->file_to_free = git_pathdup(""config"");

                opts->source.scope = CONFIG_SCOPE_LOCAL;
                free_worktrees(worktrees);
            }else
                if (opts->source.file){
                    if (!is_absolute_path(opts->source.file) && prefix)
                        opts->source.file = opts->file_to_free = prefix_filename(prefix, opts->source.file);

                    opts->source.scope = CONFIG_SCOPE_COMMAND;
                }else
                    if (opts->source.blob){
                        opts->source.scope = CONFIG_SCOPE_COMMAND;
                    }
",,
implicit_predicate,config.c,774,+,-,"if (opts->use_system_config){
    opts->source.file = opts->file_to_free = git_system_config();
    opts->source.scope = CONFIG_SCOPE_SYSTEM;
}else
    if (opts->use_local_config){
        opts->source.file = opts->file_to_free = git_pathdup(""config"");
        opts->source.scope = CONFIG_SCOPE_LOCAL;
    }else
        if (opts->use_worktree_config){
            struct worktree** worktrees = get_worktrees();
            if (the_repository->repository_format_worktree_config)
                opts->source.file = opts->file_to_free = git_pathdup(""config.worktree"");
            else
                if (worktrees[0] && worktrees[1])
                    die(_(""--worktree cannot be used with multiple working trees unless the config\nextension worktreeConfig is enabled. Please read \""CONFIGURATION FILE\""\nsection in \""git help worktree\"" for details""));
                else
                    opts->source.file = opts->file_to_free = git_pathdup(""config"");

            opts->source.scope = CONFIG_SCOPE_LOCAL;
            free_worktrees(worktrees);
        }else
            if (opts->source.file){
                if (!is_absolute_path(opts->source.file) && prefix)
                    opts->source.file = opts->file_to_free = prefix_filename(prefix, opts->source.file);

                opts->source.scope = CONFIG_SCOPE_COMMAND;
            }else
                if (opts->source.blob){
                    opts->source.scope = CONFIG_SCOPE_COMMAND;
                }
",,
implicit_predicate,config.c,777,+,-,"if (opts->use_local_config){
    opts->source.file = opts->file_to_free = git_pathdup(""config"");
    opts->source.scope = CONFIG_SCOPE_LOCAL;
}else
    if (opts->use_worktree_config){
        struct worktree** worktrees = get_worktrees();
        if (the_repository->repository_format_worktree_config)
            opts->source.file = opts->file_to_free = git_pathdup(""config.worktree"");
        else
            if (worktrees[0] && worktrees[1])
                die(_(""--worktree cannot be used with multiple working trees unless the config\nextension worktreeConfig is enabled. Please read \""CONFIGURATION FILE\""\nsection in \""git help worktree\"" for details""));
            else
                opts->source.file = opts->file_to_free = git_pathdup(""config"");

        opts->source.scope = CONFIG_SCOPE_LOCAL;
        free_worktrees(worktrees);
    }else
        if (opts->source.file){
            if (!is_absolute_path(opts->source.file) && prefix)
                opts->source.file = opts->file_to_free = prefix_filename(prefix, opts->source.file);

            opts->source.scope = CONFIG_SCOPE_COMMAND;
        }else
            if (opts->source.blob){
                opts->source.scope = CONFIG_SCOPE_COMMAND;
            }
",,
implicit_predicate,config.c,780,+,-,"if (opts->use_worktree_config){
    struct worktree** worktrees = get_worktrees();
    if (the_repository->repository_format_worktree_config)
        opts->source.file = opts->file_to_free = git_pathdup(""config.worktree"");
    else
        if (worktrees[0] && worktrees[1])
            die(_(""--worktree cannot be used with multiple working trees unless the config\nextension worktreeConfig is enabled. Please read \""CONFIGURATION FILE\""\nsection in \""git help worktree\"" for details""));
        else
            opts->source.file = opts->file_to_free = git_pathdup(""config"");

    opts->source.scope = CONFIG_SCOPE_LOCAL;
    free_worktrees(worktrees);
}else
    if (opts->source.file){
        if (!is_absolute_path(opts->source.file) && prefix)
            opts->source.file = opts->file_to_free = prefix_filename(prefix, opts->source.file);

        opts->source.scope = CONFIG_SCOPE_COMMAND;
    }else
        if (opts->source.blob){
            opts->source.scope = CONFIG_SCOPE_COMMAND;
        }
",,
implicit_predicate,config.c,822,+,-,"if (opts->end_nul){
    opts->term = '\0';
    opts->delim = '\n';
    opts->key_delim = '\n';
}
",,
implicit_predicate,config.c,828,+,-,"if (quote){
    cs->linenr--;
    return NULL;
}
",,
implicit_predicate,config.c,836,+,-,"if (comment)
    continue;
",,
implicit_predicate,config.c,898,+,-,"if (cs->eof)
    break;
",,
implicit_predicate,config.c,948,+,-,"if (append)
    value_pattern = CONFIG_REGEX_NONE;
",,
implicit_predicate,config.c,972,+,-,"if (cs->eof)
    return -1;
",,
implicit_predicate,config.c,1071,+,-,"if (cs->eof){
    if (do_event(cs, CONFIG_EVENT_EOF, &event_data) < 0)
        return -1;

    return 0;
}
",,
implicit_predicate,config.c,1081,+,-,"if (comment)
    continue;
",,
implicit_predicate,config.c,1082,-,+,,16,"	config_file = opts->source.file ?
			xstrdup(opts->source.file) :
			git_pathdup(""config"");"
implicit_predicate,config.c,1085,+,-,"if (opts->use_global_config){
    int fd = open(config_file, O_CREAT | O_EXCL | O_WRONLY, 0666);
    if (fd >= 0){
        char* content = default_user_config();
        write_str_in_full(fd, content);
        free(content);
        close(fd);
    }else
        if (errno != EEXIST)
            die_errno(_(""cannot create configuration file %s""), config_file);
}
",,
implicit_predicate,config.c,1263,+,-,"if (actions & (ACTION_LIST | ACTION_GET_ALL | ACTION_GET_REGEXP | ACTION_GET_URLMATCH))
    setup_auto_pager(""config"", 1);
",,
implicit_predicate,config.c,1302,+,-,"if (negated)
    negative |= n->component_bits;
else
    positive |= n->component_bits;
",,
implicit_predicate,config.c,1441,+,-,"if (git_config_bool(var, value))
    log_all_ref_updates = LOG_REFS_NORMAL;
else
    log_all_ref_updates = LOG_REFS_NONE;
",,
implicit_predicate,config.c,1452,+,-,"if (git_config_bool(var, value))
    log_all_ref_updates = LOG_REFS_NORMAL;
else
    log_all_ref_updates = LOG_REFS_NONE;
",,
implicit_predicate,config.c,1539,+,-,eol_rndtrp_die ? CONV_EOL_RNDTRP_DIE : 0,,
implicit_predicate,config.c,1550,+,+,eol_rndtrp_die ? CONV_EOL_RNDTRP_DIE : 0,27,"		global_conv_flags_eol = eol_rndtrp_die ?
			CONV_EOL_RNDTRP_DIE : 0;"
implicit_predicate,config.c,2080,-,+,,7,			   opts->system_gently ? ACCESS_EACCES_OK : 0))
implicit_predicate,config.c,2232,+,-,"if (ret)
    return ret;
",,
implicit_predicate,config.c,2243,+,-,"if (ret)
    return ret;
",,
implicit_predicate,config.c,2254,+,-,"if (ret)
    return ret;
",,
implicit_predicate,config.c,2265,+,-,"if (ret)
    return ret;
",,
implicit_predicate,config.c,2364,+,-,"if ((ret = configset_find_element(set, key, &e)))
    return ret;
else
    if (!e)
        return 1;
",,
implicit_predicate,config.c,2375,+,-,"if ((ret = configset_find_element(set, key, &e)))
    return ret;
else
    if (!e)
        return 1;
",,
implicit_predicate,config.c,2383,+,-,"if ((ret = git_configset_get_value_multi(cs, key, dest)))
    return ret;
",,
implicit_predicate,config.c,2386,-,+,,9,	return item->string ? 0 : config_error_nonbool(util);
implicit_predicate,config.c,2394,+,-,"if ((ret = git_configset_get_value_multi(cs, key, dest)))
    return ret;
",,
implicit_predicate,config.c,2397,+,-,"if ((ret = configset_find_element(set, key, &e)))
    return ret;
else
    if (!e)
        return 1;
",,
implicit_predicate,config.c,2408,+,-,"if ((ret = configset_find_element(set, key, &e)))
    return ret;
else
    if (!e)
        return 1;
",,
implicit_predicate,config.c,2738,+,-,"if (ret)
    return ret;
",,
implicit_predicate,config.c,2749,+,-,"if (ret)
    return ret;
",,
implicit_predicate,config.c,2754,+,-,"if (git_config_get_string_tmp(key, &expiry_string))
    return 1;
",,
implicit_predicate,config.c,2765,+,-,"if (git_config_get_string_tmp(key, &expiry_string))
    return 1;
",,
implicit_predicate,config.c,2800,+,-,"if (val){
    *dest = val;
    return 0;
}
",,
implicit_predicate,config.c,2806,+,-,"if (is_bool)
    *dest = val ? 0 : 1;
else
    *dest = val;
",,
implicit_predicate,config.c,2807,+,-,val ? 0 : 1,,
implicit_predicate,config.c,2811,+,-,"if (val){
    *dest = val;
    return 0;
}
",,
implicit_predicate,config.c,2817,+,-,"if (is_bool)
    *dest = val ? 0 : 1;
else
    *dest = val;
",,
implicit_predicate,config.c,2818,+,+,val ? 0 : 1,12,			*dest = val ? 0 : 1;
implicit_predicate,config.c,2839,+,-,"if (git_config_get_value_multi(key, &values))
    BUG(""for key '%s' we must have a value to report on"", key);
",,
implicit_predicate,config.c,2850,+,-,"if (git_config_get_value_multi(key, &values))
    BUG(""for key '%s' we must have a value to report on"", key);
",,
implicit_predicate,config.c,2911,+,-,"if (cs->subsection_case_sensitive)
    cmpfn = strncasecmp;
else
    cmpfn = strncmp;
",,
implicit_predicate,config.c,2921,+,-,"if (store->is_keys_section){
    store->section_seen = 1;
    ALLOC_GROW(store->seen, store->seen_nr + 1, store->seen_alloc);
    store->seen[store->seen_nr] = store->parsed_nr;
}
",,
implicit_predicate,config.c,2922,+,-,"if (cs->subsection_case_sensitive)
    cmpfn = strncasecmp;
else
    cmpfn = strncmp;
",,
implicit_predicate,config.c,2932,+,-,"if (store->is_keys_section){
    store->section_seen = 1;
    ALLOC_GROW(store->seen, store->seen_nr + 1, store->seen_alloc);
    store->seen[store->seen_nr] = store->parsed_nr;
}
",,
implicit_predicate,config.c,3121,+,-,"if (store->parsed[i].is_keys_section)
    continue;
",,
implicit_predicate,config.c,3132,+,-,"if (store->parsed[i].is_keys_section)
    continue;
",,
implicit_predicate,config.c,3281,+,-,"if (ret)
    goto out_free;
",,
implicit_predicate,config.c,3292,+,-,"if (ret)
    goto out_free;
",,
implicit_predicate,config.c,3646,+,-,"if (ret)
    goto out;
",,
implicit_predicate,config.c,3657,+,-,"if (ret)
    goto out;
",,
implicit_predicate,config.c,3734,+,-,"if (remove)
    continue;
",,
implicit_predicate,config.c,3745,+,-,"if (remove)
    continue;
",,
implicit_predicate,connect.c,125,+,-,"if (die_on_error)
    die(_(""server doesn't support feature '%s'""), feature);
",,
implicit_predicate,connect.c,211,+,-,"while (1){
    size_t len;
    const char* val;
    val = next_server_feature_value(""symref"", &len, &offset);
    if (!val)
        break;

    parse_one_symref_info(&symref, val, len);
}
",,
implicit_predicate,connect.c,296,+,-,"if (check_ref(name, flags)){
    struct ref* ref = alloc_ref(name);
    oidcpy(&ref->old_oid, &old_oid);
    **list = ref;
    *list = &ref->next;
}
",,
implicit_predicate,connect.c,364,+,-,"if (process_dummy_ref(reader)){
    state = EXPECTING_SHALLOW;
    break;
}
",,
implicit_predicate,connect.c,371,+,-,"if (process_ref(reader, len, &list, flags, extra_have))
    break;
",,
implicit_predicate,connect.c,376,+,-,"if (process_shallow(reader, len, shallow_points))
    break;
",,
implicit_predicate,connect.c,489,+,-,"if (server_supports_v2(""agent""))
    packet_write_fmt(fd_out, ""agent=%s"", git_user_agent_sanitized());
",,
implicit_predicate,connect.c,492,+,-,"if (server_feature_v2(""object-format"", &hash_name)){
    int hash_algo = hash_algo_by_name(hash_name);
    if (hash_algo == GIT_HASH_UNKNOWN)
        die(_(""unknown object format '%s' specified by server""), hash_name);

    reader->hash_algo = &hash_algos[hash_algo];
    packet_write_fmt(fd_out, ""object-format=%s"", reader->hash_algo->name);
}else{
    reader->hash_algo = &hash_algos[GIT_HASH_SHA1];
}
",,
implicit_predicate,connect.c,553,-,+,,32,"	struct strvec *ref_prefixes = transport_options ?
		&transport_options->ref_prefixes : NULL;"
implicit_predicate,connect.c,555,-,+,,36,"	const char **unborn_head_target = transport_options ?
		&transport_options->unborn_head_target : NULL;"
implicit_predicate,connect.c,577,+,-,"if (server_supports_feature(""ls-refs"", ""unborn"", 0))
    packet_write_fmt(fd_out, ""unborn\n"");
",,
implicit_predicate,connect.c,746,+,-,"if (removebrackets){
    *end = 0;
    memmove(start, start + 1, end - start);
    end++;
}
",,
implicit_predicate,connect.c,825,+,-,"if (gai)
    die(_(""unable to look up %s (port %s) (%s)""), host, port, gai_strerror(gai));
",,
implicit_predicate,connect.c,1261,+,-,"if (git_use_proxy(hostandport))
    conn = git_proxy_connect(fd, hostandport);
else
    conn = git_tcp_connect(fd, hostandport, flags);
",,
implicit_predicate,connect.c,1395,-,+,,13,		variant = run_command(&detect) ? VARIANT_SIMPLE : VARIANT_SSH;
implicit_predicate,connect.c,1440,-,+,,28,"		printf(""Diag: url=%s\n"", url ? url : ""NULL"");"
implicit_predicate,connect.c,1442,-,+,,36,"		printf(""Diag: hostandport=%s\n"", hostandport ? hostandport : ""NULL"");"
implicit_predicate,connect.c,1443,-,+,,29,"		printf(""Diag: path=%s\n"", path ? path : ""NULL"");"
implicit_predicate,connect.c,1478,-,+,,30,"				printf(""Diag: url=%s\n"", url ? url : ""NULL"");"
implicit_predicate,connect.c,1480,-,+,,38,"				printf(""Diag: userandhost=%s\n"", ssh_host ? ssh_host : ""NULL"");"
implicit_predicate,connect.c,1481,-,+,,31,"				printf(""Diag: port=%s\n"", port ? port : ""NONE"");"
implicit_predicate,connect.c,1482,-,+,,31,"				printf(""Diag: path=%s\n"", path ? path : ""NULL"");"
implicit_predicate,convert.c,109,+,-,"if (convert_is_binary(&stats))
    ret |= CONVERT_STAT_BITS_BIN;
",,
implicit_predicate,convert.c,111,+,-,"if (stats.crlf)
    ret |= CONVERT_STAT_BITS_TXT_CRLF;
",,
implicit_predicate,convert.c,113,+,-,"if (stats.lonelf)
    ret |= CONVERT_STAT_BITS_TXT_LF;
",,
implicit_predicate,convert.c,123,+,-,"if (convert_stats & CONVERT_STAT_BITS_BIN)
    return ""-text"";
",,
implicit_predicate,convert.c,188,+,+,text_eol_is_crlf() ? EOL_CRLF : EOL_LF,10,		return text_eol_is_crlf() ? EOL_CRLF : EOL_LF;
implicit_predicate,convert.c,259,+,-,"if (convert_is_binary(stats))
    return 0;
",,
implicit_predicate,convert.c,292,+,-,"if (die_on_error)
    die(error_msg, path, enc);
else{
    return error(error_msg, path, enc);
}
",,
implicit_predicate,convert.c,307,+,-,"if (die_on_error)
    die(error_msg, path, enc);
else{
    return error(error_msg, path, enc);
}
",,
implicit_predicate,convert.c,416,+,-,"if (die_on_error)
    die(msg, path, enc, default_encoding);
else{
    error(msg, path, enc, default_encoding);
    return 0;
}
",,
implicit_predicate,convert.c,520,+,-,"if (convert_is_binary(&stats))
    return 0;
",,
implicit_predicate,convert.c,537,+,-,"if (convert_crlf_into_lf){
    new_stats.lonelf += new_stats.crlf;
    new_stats.crlf = 0;
}
",,
implicit_predicate,convert.c,826,+,-,"if (wanted_capability & CAP_CLEAN)
    filter_type = ""clean"";
else
    if (wanted_capability & CAP_SMUDGE)
        filter_type = ""smudge"";
    else
        die(_(""unexpected filter type""));
",,
implicit_predicate,convert.c,828,+,-,"if (wanted_capability & CAP_SMUDGE)
    filter_type = ""smudge"";
else
    die(_(""unexpected filter type""));
",,
implicit_predicate,convert.c,837,+,-,"if (err)
    goto done;
",,
implicit_predicate,convert.c,841,+,-,"if (err){
    error(_(""path name too long for external filter""));
    goto done;
}
",,
implicit_predicate,convert.c,847,+,-,"if (err)
    goto done;
",,
implicit_predicate,convert.c,852,+,-,"if (err)
    goto done;
",,
implicit_predicate,convert.c,858,+,-,"if (err)
    goto done;
",,
implicit_predicate,convert.c,864,+,-,"if (err)
    goto done;
",,
implicit_predicate,convert.c,872,+,-,"if (err)
    goto done;
",,
implicit_predicate,convert.c,877,+,-,"if (err)
    goto done;
",,
implicit_predicate,convert.c,884,+,-,"if (err)
    goto done;
",,
implicit_predicate,convert.c,888,+,-,"if (err)
    goto done;
",,
implicit_predicate,convert.c,892,+,-,"if (err)
    goto done;
",,
implicit_predicate,convert.c,901,+,-,"if (err)
    goto done;
",,
implicit_predicate,convert.c,906,+,-,"if (err)
    goto done;
",,
implicit_predicate,convert.c,910,+,-,"if (err)
    goto done;
",,
implicit_predicate,convert.c,919,+,-,"if (err)
    handle_filter_error(&filter_status, entry, wanted_capability);
else
    strbuf_swap(dst, &nbuf);
",,
implicit_predicate,convert.c,949,+,-,"if (err)
    goto done;
",,
implicit_predicate,convert.c,953,+,-,"if (err)
    goto done;
",,
implicit_predicate,convert.c,965,+,-,"if (err)
    goto done;
",,
implicit_predicate,convert.c,973,+,-,"if (err)
    handle_filter_error(&filter_status, entry, 0);
",,
implicit_predicate,convert.c,1074,+,-,"while (size){
    ch = *cp++;
    size--;
    if (ch != '$')
        continue;

    if (size < 3)
        break;

    if (memcmp(""Id"", cp, 2))
        continue;

    ch = cp[2];
    cp += 3;
    size -= 3;
    if (ch == '$')
        cnt++;

    if (ch != ':')
        continue;

    while (size){
        ch = *cp++;
        size--;
        if (ch == '$'){
            cnt++;
            break;
        }
        if (ch == '\n')
            break;
    }
}
",,
implicit_predicate,convert.c,1094,+,-,"while (size){
    ch = *cp++;
    size--;
    if (ch == '$'){
        cnt++;
        break;
    }
    if (ch == '\n')
        break;
}
",,
implicit_predicate,convert.c,1341,+,+,text_eol_is_crlf() ? CRLF_TEXT_CRLF : CRLF_TEXT_INPUT,21,		ca->crlf_action = text_eol_is_crlf() ? CRLF_TEXT_CRLF : CRLF_TEXT_INPUT;
implicit_predicate,convert.c,1473,+,-,"if (ret){
    src = dst->buf;
    len = dst->len;
}
",,
implicit_predicate,convert.c,1484,+,-,"if (ret){
    src = dst->buf;
    len = dst->len;
}
",,
implicit_predicate,convert.c,1491,+,-,"if (ret){
    src = dst->buf;
    len = dst->len;
}
",,
implicit_predicate,convert.c,1532,+,-,"if (ret){
    src = dst->buf;
    len = dst->len;
}
",,
implicit_predicate,convert.c,1636,+,-,"if (lf_to_crlf->has_held){
    was_cr = 1;
    lf_to_crlf->has_held = 0;
}
",,
implicit_predicate,convert.c,1646,+,-,"if (was_cr){
    output[o++] = '\r';
}
",,
implicit_predicate,convert.c,1745,-,+,,13,		to_feed = input ? *isize_p : 0;
implicit_predicate,convert.c,1908,+,-,"if (ident->state)
    strbuf_add(&ident->left, head, ident->state);
",,
implicit_predicate,copy.c,10,+,-,"while (1){
    char buffer[8192];
    ssize_t len = xread(ifd, buffer, sizeof (buffer));
    if (!len)
        break;

    if (len < 0)
        return COPY_READ_ERROR;

    if (write_in_full(ofd, buffer, len) < 0)
        return COPY_WRITE_ERROR;
}
",,
implicit_predicate,copy.c,40,+,+,(mode & 0111) ? 0777 : 0666,9,	mode = (mode & 0111) ? 0777 : 0666;
implicit_predicate,copy.c,105,+,-,"if (ret)
    ret = !(st1.st_mode & 0111) == !(st2.st_mode & 0111);
",,
implicit_predicate,copy.c,109,+,-,"if (ret)
    ret = st1.st_size == st2.st_size;
",,
implicit_predicate,copy.c,112,+,-,"while (ret){
    ssize_t len1 = read_in_full(fd1, buf1, sizeof (buf1));
    ssize_t len2 = read_in_full(fd2, buf2, sizeof (buf2));
    if (len1 < 0 || len2 < 0 || len1 != len2)
        ret = 0;
    else
        if (!len1)
            break;
        else
            ret = !memcmp(buf1, buf2, len1);
}
",,
implicit_predicate,count-objects.c,58,+,-,"if (verbose)
    report_garbage(PACKDIR_FILE_GARBAGE, path);
",,
implicit_predicate,count-objects.c,112,+,-,"if (argc)
    usage_with_options(count_objects_usage, opts);
",,
implicit_predicate,count-objects.c,114,+,-,"if (verbose){
    report_garbage = real_report_garbage;
    report_linked_checkout_garbage();
}
",,
implicit_predicate,count-objects.c,122,+,-,"if (verbose){
    struct packed_git* p;
    unsigned long num_pack = 0;
    off_t size_pack = 0;
    struct strbuf loose_buf = STRBUF_INIT;
    struct strbuf pack_buf = STRBUF_INIT;
    struct strbuf garbage_buf = STRBUF_INIT;
    for (p = get_all_packs(the_repository);p;p = p->next){
        if (!p->pack_local)
            continue;

        if (open_pack_index(p))
            continue;

        packed += p->num_objects;
        size_pack += p->pack_size + p->index_size;
        num_pack++;
    }
    if (human_readable){
        strbuf_humanise_bytes(&loose_buf, loose_size);
        strbuf_humanise_bytes(&pack_buf, size_pack);
        strbuf_humanise_bytes(&garbage_buf, size_garbage);
    }else{
        strbuf_addf(&loose_buf, ""%lu"", (unsigned long )(loose_size / 1024));
        strbuf_addf(&pack_buf, ""%lu"", (unsigned long )(size_pack / 1024));
        strbuf_addf(&garbage_buf, ""%lu"", (unsigned long )(size_garbage / 1024));
    }
    printf(""count: %lu\n"", loose);
    printf(""size: %s\n"", loose_buf.buf);
    printf(""in-pack: %lu\n"", packed);
    printf(""packs: %lu\n"", num_pack);
    printf(""size-pack: %s\n"", pack_buf.buf);
    printf(""prune-packable: %lu\n"", packed_loose);
    printf(""garbage: %lu\n"", garbage);
    printf(""size-garbage: %s\n"", garbage_buf.buf);
    foreach_alt_odb(print_alternate, NULL);
    strbuf_release(&loose_buf);
    strbuf_release(&pack_buf);
    strbuf_release(&garbage_buf);
}else{
    struct strbuf buf = STRBUF_INIT;
    if (human_readable)
        strbuf_humanise_bytes(&buf, loose_size);
    else
        strbuf_addf(&buf, ""%lu kilobytes"", (unsigned long )(loose_size / 1024));

    printf(""%lu objects, %s\n"", loose, buf.buf);
    strbuf_release(&buf);
}
",,
implicit_predicate,count-objects.c,140,+,-,"if (human_readable){
    strbuf_humanise_bytes(&loose_buf, loose_size);
    strbuf_humanise_bytes(&pack_buf, size_pack);
    strbuf_humanise_bytes(&garbage_buf, size_garbage);
}else{
    strbuf_addf(&loose_buf, ""%lu"", (unsigned long )(loose_size / 1024));
    strbuf_addf(&pack_buf, ""%lu"", (unsigned long )(size_pack / 1024));
    strbuf_addf(&garbage_buf, ""%lu"", (unsigned long )(size_garbage / 1024));
}
",,
implicit_predicate,count-objects.c,167,+,-,"if (human_readable)
    strbuf_humanise_bytes(&buf, loose_size);
else
    strbuf_addf(&buf, ""%lu kilobytes"", (unsigned long )(loose_size / 1024));
",,
implicit_predicate,credential-cache--daemon.c,246,+,-,"while (serve_cache_loop(fd));

",,
implicit_predicate,credential-cache--daemon.c,322,+,-,"if (ignore_sighup)
    signal(SIGHUP, SIG_IGN);
",,
implicit_predicate,credential-cache.c,55,+,-,"while (1){
    char in[1024];
    int r;
    r = read_in_full(fd, in, sizeof (in));
    if (r == 0 || (r < 0 && connection_closed(errno)))
        break;

    if (r < 0)
        die_errno(""read error from cache daemon"");

    write_or_die(1, in, r);
    got_data = 1;
}
",,
implicit_predicate,credential-cache.c,101,+,-,"if (flags & FLAG_RELAY){
    if (strbuf_read(&buf, 0, 0) < 0)
        die_errno(""unable to relay credential"");
}
",,
implicit_predicate,credential-cache.c,109,+,-,"if (flags & FLAG_SPAWN){
    spawn_daemon(socket);
    if (send_request(socket, &buf) < 0)
        die_errno(""unable to connect to cache daemon"");
}
",,
implicit_predicate,credential-store.c,86,+,-,"if (is_rfc3986_unreserved(ch))
    return 1;
",,
implicit_predicate,credential.c,416,+,-,"if (want_output)
    helper.out = -1;
else
    helper.no_stdout = 1;
",,
implicit_predicate,credential.c,426,+,+,want_output ? CREDENTIAL_OP_HELPER : CREDENTIAL_OP_RESPONSE,26,"	credential_write(c, fp, want_output ? CREDENTIAL_OP_HELPER : CREDENTIAL_OP_RESPONSE);"
implicit_predicate,credential.c,430,+,-,"if (want_output){
    int r;
    fp = xfdopen(helper.out, ""r"");
    r = credential_read(c, fp, CREDENTIAL_OP_HELPER);
    fclose(fp);
    if (r < 0){
        finish_command(&helper);
        return -1;
    }
}
",,
implicit_predicate,credential.c,477,+,-,"if (all_capabilities)
    credential_set_all_capabilities(c, CREDENTIAL_OP_INITIAL);
",,
implicit_predicate,credential.c,595,-,+,,7,	cp = proto_end ? proto_end + 3 : url;
implicit_predicate,csum-file.c,48,+,-,"if (offset){
    if (!f->skip_hash)
        the_hash_algo->update_fn(&f->ctx, f->buffer, offset);

    flush(f, f->buffer, offset);
    f->offset = 0;
}
",,
implicit_predicate,csum-file.c,93,+,-,"if (cnt)
    die(""%s: sha1 file has trailing garbage"", f->name);
",,
implicit_predicate,csum-file.c,104,+,-,"while (count){
    unsigned left = f->buffer_len - f->offset;
    unsigned nr = count > left ? left : count;
    if (f->do_crc)
        f->crc32 = crc32(f->crc32, buf, nr);

    if (nr == f->buffer_len){
        if (!f->skip_hash)
            the_hash_algo->update_fn(&f->ctx, buf, nr);

        flush(f, buf, nr);
    }else{
        memcpy(f->buffer + f->offset, buf, nr);
        f->offset += nr;
        left -= nr;
        if (!left)
            hashflush(f);
    }
    count -= nr;
    buf = (char*)buf + nr;
}
",,
implicit_predicate,daemon.c,398,+,-,"if (service->overridable){
    strbuf_addf(&var, ""daemon.%s"", service->config_name);
    git_config_get_bool(var.buf, &enabled);
    strbuf_release(&var);
}
",,
implicit_predicate,daemon.c,599,+,-,"if (*val){
    char* host;
    char* port;
    parse_host_and_port(val, &host, &port);
    if (port)
        sanitize_client(&hi->tcp_port, port);

    canonicalize_client(&hi->hostname, host);
    hi->hostname_lookup_done = 0;
}
",,
implicit_predicate,daemon.c,745,+,+,init_timeout ? init_timeout : timeout,8,	alarm(init_timeout ? init_timeout : timeout);
implicit_predicate,daemon.c,856,+,-,"if (status)
    dead = "" (with error)"";
",,
implicit_predicate,daemon.c,980,+,-,"if (gai){
    logerror(""getaddrinfo() for %s failed: %s"", listen_addr, gai_strerror(gai));
    return 0;
}
",,
implicit_predicate,daemon.c,1006,+,-,"if (set_reuse_addr(sockfd)){
    logerror(""Could not set SO_REUSEADDR: %s"", strerror(errno));
    close(sockfd);
    continue;
}
",,
implicit_predicate,daemon.c,1444,+,-,"if (detach){
    if (daemonize())
        die(""--detach not supported on this platform"");
}
",,
implicit_predicate,date.c,232,+,-,"if (hide.year){
    if (tm->tm_mon == human_tm->tm_mon){
        if (tm->tm_mday > human_tm->tm_mday){
        }else
            if (tm->tm_mday == human_tm->tm_mday){
                hide.date = hide.wday = 1;
            }else
                if (tm->tm_mday + 5 > human_tm->tm_mday){
                    hide.date = 1;
                }
    }
}
",,
implicit_predicate,date.c,246,+,-,"if (hide.wday){
    show_date_relative(time, buf);
    return;
}
",,
implicit_predicate,date.c,517,-,+,,19,		struct tm *r = (now_tm ? &check : tm);
implicit_predicate,date.c,700,+,-,"if (match)
    return match;
",,
implicit_predicate,date.c,730,+,-,"if (maybeiso8601(tm)){
    unsigned int num1 = num;
    unsigned int num2 = 0;
    if (n == 4){
        num1 = num / 100;
        num2 = num % 100;
    }
    if ((n == 4 || n == 2) && !nodate(tm) && set_time(num1, num2, 0, tm) == 0)
        return n;

    tm->tm_min = tm->tm_sec = -1;
}
",,
implicit_predicate,date.c,1091,+,-,"if (number){
    *num = 0;
    if (tm->tm_mday < 0 && number < 32)
        tm->tm_mday = number;
    else
        if (tm->tm_mon < 0 && number < 13)
            tm->tm_mon = number - 1;
        else
            if (tm->tm_year < 0){
                if (number > 1969 && number < 2100)
                    tm->tm_year = number - 1900;
                else
                    if (number > 69 && number < 100)
                        tm->tm_year = number;
                    else
                        if (number < 38)
                            tm->tm_year = 100 + number;
            }
}
",,
implicit_predicate,date.c,1327,+,-,"if (match)
    return date + match;
",,
implicit_predicate,debug.c,166,+,-,"if (res)
    trace_printf_key(&trace_refs, ""iterator_advance: (%d)\n"", res);
else
    trace_printf_key(&trace_refs, ""iterator_advance: %s (0)\n"", diter->iter->refname);
",,
implicit_predicate,debug.c,173,+,-,"if (res)
    trace_printf_key(&trace_refs, ""iterator_advance: (%d)\n"", res);
else
    trace_printf_key(&trace_refs, ""iterator_advance: %s (0)\n"", diter->iter->refname);
",,
implicit_predicate,default.c,140,+,-,"if (mark & COMMON)
    mark_common(ns, parents->item, 1, 0);
",,
implicit_predicate,default.c,194,+,-,"if (marked)
    refs_for_each_ref(get_main_ref_store(the_repository), clear_marks, NULL);
",,
implicit_predicate,delta-islands.c,153,+,-,"if (hash_ret)
    kh_value(island_marks, pos) = island_bitmap_new(NULL);
",,
implicit_predicate,delta-islands.c,166,+,-,"if (hash_ret){
    marks->refcount++;
    kh_value(island_marks, pos) = marks;
    return;
}
",,
implicit_predicate,delta-islands.c,218,+,-,"if (is_core_island)
    island_counter_core = island_counter;
",,
implicit_predicate,delta-islands.c,266,+,-,"if (progress)
    progress_state = start_progress(_(""Propagating island marks""), nr);
",,
implicit_predicate,delta-islands.c,379,+,-,"if (hash_ret){
    kh_key(remote_islands, pos) = xstrdup(island_name);
    kh_value(remote_islands, pos) = xcalloc(1, sizeof (struct remote_island));
}
",,
implicit_predicate,delta-islands.c,497,+,-,"if (progress)
    fprintf(stderr, _(""Marked %d islands, done.\n""), island_counter);
",,
implicit_predicate,describe.c,81,-,+,,30,"	return !oideq(&cn1->peeled, peeled ? peeled : &cn2->peeled);"
implicit_predicate,describe.c,130,+,-,"if (replace_name(e, prio, oid, &tag)){
    if (!e){
        e = xmalloc(sizeof (struct commit_name));
        oidcpy(&e->peeled, peeled);
        hashmap_entry_init(&e->entry, oidhash(peeled));
        hashmap_add(&names, &e->entry);
        e->path = NULL;
    }
    e->tag = tag;
    e->prio = prio;
    e->name_checked = 0;
    e->misnamed = 0;
    oidcpy(&e->oid, oid);
    free(e->path);
    e->path = xstrdup(path);
}
",,
implicit_predicate,describe.c,223,-,+,,21,"	add_to_known_names(all ? path + 5 : path + 10, &peeled, prio, oid);"
implicit_predicate,describe.c,286,+,+,all ? n->path + 5 : n->path,27,"		if (strcmp(n->tag->tag, all ? n->path + 5 : n->path)) {"
implicit_predicate,describe.c,295,+,-,"if (all)
    strbuf_addstr(dst, ""tags/"");
",,
implicit_predicate,describe.c,328,-,+,,21,"			append_suffix(0, n->tag ? get_tagged_oid(n->tag) : oid, dst);"
implicit_predicate,describe.c,336,+,-,"if (debug)
    fprintf(stderr, _(""No exact match on refs or tags, searching to describe\n""));
",,
implicit_predicate,describe.c,365,-,+,,7,		n = slot ? *slot : NULL;
implicit_predicate,describe.c,403,+,-,"if (debug)
    fprintf(stderr, _(""finished search at %s\n""), oid_to_hex(&c->object.oid));
",,
implicit_predicate,describe.c,417,+,-,"if (first_parent)
    break;
",,
implicit_predicate,describe.c,424,+,-,"if (always){
    strbuf_add_unique_abbrev(dst, cmit_oid, abbrev);
    if (suffix)
        strbuf_addstr(dst, suffix);

    return;
}
",,
implicit_predicate,describe.c,430,+,-,"if (unannotated_cnt)
    die(_(""No annotated tags can describe '%s'.\nHowever, there were unannotated tags: try --tags.""), oid_to_hex(cmit_oid));
else
    die(_(""No tags can describe '%s'.\nTry --always, or create some tags.""), oid_to_hex(cmit_oid));
",,
implicit_predicate,describe.c,449,+,-,"if (debug){
    static int label_width = -1;
    if (label_width < 0){
        int i, w;
        for (i = 0;i < ARRAY_SIZE(prio_names);i++){
            w = strlen(_(prio_names[i]));
            if (label_width < w)
                label_width = w;
        }
    }
    for (cur_match = 0;cur_match < match_cnt;cur_match++){
        struct possible_tag* t = &all_matches[cur_match];
        fprintf(stderr, "" %-*s %8d %s\n"", label_width, _(prio_names[t->name->prio]), t->depth, t->name->path);
    }
    fprintf(stderr, _(""traversed %lu commits\n""), seen_commits);
    if (gave_up_on){
        fprintf(stderr, _(""more than %i tags found; listed %i most recent\ngave up search at %s\n""), max_candidates, max_candidates, oid_to_hex(&gave_up_on->object.oid));
    }
}
",,
implicit_predicate,describe.c,536,+,-,"if (debug)
    fprintf(stderr, _(""describe %s\n""), arg);
",,
implicit_predicate,describe.c,565,+,+,unset ? DEFAULT_CANDIDATES : 0,9,	*val = unset ? DEFAULT_CANDIDATES : 0;
implicit_predicate,describe.c,615,+,-,<!!!>,,
implicit_predicate,describe.c,623,+,-,"if (always)
    strvec_push(&args, ""--always"");
",,
implicit_predicate,describe.c,632,+,-,"if (argc)
    strvec_pushv(&args, argv);
else
    strvec_push(&args, ""HEAD"");
",,
implicit_predicate,diagnose.c,36,+,+,unset ? DIAGNOSE_NONE : DIAGNOSE_STATS,15,		*diagnose = unset ? DIAGNOSE_NONE : DIAGNOSE_STATS;
implicit_predicate,diagnose.c,40,-,+,,10,"					    option_output ? option_output : """");"
implicit_predicate,diagnose.c,138,+,+,"at_root ? ""."" : path",16,"	dir = opendir(at_root ? ""."" : path);"
implicit_predicate,diagnose.c,156,+,+,"at_root ? ""."" : path",38,"		strbuf_add_absolute_path(&abspath, at_root ? ""."" : path);"
implicit_predicate,diagnose.c,241,+,-,"if (add_directory_to_archiver(&archiver_args, archive_dirs[i].path, archive_dirs[i].recursive)){
    res = error_errno(_(""could not add directory '%s' to archiver""), archive_dirs[i].path);
    goto diagnose_cleanup;
}
",,
implicit_predicate,diagnose.c,259,+,-,"if (res){
    error(_(""failed to write archive""));
    goto diagnose_cleanup;
}
",,
implicit_predicate,diff-delta.c,415,+,-,"if (inscnt){
    while (moff && ref_data[moff - 1] == data[-1]){
        msize++;
        moff--;
        data--;
        outpos--;
        if (--inscnt)
            continue;

        outpos--;
        inscnt--;
        break;
    }
    out[outpos - inscnt - 1] = inscnt;
    inscnt = 0;
}
",,
implicit_predicate,diff-delta.c,422,+,-,"if (--inscnt)
    continue;
",,
implicit_predicate,diff-delta.c,486,+,-,"if (inscnt)
    out[outpos - inscnt - 1] = inscnt;
",,
implicit_predicate,diff-lib.c,108,-,+,,24,"	unsigned ce_option = ((option & DIFF_RACY_IS_MODIFIED)
			      ? CE_MATCH_RACY_IS_DIRTY : 0);"
implicit_predicate,diff-lib.c,221,+,-,"if (wt_mode)
    pair->two->mode = wt_mode;
",,
implicit_predicate,diff-lib.c,222,+,-,"if (wt_mode)
    pair->two->mode = wt_mode;
",,
implicit_predicate,diff-lib.c,247,+,-,"if (changed){
    if (changed < 0){
        perror(ce->name);
        continue;
    }
    diff_addremove(&revs->diffopt, '-', ce->ce_mode, &ce->oid, !is_null_oid(&ce->oid), ce->name, 0);
    continue;
}else
    if (revs->diffopt.ita_invisible_in_index && ce_intent_to_add(ce)){
        newmode = ce_mode_from_stat(ce, st.st_mode);
        diff_addremove(&revs->diffopt, '+', newmode, null_oid(), 0, ce->name, 0);
        continue;
    }
",,
implicit_predicate,diff-lib.c,248,+,-,"if (changed){
    if (changed < 0){
        perror(ce->name);
        continue;
    }
    diff_addremove(&revs->diffopt, '-', ce->ce_mode, &ce->oid, !is_null_oid(&ce->oid), ce->name, 0);
    continue;
}else
    if (revs->diffopt.ita_invisible_in_index && ce_intent_to_add(ce)){
        newmode = ce_mode_from_stat(ce, st.st_mode);
        diff_addremove(&revs->diffopt, '+', newmode, null_oid(), 0, ce->name, 0);
        continue;
    }
",,
implicit_predicate,diff-lib.c,278,+,+,changed ? null_oid() : &ce->oid,13,		new_oid = changed ? null_oid() : &ce->oid;
implicit_predicate,diff-lib.c,279,+,-,changed ? null_oid() : &ce->oid,,
implicit_predicate,diff-lib.c,323,+,-,"if (changed){
    if (match_missing){
        *oidp = oid;
        *modep = mode;
        return 0;
    }
    return -1;
}
",,
implicit_predicate,diff-lib.c,324,+,-,"if (match_missing){
    *oidp = oid;
    *modep = mode;
    return 0;
}
",,
implicit_predicate,diff-lib.c,325,+,-,"if (match_missing){
    *oidp = oid;
    *modep = mode;
    return 0;
}
",,
implicit_predicate,diff-lib.c,333,+,-,"if (changed){
    mode = ce_mode_from_stat(ce, st.st_mode);
    oid = null_oid();
}
",,
implicit_predicate,diff-lib.c,334,+,-,"if (changed){
    mode = ce_mode_from_stat(ce, st.st_mode);
    oid = null_oid();
}
",,
implicit_predicate,diff-lib.c,396,+,-,"if (report_missing)
    diff_index_show_file(revs, ""-"", old_entry, &old_entry->oid, 1, old_entry->ce_mode, 0);
",,
implicit_predicate,diff-lib.c,397,+,-,"if (report_missing)
    diff_index_show_file(revs, ""-"", old_entry, &old_entry->oid, 1, old_entry->ce_mode, 0);
",,
implicit_predicate,diff-lib.c,536,-,+,,6,"			  idx ? idx : tree,"
implicit_predicate,diff-lib.c,639,+,-,"if (merge_base){
    diff_get_merge_base(revs, &oid);
    name = oid_to_hex_r(merge_base_hex, &oid);
}else{
    oidcpy(&oid, &ent->item->oid);
    name = ent->name;
}
",,
implicit_predicate,diff-lib.c,640,+,-,"if (merge_base){
    diff_get_merge_base(revs, &oid);
    name = oid_to_hex_r(merge_base_hex, &oid);
}else{
    oidcpy(&oid, &ent->item->oid);
    name = ent->name;
}
",,
implicit_predicate,diff-lib.c,647,+,-,"if (diff_cache(revs, &oid, name, cached))
    exit(128);
",,
implicit_predicate,diff-lib.c,648,+,-,"if (diff_cache(revs, &oid, name, cached))
    exit(128);
",,
implicit_predicate,diff-lib.c,650,+,+,"cached ? ""i/"" : ""w/""",49,"	diff_set_mnemonic_prefix(&revs->diffopt, ""c/"", cached ? ""i/"" : ""w/"");"
implicit_predicate,diff-lib.c,651,+,-,"cached ? ""i/"" : ""w/""",,
implicit_predicate,diff-no-index.c,137,+,+,recursing ? NULL : &special1,30,"	if (get_mode(name1, &mode1, recursing ? NULL : &special1) ||"
implicit_predicate,diff-no-index.c,138,+,+,recursing ? NULL : &special2,30,"	    get_mode(name2, &mode2, recursing ? NULL : &special2))"
implicit_predicate,diff-no-index.c,251,-,+,,22,"	strbuf_addstr(path, tail ? tail + 1 : file);"
implicit_predicate,diff-no-index.c,284,+,-,"if (isdir0){
    append_basename(replacement, path[0], path[1]);
    path[0] = replacement->buf;
}else{
    append_basename(replacement, path[1], path[0]);
    path[1] = replacement->buf;
}
",,
implicit_predicate,diff-no-index.c,319,+,-,"if (implicit_no_index)
    warning(_(""Not a git repository. Use --no-index to compare two paths outside a working tree""));
",,
implicit_predicate,diff-tree.c,188,+,-,"if (merge_base){
    struct object_id oid;
    diff_get_merge_base(opt, &oid);
    tree1 = lookup_object(the_repository, &oid);
}else
    if (tree2->flags & UNINTERESTING){
        SWAP(tree2, tree1);
    }
",,
implicit_predicate,diff-tree.c,201,+,-,"if (read_stdin){
    int saved_nrl = 0;
    int saved_dcctc = 0;
    opt->diffopt.rotate_to_strict = 0;
    opt->diffopt.no_free = 1;
    if (opt->diffopt.detect_rename){
        if (the_repository->index->cache)
            repo_read_index(the_repository);

        opt->diffopt.setup |= DIFF_SETUP_USE_SIZE_CACHE;
    }
    while (fgets(line, sizeof (line), stdin)){
        struct object_id oid;
        if (get_oid_hex(line, &oid)){
            fputs(line, stdout);
            fflush (stdout);
        }else{
            diff_tree_stdin(line);
            if (saved_nrl < opt->diffopt.needed_rename_limit)
                saved_nrl = opt->diffopt.needed_rename_limit;

            if (opt->diffopt.degraded_cc_to_c)
                saved_dcctc = 1;
        }
    }
    opt->diffopt.degraded_cc_to_c = saved_dcctc;
    opt->diffopt.needed_rename_limit = saved_nrl;
    opt->diffopt.no_free = 0;
    diff_free(&opt->diffopt);
}
",,
implicit_predicate,diff.c,41,-,+,,9,	return entry->path ? entry->path : entry->name;
implicit_predicate,diff.c,106,-,+,,8,"		     blob[0]->path ? blob[0]->path : path,"
implicit_predicate,diff.c,143,+,-,"if (*params_copy)
    string_list_split_in_place(&params, params_copy, "","", -1);
",,
implicit_predicate,diff.c,188,+,-,"if (merge_base){
    diff_get_merge_base(revs, &mb_oid);
    oid[0] = &mb_oid;
    oid[1] = &revs->pending.objects[1].item->oid;
}else{
    int swap = 0;
    if (ent1->item->flags & UNINTERESTING)
        swap = 1;

    oid[swap] = &ent0->item->oid;
    oid[1 - swap] = &ent1->item->oid;
}
",,
implicit_predicate,diff.c,211,-,+,,9,"	return git_config_bool(var,value) ? DIFF_DETECT_RENAME : 0;"
implicit_predicate,diff.c,249,+,-,"if (parse_one_token(&arg, ""none""))
    val = 0;
else
    if (parse_one_token(&arg, ""default""))
        val = WSEH_NEW;
    else
        if (parse_one_token(&arg, ""all""))
            val = WSEH_NEW | WSEH_OLD | WSEH_CONTEXT;
        else
            if (parse_one_token(&arg, ""new""))
                val |= WSEH_NEW;
            else
                if (parse_one_token(&arg, ""old""))
                    val |= WSEH_OLD;
                else
                    if (parse_one_token(&arg, ""context""))
                        val |= WSEH_CONTEXT;
                    else{
                        return -1 - (int)(arg - orig_arg);
                    }
",,
implicit_predicate,diff.c,251,+,-,"if (parse_one_token(&arg, ""default""))
    val = WSEH_NEW;
else
    if (parse_one_token(&arg, ""all""))
        val = WSEH_NEW | WSEH_OLD | WSEH_CONTEXT;
    else
        if (parse_one_token(&arg, ""new""))
            val |= WSEH_NEW;
        else
            if (parse_one_token(&arg, ""old""))
                val |= WSEH_OLD;
            else
                if (parse_one_token(&arg, ""context""))
                    val |= WSEH_CONTEXT;
                else{
                    return -1 - (int)(arg - orig_arg);
                }
",,
implicit_predicate,diff.c,253,+,-,"if (parse_one_token(&arg, ""all""))
    val = WSEH_NEW | WSEH_OLD | WSEH_CONTEXT;
else
    if (parse_one_token(&arg, ""new""))
        val |= WSEH_NEW;
    else
        if (parse_one_token(&arg, ""old""))
            val |= WSEH_OLD;
        else
            if (parse_one_token(&arg, ""context""))
                val |= WSEH_CONTEXT;
            else{
                return -1 - (int)(arg - orig_arg);
            }
",,
implicit_predicate,diff.c,255,+,-,"if (parse_one_token(&arg, ""new""))
    val |= WSEH_NEW;
else
    if (parse_one_token(&arg, ""old""))
        val |= WSEH_OLD;
    else
        if (parse_one_token(&arg, ""context""))
            val |= WSEH_CONTEXT;
        else{
            return -1 - (int)(arg - orig_arg);
        }
",,
implicit_predicate,diff.c,257,+,-,"if (parse_one_token(&arg, ""old""))
    val |= WSEH_OLD;
else
    if (parse_one_token(&arg, ""context""))
        val |= WSEH_CONTEXT;
    else{
        return -1 - (int)(arg - orig_arg);
    }
",,
implicit_predicate,diff.c,259,+,-,"if (parse_one_token(&arg, ""context""))
    val |= WSEH_CONTEXT;
else{
    return -1 - (int)(arg - orig_arg);
}
",,
implicit_predicate,diff.c,447,+,-,"if (parse_submodule_params(&default_diff_options, value))
    warning(_(""Unknown value for 'diff.submodule' config variable: '%s'""), value);
",,
implicit_predicate,diff.c,480,+,-,"if (no_index)
    exit(diff_no_index(&rev, no_index == DIFF_NO_INDEX_IMPLICIT, argc, argv));
",,
implicit_predicate,diff.c,498,+,-,"if (nongit)
    die(_(""Not a git repository""));
",,
implicit_predicate,diff.c,517,+,-,"if (parse_dirstat_params(&default_diff_options, value, &errmsg))
    warning(_(""Found errors in 'diff.dirstat' config variable:\n%s""), errmsg.buf);
",,
implicit_predicate,diff.c,537,+,-,"if (need_one + need_two){
    strbuf_addch(&res, '""');
    quote_c_style(one, &res, NULL, CQUOTE_NODQ);
    quote_c_style(two, &res, NULL, CQUOTE_NODQ);
    strbuf_addch(&res, '""');
}else{
    strbuf_addstr(&res, one);
    strbuf_addstr(&res, two);
}
",,
implicit_predicate,diff.c,554,+,-,"if (done_preparing)
    return external_diff_cmd;
",,
implicit_predicate,diff.c,586,+,-,"if (paths)
    usage(builtin_diff_usage);
",,
implicit_predicate,diff.c,594,+,-,"if (blobs)
    usage(builtin_diff_usage);
else
    if (ent.nr == 1)
        builtin_diff_index(&rev, argc, argv);
    else
        if (ent.nr == 2){
            if (sdiff.warn)
                warning(_(""%s...%s: multiple merge bases, using %s""), sdiff.left, sdiff.right, sdiff.base);

            builtin_diff_tree(&rev, argc, argv, &ent.objects[0], &ent.objects[1]);
        }else
            builtin_diff_combined(&rev, argc, argv, ent.objects, ent.nr, first_non_parent);
",,
implicit_predicate,diff.c,599,+,-,"if (sdiff.warn)
    warning(_(""%s...%s: multiple merge bases, using %s""), sdiff.left, sdiff.right, sdiff.base);
",,
implicit_predicate,diff.c,614,+,-,"if (completely_empty)
    return 0;
",,
implicit_predicate,diff.c,706,+,-,"if (has_trailing_newline)
    len--;
",,
implicit_predicate,diff.c,710,+,-,"if (has_trailing_carriage_return)
    len--;
",,
implicit_predicate,diff.c,726,+,-,"if (first)
    fputc(first, file);
",,
implicit_predicate,diff.c,742,+,-,"if (needs_reset)
    fputs(reset, file);
",,
implicit_predicate,diff.c,744,+,-,"if (has_trailing_carriage_return)
    fputc('\r', file);
",,
implicit_predicate,diff.c,746,+,-,"if (has_trailing_newline)
    fputc('\n', file);
",,
implicit_predicate,diff.c,844,-,+,,12,"	f->line = e->line ? xmemdupz(e->line, e->len) : NULL;"
implicit_predicate,diff.c,881,+,-,"while (1){
    if (s[off] == ' '){
        width++;
        off++;
    }else
        if (s[off] == '\t'){
            width += tab_width - (width % tab_width);
            while (s[++off] == '\t')
                width += tab_width;
        }else{
            break;
        }
}
",,
implicit_predicate,diff.c,1076,+,-,"if (match){
    pmb[j] = pmb[i];
    pmb[j++].match = cur;
}
",,
implicit_predicate,diff.c,1221,+,-,"if (pmb_nr)
    moved_symbol = l->s;
else
    moved_symbol = DIFF_SYMBOL_BINARY_DIFF_HEADER;
",,
implicit_predicate,diff.c,1229,+,-,"if (pmb_nr){
    block_length++;
    l->flags |= DIFF_SYMBOL_MOVED_LINE;
    if (flipped_block && o->color_moved != COLOR_MOVED_BLOCKS)
        l->flags |= DIFF_SYMBOL_MOVED_LINE_ALT;
}
",,
implicit_predicate,diff.c,1319,+,-,"if (blank_at_eof)
    emit_line_0(o, ws, NULL, 0, reset, sign, line, len);
else{
    emit_line_0(o, set_sign ? set_sign : set, NULL, !!set_sign, reset, sign, """", 0);
    ws_check_emit(line, len, ws_rule, o->file, set, reset, ws);
}
",,
implicit_predicate,diff.c,1324,-,+,,18,"		emit_line_0(o, set_sign ? set_sign : set, NULL, !!set_sign, reset,"
implicit_predicate,diff.c,1502,-,+,,4,"			strchr(line, ' ') ? ""\t"" : """");"
implicit_predicate,diff.c,1509,-,+,,4,"			strchr(line, ' ') ? ""\t"" : """");"
implicit_predicate,diff.c,1636,+,-,"if (new_blank_line_at_eof(ecbdata, line, len))
    flags |= DIFF_SYMBOL_CONTENT_BLANK_LINE_EOF;
",,
implicit_predicate,diff.c,1663,+,+,"ecbdata->color_diff ? GIT_COLOR_REVERSE : """"",24,"	const char *reverse = ecbdata->color_diff ? GIT_COLOR_REVERSE : """";"
implicit_predicate,diff.c,1766,-,+,,9,		len = endp ? (endp - data + 1) : size;
implicit_predicate,diff.c,1852,+,-,"if (lc_b)
    emit_rewrite_lines(&ecbdata, '+', data_two, size_two);
",,
implicit_predicate,diff.c,1919,+,-,"if (print)
    strbuf_addstr(&sb, diff_line_prefix(o));
",,
implicit_predicate,diff.c,1928,-,+,,25,"			strbuf_add(&sb, buf, p ? p - buf : count);"
implicit_predicate,diff.c,2061,-,+,,11,			*end = p ? p - buffer->ptr : match[0].rm_eo + *begin;
implicit_predicate,diff.c,2169,+,-,"if (color_words_output_graph_prefix(diff_words))
    emit_diff_symbol(diff_words->opt, DIFF_SYMBOL_WORD_DIFF, line_prefix, strlen(line_prefix), 0);
",,
implicit_predicate,diff.c,2472,+,+,pfx_length ? 1 : 0,26,	pfx_adjust_for_slash = (pfx_length ? 1 : 0);
implicit_predicate,diff.c,2496,+,-,"if (pfx_length + sfx_length){
    strbuf_add(name, a, pfx_length);
    strbuf_addch(name, '{');
}
",,
implicit_predicate,diff.c,2503,+,-,"if (pfx_length + sfx_length){
    strbuf_addch(name, '}');
    strbuf_add(name, a + len_a - sfx_length, sfx_length);
}
",,
implicit_predicate,diff.c,2652,-,+,,10,	count = options->stat_count ? options->stat_count : data->nr;
implicit_predicate,diff.c,2731,-,+,,11,		width = options->stat_width ? options->stat_width : 80;
implicit_predicate,diff.c,2991,+,-,"while (dir->nr){
    struct dirstat_file* f = dir->files;
    int namelen = strlen(f->name);
    unsigned long changes;
    char* slash;
    if (namelen < baselen)
        break;

    if (memcmp(f->name, base, baselen))
        break;

    slash = strchr(f->name + baselen, '/');
    if (slash){
        int newbaselen = slash + 1 - f->name;
        changes = gather_dirstat(opt, dir, changed, f->name, newbaselen);
        sources++;
    }else{
        changes = f->changed;
        dir->files++;
        dir->nr--;
        sources += 2;
    }
    sum_changes += changes;
}
",,
implicit_predicate,diff.c,3022,+,-,"if (sum_changes){
    int permille = sum_changes * 1000 / changed;
    if (permille >= dir->permille){
        fprintf(opt->file, ""%s%4d.%01d%% %.*s\n"", line_prefix, permille / 10, permille % 10, baselen, base);
        if (!dir->cumulative)
            return 0;
    }
}
",,
implicit_predicate,diff.c,3082,-,+,,10,		name = p->two->path ? p->two->path : p->one->path;
implicit_predicate,diff.c,3264,+,-,"if (is_conflict_marker(line + 1, marker_size, len - 1)){
    data->status |= 1;
    fprintf(data->o->file, ""%s%s:%d: leftover conflict marker\n"", line_prefix, data->filename, data->lineno);
}
",,
implicit_predicate,diff.c,3359,+,-,"while (data_size){
    int len;
    int bytes = (52 < data_size) ? 52 : data_size;
    char line[71];
    data_size -= bytes;
    if (bytes <= 26)
        line[0] = bytes + 'A' - 1;
    else
        line[0] = bytes - 26 + 'a' - 1;

    encode_85(line + 1, cp, bytes);
    cp = (char*)cp + bytes;
    len = strlen(line);
    line[len++] = '\n';
    line[len] = '\0';
    emit_diff_symbol(o, DIFF_SYMBOL_BINARY_DIFF_BODY, line, len, 0);
}
",,
implicit_predicate,diff.c,3418,-,+,,9,	return one->driver->funcname.pattern ? &one->driver->funcname : NULL;
implicit_predicate,diff.c,3552,-,+,,34,"		show_submodule_diff_summary(o, one->path ? one->path : two->path,"
implicit_predicate,diff.c,3560,-,+,,33,"		show_submodule_inline_diff(o, one->path ? one->path : two->path,"
implicit_predicate,diff.c,3579,+,-,"if (diff_filepair_is_phoney(one, two)){
    lbl[0] = a_one;
    lbl[1] = b_two;
}
",,
implicit_predicate,diff.c,3648,+,-,"if (must_show_header)
    emit_diff_symbol(o, DIFF_SYMBOL_HEADER, header.buf, header.len, 0);
",,
implicit_predicate,diff.c,3669,+,-,"if (must_show_header)
    emit_diff_symbol(o, DIFF_SYMBOL_HEADER, header.buf, header.len, 0);
",,
implicit_predicate,diff.c,3695,+,-,"if (must_show_header){
    emit_diff_symbol(o, DIFF_SYMBOL_HEADER, header.buf, header.len, 0);
    strbuf_reset(&header);
}
",,
implicit_predicate,diff.c,3834,+,-,"if (complete_rewrite){
    diff_populate_filespec(o->repo, one, NULL);
    diff_populate_filespec(o->repo, two, NULL);
    data->deleted = count_lines(one->data, one->size);
    data->added = count_lines(two->data, two->size);
}else
    if (may_differ){
        xpparam_t xpp;
        xdemitconf_t xecfg;
        if (fill_mmfile(o->repo, &mf1, one) < 0 || fill_mmfile(o->repo, &mf2, two) < 0)
            die(""unable to read files to diff"");

        memset(&xpp, 0, sizeof (xpp));
        memset(&xecfg, 0, sizeof (xecfg));
        xpp.flags = o->xdl_opts;
        xpp.ignore_regex = o->ignore_regex;
        xpp.ignore_regex_nr = o->ignore_regex_nr;
        xpp.anchors = o->anchors;
        xpp.anchors_nr = o->anchors_nr;
        xecfg.ctxlen = o->context;
        xecfg.interhunkctxlen = o->interhunkcontext;
        xecfg.flags = XDL_EMIT_NO_HUNK_HDR;
        if (xdi_diff_outf(&mf1, &mf2, NULL, diffstat_consume, diffstat, &xpp, &xecfg))
            die(""unable to generate diffstat for %s"", one->path);

        if (DIFF_FILE_VALID(one) && DIFF_FILE_VALID(two)){
            struct diffstat_file* file = diffstat->files[diffstat->nr - 1];
            if ((p->status == DIFF_STATUS_MODIFIED) && !file->added && !file->deleted && one->mode == two->mode){
                free_diffstat_file(file);
                diffstat->nr--;
            }
        }
    }
",,
implicit_predicate,diff.c,3841,+,-,"if (may_differ){
    xpparam_t xpp;
    xdemitconf_t xecfg;
    if (fill_mmfile(o->repo, &mf1, one) < 0 || fill_mmfile(o->repo, &mf2, two) < 0)
        die(""unable to read files to diff"");

    memset(&xpp, 0, sizeof (xpp));
    memset(&xecfg, 0, sizeof (xecfg));
    xpp.flags = o->xdl_opts;
    xpp.ignore_regex = o->ignore_regex;
    xpp.ignore_regex_nr = o->ignore_regex_nr;
    xpp.anchors = o->anchors;
    xpp.anchors_nr = o->anchors_nr;
    xecfg.ctxlen = o->context;
    xecfg.interhunkctxlen = o->interhunkcontext;
    xecfg.flags = XDL_EMIT_NO_HUNK_HDR;
    if (xdi_diff_outf(&mf1, &mf2, NULL, diffstat_consume, diffstat, &xpp, &xecfg))
        die(""unable to generate diffstat for %s"", one->path);

    if (DIFF_FILE_VALID(one) && DIFF_FILE_VALID(two)){
        struct diffstat_file* file = diffstat->files[diffstat->nr - 1];
        if ((p->status == DIFF_STATUS_MODIFIED) && !file->added && !file->deleted && one->mode == two->mode){
            free_diffstat_file(file);
            diffstat->nr--;
        }
    }
}
",,
implicit_predicate,diff.c,3903,-,+,,18,	data.filename = name_b ? name_b : name_a;
implicit_predicate,diff.c,3943,+,-,"if (blank_at_eof){
    static char* err;
    if (!err)
        err = whitespace_error_string(WS_BLANK_AT_EOF);

    fprintf(o->file, ""%s:%d: %s.\n"", data.filename, blank_at_eof, err);
    data.status = 1;
}
",,
implicit_predicate,diff.c,3956,+,-,"if (data.status)
    o->flags.check_failed = 1;
",,
implicit_predicate,diff.c,3981,+,-,"if (mode){
    spec->mode = canon_mode(mode);
    oidcpy(&spec->oid, oid);
    spec->oid_valid = oid_valid;
}
",,
implicit_predicate,diff.c,4086,+,-,"if (size_only){
    s->data = NULL;
    strbuf_release(&buf);
}else{
    s->data = strbuf_detach(&buf, NULL);
    s->should_free = 1;
}
",,
implicit_predicate,diff.c,4105,-,+,,18,	int size_only = options ? options->check_size_only : 0;
implicit_predicate,diff.c,4106,-,+,,21,	int check_binary = options ? options->check_binary : 0;
implicit_predicate,diff.c,4225,+,-,"if (size_only)
    return 0;
",,
implicit_predicate,diff.c,4327,-,+,,13,"				       (one->oid_valid ?
					&one->oid : null_oid()),"
implicit_predicate,diff.c,4329,-,+,,13,"				       (one->oid_valid ?
					one->mode : S_IFLNK));"
implicit_predicate,diff.c,4428,+,-,"if (abbrev)
    hex[abbrev] = '\0';
",,
implicit_predicate,diff.c,4491,-,+,,16,		int abbrev = o->abbrev ? o->abbrev : DEFAULT_ABBREV;
implicit_predicate,diff.c,4542,-,+,,14,		xfrm_msg = msg->len ? msg->buf : NULL;
implicit_predicate,diff.c,4553,-,+,,22,"		builtin_diff(name, other ? other : name,"
implicit_predicate,diff.c,4607,-,+,,11,"	other = (strcmp(name, two->path) ? two->path : NULL);"
implicit_predicate,diff.c,4672,-,+,,11,"	other = (strcmp(name, p->two->path) ? p->two->path : NULL);"
implicit_predicate,diff.c,4696,-,+,,11,"	other = (strcmp(name, p->two->path) ? p->two->path : NULL);"
implicit_predicate,diff.c,4697,-,+,,14,	attr_path = other ? other : name;
implicit_predicate,diff.c,4736,+,-,"if (diff_indent_heuristic)
    DIFF_XDL_SET(options, INDENT_HEURISTIC);
",,
implicit_predicate,diff.c,4744,+,-,"if (diff_no_prefix){
    diff_set_noprefix(options);
}else
    if (!diff_mnemonic_prefix){
        diff_set_default_prefix(options);
    }
",,
implicit_predicate,diff.c,4796,+,-,"if (die_on_error)
    die(_(""--follow requires exactly one pathspec""));
",,
implicit_predicate,diff.c,4803,+,-,"if (forbidden_magic){
    if (die_on_error){
        struct strbuf sb = STRBUF_INIT;
        pathspec_magic_names(forbidden_magic, &sb);
        die(_(""pathspec magic not supported by --follow: %s""), sb.buf);
    }
    return 0;
}
",,
implicit_predicate,diff.c,4804,+,-,"if (die_on_error){
    struct strbuf sb = STRBUF_INIT;
    pathspec_magic_names(forbidden_magic, &sb);
    die(_(""pathspec magic not supported by --follow: %s""), sb.buf);
}
",,
implicit_predicate,diff.c,4979,+,-,"if (*end)
    return error(_(""invalid --stat value: %s""), value);
",,
implicit_predicate,diff.c,4984,+,-,"if (*end)
    return error(_(""%s expects a numerical value""), opt->long_name);
",,
implicit_predicate,diff.c,4989,+,-,"if (*end)
    return error(_(""%s expects a numerical value""), opt->long_name);
",,
implicit_predicate,diff.c,4994,+,-,"if (*end)
    return error(_(""%s expects a numerical value""), opt->long_name);
",,
implicit_predicate,diff.c,4999,+,-,"if (*end)
    return error(_(""%s expects a numerical value""), opt->long_name);
",,
implicit_predicate,diff.c,5017,+,-,"if (parse_dirstat_params(options, params, &errmsg))
    die(_(""Failed to parse --dirstat/-X option parameter:\n%s""), errmsg.buf);
",,
implicit_predicate,diff.c,5054,+,-,"if (negate)
    opt->filter_not |= bit;
else
    opt->filter |= bit;
",,
implicit_predicate,diff.c,5169,+,-,"if (unset){
    options->color_moved = COLOR_MOVED_NO;
}else
    if (!arg){
        if (diff_color_moved_default)
            options->color_moved = diff_color_moved_default;

        if (options->color_moved == COLOR_MOVED_NO)
            options->color_moved = COLOR_MOVED_DEFAULT;
    }else{
        int cm = parse_color_moved(arg);
        if (cm < 0)
            return error(_(""bad --color-moved argument: %s""), arg);

        options->color_moved = cm;
    }
",,
implicit_predicate,diff.c,5172,+,-,"if (diff_color_moved_default)
    options->color_moved = diff_color_moved_default;
",,
implicit_predicate,diff.c,5191,+,-,"if (unset){
    options->color_moved_ws_handling = 0;
    return 0;
}
",,
implicit_predicate,diff.c,5221,+,-,"if (unset){
    options->flags.stat_with_summary = 0;
}else{
    options->flags.stat_with_summary = 1;
    options->output_format &= ~DIFF_FORMAT_NO_OUTPUT;
    options->output_format |= DIFF_FORMAT_DIFFSTAT;
}
",,
implicit_predicate,diff.c,5238,+,-,"if (set_diff_algorithm(options, arg))
    return error(_(""option diff-algorithm accepts \""myers\"", \""minimal\"", \""patience\"" and \""histogram\""""));
",,
implicit_predicate,diff.c,5276,-,+,,29,"	parse_dirstat_opt(options, arg ? arg : """");"
implicit_predicate,diff.c,5322,+,-,"if (unset){
    options->flags.follow_renames = 0;
    options->flags.default_follow_renames = 0;
}else{
    options->flags.follow_renames = 1;
}
",,
implicit_predicate,diff.c,5475,+,-,"if (parse_submodule_params(options, arg))
    return error(_(""failed to parse --submodule option parameter: '%s'""), arg);
",,
implicit_predicate,diff.c,5487,+,-,"if (unset){
    options->flags.allow_textconv = 0;
}else{
    options->flags.allow_textconv = 1;
    options->flags.textconv_set_via_cmdline = 1;
}
",,
implicit_predicate,diff.c,5506,+,-,"if (*s)
    return error(_(""%s expects a numerical value""), ""--unified"");
",,
implicit_predicate,diff.c,5882,+,+,dot ? scale * 100 : 100,12,			scale = dot ? scale*100 : 100;
implicit_predicate,diff.c,5988,+,+,line_termination ? '\t' : '\0',31,	int inter_name_termination = line_termination ? '\t' : '\0';
implicit_predicate,diff.c,6014,-,+,,12,		name_a = p->one->mode ? p->one->path : p->two->path;
implicit_predicate,diff.c,6084,+,-,"if (diff_unmodified_pair(p))
    return;
",,
implicit_predicate,diff.c,6097,+,-,"if (diff_unmodified_pair(p))
    return;
",,
implicit_predicate,diff.c,6117,+,-,"if (include_conflict_headers)
    return 0;
",,
implicit_predicate,diff.c,6276,+,-,"if (show_name){
    strbuf_addch(&sb, ' ');
    quote_c_style(p->two->path, &sb, NULL, 0);
}
",,
implicit_predicate,diff.c,6420,+,-,"if (diff_unmodified_pair(p))
    continue;
",,
implicit_predicate,diff.c,6452,+,-,"if (diff_header_only){
}else
    if (diff_filespec_is_binary(options->repo, p->one) || diff_filespec_is_binary(options->repo, p->two)){
        the_hash_algo->update_fn(&ctx, oid_to_hex(&p->one->oid), the_hash_algo->hexsz);
        the_hash_algo->update_fn(&ctx, oid_to_hex(&p->two->oid), the_hash_algo->hexsz);
    }else{
        if (p->one->mode == 0){
            patch_id_add_string(&ctx, ""---/dev/null"");
            patch_id_add_string(&ctx, ""+++b/"");
            the_hash_algo->update_fn(&ctx, p->two->path, len2);
        }else
            if (p->two->mode == 0){
                patch_id_add_string(&ctx, ""---a/"");
                the_hash_algo->update_fn(&ctx, p->one->path, len1);
                patch_id_add_string(&ctx, ""+++/dev/null"");
            }else{
                patch_id_add_string(&ctx, ""---a/"");
                the_hash_algo->update_fn(&ctx, p->one->path, len1);
                patch_id_add_string(&ctx, ""+++b/"");
                the_hash_algo->update_fn(&ctx, p->two->path, len2);
            }

        if (fill_mmfile(options->repo, &mf1, p->one) < 0 || fill_mmfile(options->repo, &mf2, p->two) < 0)
            return error(""unable to read files to diff"");

        xpp.flags = 0;
        xecfg.ctxlen = 3;
        xecfg.flags = XDL_EMIT_NO_HUNK_HDR;
        if (xdi_diff_outf(&mf1, &mf2, NULL, patch_id_consume, &data, &xpp, &xecfg))
            return error(""unable to generate patch-id diff for %s"", p->one->path);
    }
",,
implicit_predicate,diff.c,6542,+,-,"if (degraded_cc)
    warning(_(degrade_cc_to_c_warning));
else
    if (needed)
        warning(_(rename_limit_warning));
    else
        return;
",,
implicit_predicate,diff.c,6544,+,-,"if (needed)
    warning(_(rename_limit_warning));
else
    return;
",,
implicit_predicate,diff.c,6568,-,+,,16,		char *path = p->one->path ? p->one->path : p->two->path;
implicit_predicate,diff.c,6617,+,-,"if (check_pair_status(p))
    diff_flush_patch(p, o);
",,
implicit_predicate,diff.c,6695,+,-,"if (check_pair_status(p))
    flush_one_pair(p, options);
",,
implicit_predicate,diff.c,6731,+,-,"if (separator){
    emit_diff_symbol(options, DIFF_SYMBOL_SEPARATOR, NULL, 0, 0);
    if (options->stat_sep)
        emit_diff_symbol(options, DIFF_SYMBOL_STAT_SEP, NULL, 0, 0);
}
",,
implicit_predicate,diff.c,6759,+,-,"if (check_pair_status(p))
    diff_flush_patch(p, options);
",,
implicit_predicate,diff.c,6812,+,-,"if (found)
    return;
",,
implicit_predicate,diff.c,6827,+,-,"if (match_filter(options, p))
    diff_q(&outq, p);
else
    diff_free_filepair(p);
",,
implicit_predicate,diff.c,6923,-,+,,11,	name_a = a->one ? a->one->path : a->two->path;
implicit_predicate,diff.c,6924,-,+,,11,	name_b = b->one ? b->one->path : b->two->path;
implicit_predicate,diff.c,7077,+,-,"if (check_pair_status(p))
    diff_flush_stat(p, options, diffstat);
",,
implicit_predicate,diffcore-delta.c,66,+,-,"while (1){
    struct spanhash* h = &(new_spanhash->data[bucket++]);
    if (!h->cnt){
        h->hashval = o->hashval;
        h->cnt = o->cnt;
        new_spanhash->free--;
        break;
    }
    if (sz <= bucket)
        bucket = 0;
}
",,
implicit_predicate,diffcore-delta.c,90,+,-,"while (1){
    h = &(top->data[bucket++]);
    if (!h->cnt){
        h->hashval = hashval;
        h->cnt = cnt;
        top->free--;
        if (top->free < 0)
            return spanhash_rehash(top);

        return top;
    }
    if (h->hashval == hashval){
        h->cnt += cnt;
        return top;
    }
    if (lim <= bucket)
        bucket = 0;
}
",,
implicit_predicate,diffcore-delta.c,142,+,-,"while (sz){
    unsigned int c = *buf++;
    unsigned int old_1 = accum1;
    sz--;
    if (is_text && c == '\r' && sz && *buf == '\n')
        continue;

    accum1 = (accum1 << 7) ^ (accum2 >> 25);
    accum2 = (accum2 << 7) ^ (old_1 >> 25);
    accum1 += c;
    if (++n < 64 && c != '\n')
        continue;

    hashval = (accum1 + accum2 * 0x61) % HASHBASE;
    hash = add_spanhash(hash, hashval, n);
    n = 0;
    accum1 = accum2 = 0;
}
",,
implicit_predicate,diffcore-delta.c,204,+,-,"while (d->cnt){
    if (d->hashval >= s->hashval)
        break;

    la += d->cnt;
    d++;
}
",,
implicit_predicate,diffcore-delta.c,224,+,-,"while (d->cnt){
    la += d->cnt;
    d++;
}
",,
implicit_predicate,diffcore-pickaxe.c,30,+,-,"if (data->hit)
    BUG(""Already matched in diffgrep_consume! Broken xdiff_emit_line_fn?"");
",,
implicit_predicate,diffcore-pickaxe.c,101,+,-,"while (sz){
    struct kwsmatch kwsm;
    size_t offset = kwsexec(kws, data, sz, &kwsm);
    if (offset == -1)
        break;

    sz -= offset + kwsm.size[0];
    data += offset + kwsm.size[0];
    cnt++;
    if (limit && cnt == limit)
        return cnt;
}
",,
implicit_predicate,diffcore-pickaxe.c,121,-,+,,20,"	unsigned int c1 = one ? contains(one, regexp, kws, 0) : 0;"
implicit_predicate,diffcore-pickaxe.c,122,-,+,,20,"	unsigned int c2 = two ? contains(two, regexp, kws, c1 + 1) : 0;"
implicit_predicate,diffcore-pickaxe.c,222,+,-,"if (err){
    char errbuf[1024];
    regerror(err, regex, errbuf, 1024);
    die(""invalid regex: %s"", errbuf);
}
",,
implicit_predicate,diffcore-pickaxe.c,272,-,+,,19,"			kws = kwsalloc(o->pickaxe_opts & DIFF_PICKAXE_IGNORE_CASE
				       ? tolower_trans_tbl : NULL);"
implicit_predicate,diffcore-rename.c,32,-,+,,12,"	int idx = break_idx ? strintmap_get(break_idx, p->one->path) : -1;"
implicit_predicate,diffcore-rename.c,380,-,+,,9,"	return slash ? xstrndup(filename, slash - filename) : xstrdup("""");"
implicit_predicate,diffcore-rename.c,488,+,-,"while (1){
    int drd_flag = NOT_RELEVANT;
    dirname_munge(old_dir);
    if (info->relevant_source_dirs && !strintmap_contains(info->relevant_source_dirs, old_dir))
        break;

    dirname_munge(new_dir);
    if (!first_time_in_loop){
        char* old_sub_dir = strchr(old_dir, '\0') + 1;
        char* new_sub_dir = strchr(new_dir, '\0') + 1;
        if (!*new_dir){
            if (new_dir_first_char != old_sub_dir[0] || strcmp(old_sub_dir + 1, new_sub_dir))
                break;
        }else{
            if (strcmp(old_sub_dir, new_sub_dir))
                break;
        }
    }
    if (dirs_removed)
        drd_flag = strintmap_get(dirs_removed, old_dir);

    if (drd_flag == RELEVANT_FOR_SELF || first_time_in_loop)
        increment_count(info, old_dir, new_dir);

    first_time_in_loop = 0;
    if (drd_flag == NOT_RELEVANT)
        break;

    if (!*old_dir || !*new_dir)
        break;
}
",,
implicit_predicate,diffcore-rename.c,749,-,+,,9,	return base ? base + 1 : filename;
implicit_predicate,diffcore-rename.c,977,+,-,"if (rename_dst[i].is_rename)
    continue;
",,
implicit_predicate,diffcore-rename.c,1144,+,-,"if (dst->is_rename)
    continue;
",,
implicit_predicate,diffcore-rename.c,1305,+,-,"while (1){
    char* freeme = dir;
    int res = strintmap_get(dirs_removed, dir);
    if (res == NOT_RELEVANT)
        break;

    if (res == RELEVANT_FOR_SELF){
        removable = 0;
        break;
    }
    assert(res == RELEVANT_FOR_ANCESTOR);
    dir = get_dirname(dir);
    free(freeme);
}
",,
implicit_predicate,diffcore-rename.c,1323,+,-,"if (removable){
    strintmap_set(relevant_sources, one->path, RELEVANT_NO_MORE);
    continue;
}
",,
implicit_predicate,diffcore-rename.c,1449,+,-,"if (want_copies){
    p->one->rename_used++;
    register_rename_src(p);
}
",,
implicit_predicate,diffcore-rename.c,1584,+,-,"if (rename_dst[i].is_rename)
    continue;
",,
implicit_predicate,diffcore-rename.c,1627,+,-,"if (want_copies)
    rename_count += find_renames(mx, dst_cnt, minimum_score, 1, &info, dirs_removed);
",,
implicit_predicate,diffcore-rename.c,1672,+,-,"if (dst->is_rename)
    pair_to_free = p;
",,
implicit_predicate,difftool.c,190,+,+,is_right ? e->right : e->left,10,"	strlcpy(is_right ? e->right : e->left, content, PATH_MAX);"
implicit_predicate,difftool.c,208,-,+,,25,"	return strcmp(a->path, key ? key : b->path);"
implicit_predicate,difftool.c,348,+,-,"if (*entry->left)
    write_file_in_directory(ldir, ldir_len, entry->path, entry->left);
",,
implicit_predicate,difftool.c,350,+,-,"if (*entry->right)
    write_file_in_directory(rdir, rdir_len, entry->path, entry->right);
",,
implicit_predicate,difftool.c,384,-,+,,36,"	strbuf_add_absolute_path(&tmpdir, tmp ? tmp : ""/tmp"");"
implicit_predicate,difftool.c,478,+,-,"if (checkout_path(lmode, &loid, src_path, &lstate)){
    ret = error(""could not write '%s'"", src_path);
    goto finish;
}
",,
implicit_predicate,difftool.c,498,+,-,"if (checkout_path(rmode, &roid, dst_path, &rstate)){
    ret = error(""could not write '%s'"", dst_path);
    goto finish;
}
",,
implicit_predicate,difftool.c,525,+,-,"if (symlinks){
    if (symlink(wtdir.buf, rdir.buf)){
        ret = error_errno(""could not symlink '%s' to '%s'"", wtdir.buf, rdir.buf);
        goto finish;
    }
}else{
    struct stat st;
    if (stat(wtdir.buf, &st))
        st.st_mode = 0644;

    if (copy_file(rdir.buf, wtdir.buf, st.st_mode)){
        ret = error(""could not copy '%s' to '%s'"", wtdir.buf, rdir.buf);
        goto finish;
    }
}
",,
implicit_predicate,difftool.c,649,+,-,"if (err){
    warning(_(""temporary files exist in '%s'.""), tmpdir.buf);
    warning(_(""you may want to cleanup or recover these.""));
    ret = 1;
}else{
    remove_dir_recursively(&tmpdir, 0);
    if (ret)
        warning(_(""failed: %d""), ret);
}
",,
implicit_predicate,difftool.c,655,+,-,"if (ret)
    warning(_(""failed: %d""), ret);
",,
implicit_predicate,difftool.c,733,+,-,"if (tool_help)
    return print_tool_help();
",,
implicit_predicate,difftool.c,743,+,-,"if (dir_diff)
    die(_(""options '%s' and '%s' cannot be used together""), ""--dir-diff"", ""--no-index"");
",,
implicit_predicate,difftool.c,761,+,-,"if (*difftool_cmd)
    setenv(""GIT_DIFF_TOOL"", difftool_cmd, 1);
else
    die(_(""no <tool> given for --tool=<tool>""));
",,
implicit_predicate,difftool.c,768,+,-,"if (*extcmd)
    setenv(""GIT_DIFFTOOL_EXTCMD"", extcmd, 1);
else
    die(_(""no <cmd> given for --extcmd=<cmd>""));
",,
implicit_predicate,difftool.c,775,+,+,"trust_exit_code ? ""true"" : ""false""",9,"	       trust_exit_code ? ""true"" : ""false"", 1);"
implicit_predicate,difftool.c,784,+,-,"if (no_index)
    strvec_push(&child.args, ""--no-index"");
",,
implicit_predicate,difftool.c,786,+,-,"if (dir_diff)
    strvec_pushl(&child.args, ""--raw"", ""--no-abbrev"", ""-z"", NULL);
",,
implicit_predicate,difftool.c,790,+,-,"if (dir_diff)
    return run_dir_diff(extcmd, symlinks, prefix, &child);
",,
implicit_predicate,dir-iterator.c,119,+,-,"while (1){
    int ret = next_directory_entry(level->dir, iter->base.path.buf, &de);
    if (ret < 0){
        if (errno != ENOENT && iter->flags & DIR_ITERATOR_PEDANTIC)
            return -1;

        continue;
    }else
        if (ret > 0){
            break;
        }

    string_list_append(&level->entries, de->d_name);
}
",,
implicit_predicate,dir-iterator.c,202,+,-,"while (1){
    struct dirent* de;
    struct dir_iterator_level* level = &iter->levels[iter->levels_nr - 1];
    const char* name;
    strbuf_setlen(&iter->base.path, level->prefix_len);
    if (level->dir){
        int ret = next_directory_entry(level->dir, iter->base.path.buf, &de);
        if (ret < 0){
            if (iter->flags & DIR_ITERATOR_PEDANTIC)
                goto error_out;

            continue;
        }else
            if (ret > 0){
                if (pop_level(iter) == 0)
                    return dir_iterator_abort(dir_iterator);

                continue;
            }

        name = de->d_name;
    }else{
        if (level->entries_idx >= level->entries.nr){
            if (pop_level(iter) == 0)
                return dir_iterator_abort(dir_iterator);

            continue;
        }
        name = level->entries.items[level->entries_idx++].string;
    }
    if (prepare_next_entry_data(iter, name)){
        if (errno != ENOENT && iter->flags & DIR_ITERATOR_PEDANTIC)
            goto error_out;

        continue;
    }
    return ITER_OK;
}
",,
implicit_predicate,dir-iterator.c,233,+,-,"if (prepare_next_entry_data(iter, name)){
    if (errno != ENOENT && iter->flags & DIR_ITERATOR_PEDANTIC)
        goto error_out;

    continue;
}
",,
implicit_predicate,dir.c,90,-,+,,9,"	return ignore_case ? strcasecmp(a, b) : strcmp(a, b);"
implicit_predicate,dir.c,100,-,+,,9,"	return ignore_case ? strncasecmp(a, b, count) : strncmp(a, b, count);"
implicit_predicate,dir.c,117,-,+,,9,	return ignore_case ? strihash(str) : strhash(str);
implicit_predicate,dir.c,140,-,+,,7,				 (item->magic & PATHSPEC_ICASE ? WM_CASEFOLD : 0));
implicit_predicate,dir.c,144,-,+,,6,				 item->magic & PATHSPEC_ICASE ? WM_CASEFOLD : 0);
implicit_predicate,dir.c,230,+,+,"len ? xmemdupz(pathspec->items[0].match, len) : NULL",9,"	return len ? xmemdupz(pathspec->items[0].match, len) : NULL;"
implicit_predicate,dir.c,249,-,+,,11,"	prefix = prefix_len ? pathspec->items[0].match : """";"
implicit_predicate,dir.c,532,+,-,"if (how){
    if (retval < how)
        retval = how;

    if (seen && seen[i] < how)
        seen[i] = how;
}
",,
implicit_predicate,dir.c,555,+,+,negative ? 0 : positive,9,	return negative ? 0 : positive;
implicit_predicate,dir.c,563,+,+,is_dir ? DO_MATCH_DIRECTORY : 0,19,	unsigned flags = is_dir ? DO_MATCH_DIRECTORY : 0;
implicit_predicate,dir.c,614,+,-,"if (found_dup)
    continue;
",,
implicit_predicate,dir.c,708,+,-,"while (*read){
    if (*read == '\\')
        read++;

    *set = *read;
    set++;
    read++;
    count++;
}
",,
implicit_predicate,dir.c,893,+,-,"if (hashmap_contains_path(map, buffer))
    return 1;
",,
implicit_predicate,dir.c,969,+,-,"for (p = buf;*p;p++)
    switch (*p){
        case ' ':
            if (!last_space)
                last_space = p;

            break;
        case '\\':
            p++;
            if (!*p)
                return;

        default:
            last_space = NULL;
    }
",,
implicit_predicate,dir.c,1095,+,-,"if (flags & PATTERN_NOFOLLOW)
    fd = open_nofollow(fname, O_RDONLY);
else
    fd = open(fname, O_RDONLY);
",,
implicit_predicate,dir.c,1300,+,+,baselen ? pathlen - baselen - 1 : pathlen,12,	namelen = baselen ? pathlen - baselen - 1 : pathlen;
implicit_predicate,dir.c,1303,+,-,"if (prefix){
    if (prefix > namelen)
        return 0;

    if (fspathncmp(pattern, name, prefix))
        return 0;

    pattern += prefix;
    patternlen -= prefix;
    name += prefix;
    namelen -= prefix;
    if (!patternlen && !namelen)
        return 1;
}
",,
implicit_predicate,dir.c,1377,-,+,,8,"				   pattern->baselen ? pattern->baselen - 1 : 0,"
implicit_predicate,dir.c,1435,-,+,,15,		slash_pos = slash_ptr ? slash_ptr - parent_pathname.buf : 0;
implicit_predicate,dir.c,1605,-,+,,12,	current = stk ? stk->baselen : -1;
implicit_predicate,dir.c,1608,-,+,,15,		untracked = stk ? stk->ucd : dir->untracked->root;
implicit_predicate,dir.c,1688,-,+,,10,				     untracked ? &oid_stat : NULL);
implicit_predicate,dir.c,1750,-,+,,10,		return pattern->flags & PATTERN_FLAG_NEGATIVE ? 0 : 1;
implicit_predicate,dir.c,1937,+,-,"if (nested_repo){
    char *real_dirname, *real_gitdir;
    strbuf_addstr(&sb, "".git"");
    real_dirname = real_pathdup(sb.buf, 1);
    real_gitdir = real_pathdup(the_repository->gitdir, 1);
    nested_repo = !!strcmp(real_dirname, real_gitdir);
    free(real_gitdir);
    free(real_dirname);
}
",,
implicit_predicate,dir.c,1949,+,-,"if (nested_repo){
    if ((dir->flags & DIR_SKIP_NESTED_GIT) || (matches_how == MATCHED_RECURSIVELY_LEADING_PATHSPEC))
        return path_none;

    return excluded ? path_excluded : path_untracked;
}
",,
implicit_predicate,dir.c,1953,+,+,excluded ? path_excluded : path_untracked,11,			return excluded ? path_excluded : path_untracked;
implicit_predicate,dir.c,1997,+,-,"if (excluded){
    if (!(dir->flags & DIR_HIDE_EMPTY_DIRECTORIES))
        return path_excluded;

    if ((dir->flags & DIR_SHOW_IGNORED_TOO) && (dir->flags & DIR_SHOW_IGNORED_TOO_MODE_MATCHING))
        return path_excluded;
}
",,
implicit_predicate,dir.c,2096,+,-,"if (want_ignored_subpaths){
    state = path_none;
}else{
    int i;
    for (i = old_ignored_nr + 1;i < dir->ignored_nr;++i)
        FREE_AND_NULL(dir->ignored[i]);
    dir->ignored_nr = old_ignored_nr;
}
",,
implicit_predicate,dir.c,2128,+,+,excluded ? path_excluded : path_untracked,11,		state = excluded ? path_excluded : path_untracked;
implicit_predicate,dir.c,2423,+,-,"if (excluded)
    return path_excluded;
",,
implicit_predicate,dir.c,2454,-,+,,13,"		if (lstat(path->len ? path->buf : ""."", &st)) {"
implicit_predicate,dir.c,2497,+,-,"if (valid_cached_dir(dir, untracked, istate, path, check_only))
    return 0;
",,
implicit_predicate,dir.c,2499,-,+,,11,"	c_path = path->len ? path->buf : ""."";"
implicit_predicate,dir.c,2629,+,-,"if (open_cached_dir(&cdir, dir, untracked, istate, &path, check_only))
    goto out;
",,
implicit_predicate,dir.c,2666,+,-,"if (check_only){
    if (stop_at_first_file){
        if (dir_state >= path_excluded){
            dir_state = path_excluded;
            break;
        }
    }
    if (dir_state == path_untracked){
        if (cdir.fdir)
            add_untracked(untracked, path.buf + baselen);

        break;
    }
    continue;
}
",,
implicit_predicate,dir.c,2667,+,-,"if (stop_at_first_file){
    if (dir_state >= path_excluded){
        dir_state = path_excluded;
        break;
    }
}
",,
implicit_predicate,dir.c,2764,+,-,"while (1){
    prevlen = baselen + !!baselen;
    cp = path + prevlen;
    cp = memchr(cp, '/', path + len - cp);
    if (!cp)
        baselen = len;
    else
        baselen = cp - path;

    strbuf_reset(&sb);
    strbuf_add(&sb, path, baselen);
    if (!is_directory(sb.buf))
        break;

    strbuf_reset(&sb);
    strbuf_add(&sb, path, prevlen);
    strbuf_reset(&subdir);
    strbuf_add(&subdir, path + prevlen, baselen - prevlen);
    cdir.d_name = subdir.buf;
    state = treat_path(dir, NULL, &cdir, istate, &sb, prevlen, pathspec);
    if (state != path_recurse)
        break;

    if (len <= baselen)
        break;
}
",,
implicit_predicate,dir.c,2899,+,-,"if (untracked_cache_disabled)
    return NULL;
",,
implicit_predicate,dir.c,3265,+,+,"is_bundle ? "".bundle"" : "".git""",32,"	strip_suffix_mem(start, &len, is_bundle ? "".bundle"" : "".git"");"
implicit_predicate,dir.c,3271,+,-,"if (is_bare)
    dir = xstrfmt(""%.*s.git"", (int)len, start);
else
    dir = xstrndup(start, len);
",,
implicit_predicate,dir.c,3279,+,-,"if (*dir){
    char* out = dir;
    int prev_space = 1;
    for (end = dir;*end;++end){
        char ch = *end;
        if ((unsigned char)ch < '\x20')
            ch = '\x20';

        if (isspace(ch)){
            if (prev_space)
                continue;

            prev_space = 1;
        }else
            prev_space = 0;

        *out++ = ch;
    }
    *out = '\0';
    if (out > dir && prev_space)
        out[-1] = '\0';
}
",,
implicit_predicate,dir.c,3287,+,-,"if (prev_space)
    continue;
",,
implicit_predicate,dir.c,3332,+,+,keep_toplevel ? -1 : 0,11,			return keep_toplevel ? -1 : 0;
implicit_predicate,dir.c,3333,+,-,keep_toplevel ? -1 : 0,,
implicit_predicate,dir.c,3405,-,+,,7,					 dir->untracked ? &dir->internal.ss_excludes_file : NULL);
implicit_predicate,dir.c,3412,-,+,,8,						 dir->untracked ? &dir->internal.ss_info_exclude : NULL);
implicit_predicate,dir.c,3913,+,-,"if (ret)
    invalidate_one_directory(uc, dir);
",,
implicit_predicate,dir.c,3914,+,-,"if (ret)
    invalidate_one_directory(uc, dir);
",,
implicit_predicate,dir.c,4048,+,-,"if (recurse_into_nested)
    connect_wt_gitdir_in_nested(work_tree, git_dir);
",,
implicit_predicate,dir.c,4049,+,-,"if (recurse_into_nested)
    connect_wt_gitdir_in_nested(work_tree, git_dir);
",,
implicit_predicate,dir.h,577,+,+,has_trailing_dir ? ent->len - 1 : ent->len,12,	int len = has_trailing_dir ? ent->len - 1 : ent->len;
implicit_predicate,dirent.c,63,+,-,"if (dir->dd_stat){
    WIN32_FIND_DATAW fdata;
    if (FindNextFileW(dir->dd_handle, &fdata)){
        finddata2dirent(&dir->dd_dir, &fdata);
    }else{
        DWORD lasterr = GetLastError();
        if (lasterr != ERROR_NO_MORE_FILES)
            errno = err_win_to_posix(lasterr);

        return NULL;
    }
}
",,
implicit_predicate,dump.c,91,+,-,"if (opt_dump_table){
    err = reftable_reader_print_file(arg);
}else
    if (opt_dump_stack){
        err = reftable_stack_print_directory(arg, opt_hash_id);
    }else
        if (opt_compact){
            err = compact_stack(arg);
        }
",,
implicit_predicate,dump.c,93,+,-,"if (opt_dump_stack){
    err = reftable_stack_print_directory(arg, opt_hash_id);
}else
    if (opt_compact){
        err = compact_stack(arg);
    }
",,
implicit_predicate,dump.c,95,+,-,"if (opt_compact){
    err = compact_stack(arg);
}
",,
implicit_predicate,editor.c,70,+,-,"if (print_waiting_for_editor){
    const char term = is_terminal_dumb() ? '\n' : ' ';
    fprintf(stderr, _(""hint: Waiting for your editor to close the file...%c""), term);
    fflush (stderr);
}
",,
implicit_predicate,editor.c,78,+,+,is_terminal_dumb() ? '\n' : ' ',22,			const char term = is_terminal_dumb() ? '\n' : ' ';
implicit_predicate,editor.c,113,+,-,"if (ret)
    return error(""there was a problem with the editor '%s'"", editor);
",,
implicit_predicate,entry.c,86,+,+,(mode & 0100) ? 0777 : 0666,9,	mode = (mode & 0100) ? 0777 : 0666;
implicit_predicate,entry.c,109,+,-,"if (to_tempfile){
    xsnprintf(path, TEMPORARY_FILENAME_LENGTH, ""%s"", symlink ? "".merge_link_XXXXXX"" : "".merge_file_XXXXXX"");
    return mkstemp(path);
}else{
    return create_file(path, !symlink ? ce->ce_mode : 0666);
}
",,
implicit_predicate,entry.c,111,+,+,"symlink ? "".merge_link_XXXXXX"" : "".merge_file_XXXXXX""",6,"			  symlink ? "".merge_link_XXXXXX"" : "".merge_file_XXXXXX"");"
implicit_predicate,entry.c,144,+,-,"if (result)
    unlink(path);
",,
implicit_predicate,entry.c,183,+,-,"if (show_progress)
    progress = start_delayed_progress(_(""Filtering content""), dco->paths.nr);
",,
implicit_predicate,entry.c,317,+,-,"if (ret)
    return error_errno(""unable to create symlink %s"", path);
",,
implicit_predicate,entry.c,343,+,-,"if (ret){
    struct string_list_item* item = string_list_lookup(&dco->paths, ce->name);
    if (item){
        item->util = nr_checkouts ? nr_checkouts : &scratch_nr_checkouts;
        free(new_blob);
        goto delayed;
    }
}
",,
implicit_predicate,entry.c,347,-,+,,19,"					item->util = nr_checkouts ? nr_checkouts
							: &scratch_nr_checkouts;"
implicit_predicate,entry.c,358,+,-,"if (ret){
    free(new_blob);
    new_blob = strbuf_detach(&buf, &newsize);
    size = newsize;
}
",,
implicit_predicate,entry.c,386,+,-,"if (to_tempfile)
    return error(""cannot create temporary submodule %s"", ce->name);
",,
implicit_predicate,entry.c,394,-,+,,5,				state->force ? SUBMODULE_MOVE_HEAD_FORCE : 0);
implicit_predicate,entry.c,524,-,+,,6,					state->force ? SUBMODULE_MOVE_HEAD_FORCE : 0);
implicit_predicate,environment.c,201,-,+,,33,"	git_replace_ref_base = xstrdup(replace_ref_base ? replace_ref_base
							  : ""refs/replace/"");"
implicit_predicate,environment.c,265,+,-,"if (git_work_tree_initialized){
    struct strbuf realpath = STRBUF_INIT;
    strbuf_realpath(&realpath, new_work_tree, 1);
    new_work_tree = realpath.buf;
    if (strcmp(new_work_tree, the_repository->worktree))
        die(""internal error: work tree has already been set\nCurrent worktree: %s\nNew worktree: %s"", the_repository->worktree, new_work_tree);

    strbuf_release(&realpath);
    return;
}
",,
implicit_predicate,environment.c,367,+,-,"if (make_realpath){
    strbuf_realpath(&realpath, path, 1);
    path = realpath.buf;
}
",,
implicit_predicate,environment.c,381,-,+,,9,"	return git_log_output_encoding ? git_log_output_encoding
		: get_commit_output_encoding();"
implicit_predicate,environment.c,387,-,+,,9,"	return git_commit_encoding ? git_commit_encoding : ""UTF-8"";"
implicit_predicate,environment.c,401,+,-,"if (need_shared_repository_from_config){
    const char* var = ""core.sharedrepository"";
    const char* value;
    if (!git_config_get_value(var, &value))
        the_shared_repository = git_config_perm(var, value);

    need_shared_repository_from_config = 0;
}
",,
implicit_predicate,ewah_bitmap.c,62,+,-,"if (v)
    rlw_set_run_bit(self->rlw, v);
",,
implicit_predicate,ewah_bitmap.c,75,+,-,"if (v)
    rlw_set_run_bit(self->rlw, v);
",,
implicit_predicate,ewah_bitmap.c,84,+,-,"if (v)
    rlw_set_run_bit(self->rlw, v);
",,
implicit_predicate,ewah_bitmap.c,127,+,-,"while (1){
    literals = rlw_get_literal_words(self->rlw);
    can_add = min_size(number, RLW_LARGEST_LITERAL_COUNT - literals);
    rlw_set_literal_words(self->rlw, literals + can_add);
    buffer_grow(self, self->buffer_size + can_add);
    if (negate){
        size_t i;
        for (i = 0;i < can_add;++i)
            self->buffer[self->buffer_size++] = ~buffer[i];
    }else{
        memcpy(self->buffer + self->buffer_size, buffer, can_add * sizeof (eword_t));
        self->buffer_size += can_add;
    }
    self->bit_size += can_add * BITS_IN_EWORD;
    if (number - can_add == 0)
        break;

    buffer_push_rlw(self, 0);
    buffer += can_add;
    number -= can_add;
}
",,
implicit_predicate,ewah_bitmap.c,135,+,-,"if (negate){
    size_t i;
    for (i = 0;i < can_add;++i)
        self->buffer[self->buffer_size++] = ~buffer[i];
}else{
    memcpy(self->buffer + self->buffer_size, buffer, can_add * sizeof (eword_t));
    self->buffer_size += can_add;
}
",,
implicit_predicate,ewah_bitmap.c,313,+,-,"while (1){
    word = &it->buffer[it->pointer];
    it->rl = rlw_get_running_len(word);
    it->lw = rlw_get_literal_words(word);
    it->b = rlw_get_run_bit(word);
    if (it->rl || it->lw)
        return;

    if (it->pointer < it->buffer_size - 1){
        it->pointer++;
    }else{
        it->pointer = it->buffer_size;
        return;
    }
}
",,
implicit_predicate,ewah_bitmap.c,339,-,+,,11,		*next = it->b ? (eword_t)(~0) : 0;
implicit_predicate,ewok_rlw.h,41,+,-,"if (b){
    *word |= (eword_t)1;
}else{
    *word &= (eword_t)(~1);
}
",,
implicit_predicate,fast-export.c,93,+,-,"if (unset){
    *val = REENCODE_ABORT;
    return 0;
}
",,
implicit_predicate,fast-export.c,303,+,-,"if (no_data)
    return;
",,
implicit_predicate,fast-export.c,313,+,-,"if (anonymize){
    buf = anonymize_blob(&size);
    object = (struct object*)lookup_blob(the_repository, oid);
    eaten = 0;
}else{
    buf = repo_read_object_file(the_repository, oid, &type, &size);
    if (!buf)
        die(""could not read blob %s"", oid_to_hex(oid));

    if (check_object_signature(the_repository, oid, buf, size, type) < 0)
        die(""oid mismatch in blob %s"", oid_to_hex(oid));

    object = parse_object_buffer(the_repository, oid, type, size, buf, &eaten);
}
",,
implicit_predicate,fast-export.c,334,+,-,"if (show_original_ids)
    printf(""original-oid %s\n"", oid_to_hex(oid));
",,
implicit_predicate,fast-export.c,356,-,+,,11,	name_a = a->one ? a->one->path : a->two->path;
implicit_predicate,fast-export.c,357,-,+,,11,	name_b = b->one ? b->one->path : b->two->path;
implicit_predicate,fast-export.c,365,+,-,"if (cmp)
    return cmp;
",,
implicit_predicate,fast-export.c,368,+,-,"if (cmp)
    return cmp;
",,
implicit_predicate,fast-export.c,381,+,-,"if (need_quote)
    quote_c_style(path, NULL, stdout, 0);
else
    if (strchr(path, ' '))
        printf(""\""%s\"""", path);
    else
        printf(""%s"", path);
",,
implicit_predicate,fast-export.c,486,-,+,,12,"				       anonymize ?
				       anonymize_oid(oid_to_hex(&spec->oid)) :
				       oid_to_hex(&spec->oid));"
implicit_predicate,fast-export.c,503,-,+,,5,"				ospec->path ? ospec->path : ""none"","
implicit_predicate,fast-export.c,504,-,+,,5,"				spec->path ? spec->path : ""none"");"
implicit_predicate,fast-export.c,514,-,+,,22,"	bol = memmem(begin, end ? end - begin : strlen(begin),"
implicit_predicate,fast-export.c,683,+,-,"if (anonymize){
    refname = anonymize_refname(refname);
    anonymize_ident_line(&committer, &committer_end);
    anonymize_ident_line(&author, &author_end);
}
",,
implicit_predicate,fast-export.c,690,+,-,"if (anonymize){
    reencoded = anonymize_commit_message();
}else
    if (encoding){
        switch (reencode_mode){
            case REENCODE_YES:
                reencoded = reencode_string(message, ""UTF-8"", encoding);
                break;
            case REENCODE_NO:
                break;
            case REENCODE_ABORT:
                die(""Encountered commit-specific encoding %s in commit %s; use --reencode=[yes|no] to handle it"", encoding, oid_to_hex(&commit->object.oid));
        }
    }
",,
implicit_predicate,fast-export.c,708,+,-,"if (show_original_ids)
    printf(""original-oid %s\n"", oid_to_hex(&commit->object.oid));
",,
implicit_predicate,fast-export.c,716,-,+,,20,"	       (unsigned)(reencoded
			  ? strlen(reencoded) : message
			  ? strlen(message) : 0),"
implicit_predicate,fast-export.c,717,-,+,,28,"			  ? strlen(reencoded) : message
			  ? strlen(message) : 0),"
implicit_predicate,fast-export.c,719,-,+,,33,"	       reencoded ? reencoded : message ? message : """");"
implicit_predicate,fast-export.c,733,+,-,"if (mark)
    printf("":%d\n"", mark);
else
    printf(""%s\n"", anonymize ? anonymize_oid(oid_to_hex(&obj->oid)) : oid_to_hex(&obj->oid));
",,
implicit_predicate,fast-export.c,737,+,+,anonymize ? anonymize_oid(oid_to_hex(&obj->oid)) : oid_to_hex(&obj->oid),11,"			       anonymize ?
			       anonymize_oid(oid_to_hex(&obj->oid)) :
			       oid_to_hex(&obj->oid));"
implicit_predicate,fast-export.c,743,+,-,"if (full_tree)
    printf(""deleteall\n"");
",,
implicit_predicate,fast-export.c,797,-,+,,23,"	tagger = memmem(buf, message ? message - buf : size, ""\ntagger "", 8);"
implicit_predicate,fast-export.c,799,+,-,"if (fake_missing_tagger)
    tagger = ""tagger Unspecified Tagger <unspecified-tagger> 0 +0000"";
else
    tagger = """";
",,
implicit_predicate,fast-export.c,808,+,-,"if (anonymize)
    anonymize_ident_line(&tagger, &tagger_end);
",,
implicit_predicate,fast-export.c,812,+,-,"if (anonymize){
    name = anonymize_refname(name);
    if (message){
        static struct hashmap tags;
        message = anonymize_str(&tags, anonymize_tag, message, message_size);
        message_size = strlen(message);
    }
}
",,
implicit_predicate,fast-export.c,886,+,-,<!!!>,,
implicit_predicate,fast-export.c,890,+,-,"if (tagged_mark)
    printf(""from :%d\n"", tagged_mark);
else
    printf(""from %s\n"", oid_to_hex(&tagged->oid));
",,
implicit_predicate,fast-export.c,895,+,-,"if (show_original_ids)
    printf(""original-oid %s\n"", oid_to_hex(&tag->object.oid));
",,
implicit_predicate,fast-export.c,900,-,+,,47,"	       (int)message_size, (int)message_size, message ? message : """");"
implicit_predicate,fast-export.c,1003,+,-,"if (anonymize)
    name = anonymize_refname(name);
",,
implicit_predicate,fast-export.c,1077,+,-,"if (e)
    error(""Unable to write marks file %s."", file);
",,
implicit_predicate,fast-export.c,1258,+,-,"if (use_done_feature)
    printf(""feature done\n"");
",,
implicit_predicate,fast-export.c,1292,+,-,"if (use_done_feature)
    printf(""done\n"");
",,
implicit_predicate,fast-import.c,277,+,-,"if (m->shift){
    for (k = 0;k < 1024;k++){
        if (m->data.sets[k])
            for_each_mark(m->data.sets[k], base + (k << m->shift), callback, p);
    }
}else{
    for (k = 0;k < 1024;k++){
        if (m->data.marked[k])
            callback(base + k, m->data.marked[k], p);
    }
}
",,
implicit_predicate,fast-import.c,302,+,-,"if (b->active)
    fputs("" active"", rpt);
",,
implicit_predicate,fast-import.c,555,+,-,"while (s->shift){
    uintmax_t i = idnum >> s->shift;
    idnum -= i << s->shift;
    if (!s->data.sets[i]){
        s->data.sets[i] = mem_pool_calloc(&fi_mem_pool, 1, sizeof (struct mark_set));
        s->data.sets[i]->shift = s->shift - 10;
    }
    s = s->data.sets[i];
}
",,
implicit_predicate,fast-import.c,642,+,+,cnt & 7 ? (cnt / 8) + 1 : cnt / 8,8,	cnt = cnt & 7 ? (cnt / 8) + 1 : cnt / 8;
implicit_predicate,fast-import.c,662,+,+,cnt & 7 ? ((cnt / 8) + 1) * 8 : cnt,9,		cnt = cnt & 7 ? ((cnt / 8) + 1) * 8 : cnt;
implicit_predicate,fast-import.c,866,+,-,"if (object_count){
    struct packed_git* new_p;
    struct object_id cur_pack_oid;
    char* idx_name;
    int i;
    struct branch* b;
    struct tag* t;
    close_pack_windows(pack_data);
    finalize_hashfile(pack_file, cur_pack_oid.hash, FSYNC_COMPONENT_PACK, 0);
    fixup_pack_header_footer(pack_data->pack_fd, pack_data->hash, pack_data->pack_name, object_count, cur_pack_oid.hash, pack_size);
    if (object_count <= unpack_limit){
        if (!loosen_small_pack(pack_data)){
            invalidate_pack_id(pack_id);
            goto discard_pack;
        }
    }
    close(pack_data->pack_fd);
    idx_name = keep_pack(create_index());
    new_p = add_packed_git(idx_name, strlen(idx_name), 1);
    if (!new_p)
        die(""core git rejected index %s"", idx_name);

    all_packs[pack_id] = new_p;
    install_packed_git(the_repository, new_p);
    free(idx_name);
    if (pack_edges){
        fprintf(pack_edges, ""%s:"", new_p->pack_name);
        for (i = 0;i < branch_table_sz;i++){
            for (b = branch_table[i];b;b = b->table_next_branch){
                if (b->pack_id == pack_id)
                    fprintf(pack_edges, "" %s"", oid_to_hex(&b->oid));
            }
        }
        for (t = first_tag;t;t = t->next_tag){
            if (t->pack_id == pack_id)
                fprintf(pack_edges, "" %s"", oid_to_hex(&t->oid));
        }
        fputc('\n', pack_edges);
        fflush(pack_edges);
    }
    pack_id++;
}else{
    discard_pack:
    close(pack_data->pack_fd);
    unlink_or_warn(pack_data->pack_name);
}
",,
implicit_predicate,fast-import.c,1067,+,-,"if (last->no_swap){
    last->data = *dat;
}else{
    strbuf_swap(&last->data, dat);
}
",,
implicit_predicate,fast-import.c,1136,-,+,,28,"		status = git_deflate(&s, len ? 0 : Z_FINISH);"
implicit_predicate,fast-import.c,1523,+,-,"if (tree_content_remove(e, slash1 + 1, backup_leaf, 0)){
    for (n = 0;n < e->tree->entry_count;n++){
        if (e->tree->entries[n]->versions[1].mode){
            oidclr(&root->versions[1].oid);
            return 1;
        }
    }
    backup_leaf = NULL;
    goto del_entry;
}
",,
implicit_predicate,fast-import.c,1799,+,-,"if (stdin_eof){
    unread_command_buf = 0;
    return EOF;
}
",,
implicit_predicate,fast-import.c,1805,+,-,"if (unread_command_buf){
    unread_command_buf = 0;
}else{
    struct recent_command* rc;
    stdin_eof = strbuf_getline_lf(&command_buf, stdin);
    if (stdin_eof)
        return EOF;

    if (!seen_data_command && !starts_with(command_buf.buf, ""feature "") && !starts_with(command_buf.buf, ""option "")){
        parse_argv();
    }
    rc = rc_free;
    if (rc)
        rc_free = rc->next;
    else{
        rc = cmd_hist.next;
        cmd_hist.next = rc->next;
        cmd_hist.next->prev = &cmd_hist;
        free(rc->buf);
    }
    rc->buf = xstrdup(command_buf.buf);
    rc->prev = cmd_tail;
    rc->next = cmd_hist.prev;
    rc->prev->next = rc;
    cmd_tail = rc;
}
",,
implicit_predicate,fast-import.c,1811,+,-,"if (stdin_eof)
    return EOF;
",,
implicit_predicate,fast-import.c,2084,+,-,"while (fanout){
    path[i++] = hex_sha1[j++];
    path[i++] = hex_sha1[j++];
    path[i++] = '/';
    fanout--;
}
",,
implicit_predicate,fast-import.c,2134,+,-,"if (tmp_fullpath_len)
    fullpath[tmp_fullpath_len++] = '/';
",,
implicit_predicate,fast-import.c,2284,+,+,"is_last_field ? p + strlen(p) : strchrnul(p, ' ')",11,"		*endp = is_last_field
			? p + strlen(p)
			: strchrnul(p, ' ');"
implicit_predicate,fast-import.c,2350,+,-,"if (parse_mapped_oid_hex(p, &oid, &p))
    die(""Invalid dataref: %s"", command_buf.buf);
",,
implicit_predicate,fast-import.c,2395,-,+,,27,"		enum object_type type = oe ? oe->type :
					oid_object_info(the_repository, &oid,
							NULL);"
implicit_predicate,fast-import.c,2436,+,-,"if (rename)
    tree_content_remove(&b->branch_tree, source.buf, &leaf, 1);
else
    tree_content_get(&b->branch_tree, source.buf, &leaf, 1);
",,
implicit_predicate,fast-import.c,2489,+,-,"if (parse_mapped_oid_hex(p, &oid, &p))
    die(""Invalid dataref: %s"", command_buf.buf);
",,
implicit_predicate,fast-import.c,2791,-,+,,3,"		author ? author : committer, committer);"
implicit_predicate,fast-import.c,3019,+,-,"if (parse_mapped_oid_hex(p, &oid, &p))
    die(""Invalid dataref: %s"", command_buf.buf);
",,
implicit_predicate,fast-import.c,3131,+,-,"if (parse_mapped_oid_hex(*p, &oid, p))
    die(""Invalid dataref: %s"", command_buf.buf);
",,
implicit_predicate,fast-import.c,3209,+,-,"if (object_count){
    cycle_packfile();
}
",,
implicit_predicate,fast-import.c,3264,+,-,"if (from_stream)
    die(""Only one import-marks command allowed per stream"");
",,
implicit_predicate,fast-import.c,3446,+,-,"if (seen_data_command)
    die(""Got feature command '%s' after data command"", feature);
",,
implicit_predicate,fast-import.c,3449,+,-,"if (parse_one_feature(feature, 1))
    return;
",,
implicit_predicate,fast-import.c,3457,+,-,"if (seen_data_command)
    die(""Got option command '%s' after data command"", option);
",,
implicit_predicate,fast-import.c,3460,+,-,"if (parse_one_option(option))
    return;
",,
implicit_predicate,fast-import.c,3509,+,-,"if (parse_one_option(a))
    continue;
",,
implicit_predicate,fast-import.c,3512,+,-,"if (parse_one_feature(a, 0))
    continue;
",,
implicit_predicate,fast-import.c,3630,+,-,<!!!>,,
implicit_predicate,fast-import.c,3657,+,+,failure ? 1 : 0,9,
implicit_predicate,fetch-pack.c,135,+,-,"while (1){
    if (oid_object_info_extended(the_repository, oid, &info, oi_flags))
        return NULL;

    if (*type == OBJ_TAG){
        struct tag* tag = (struct tag*)parse_object(the_repository, oid);
        if (!tag->tagged)
            return NULL;

        if (mark_tags_complete)
            tag->object.flags |= COMPLETE;

        oid = &tag->tagged->oid;
    }else{
        break;
    }
}
",,
implicit_predicate,fetch-pack.c,145,+,-,"if (mark_tags_complete)
    tag->object.flags |= COMPLETE;
",,
implicit_predicate,fetch-pack.c,214,-,+,,15,		int flags = args.verbose ? CONNECT_VERBOSE : 0;
implicit_predicate,fetch-pack.c,220,-,+,,11,			return args.diag_url ? 0 : 1;
implicit_predicate,fetch-pack.c,273,+,-,"if (stateless_rpc){
    if (count < LARGE_FLUSH)
        count <<= 1;
    else
        count = count * 11 / 10;
}else{
    if (count < PIPESAFE_FLUSH)
        count <<= 1;
    else
        count += PIPESAFE_FLUSH;
}
",,
implicit_predicate,fetch-pack.c,310,+,-,"if (server_supports_filter){
    print_verbose(args, _(""Server supports filter""));
    packet_buf_write(req_buf, ""filter %s"", spec);
    trace2_data_string(""fetch"", the_repository, ""filter/effective"", spec);
}else{
    warning(""filtering not recognized by server, ignoring"");
    trace2_data_string(""fetch"", the_repository, ""filter/unsupported"", spec);
}
",,
implicit_predicate,fetch-pack.c,380,+,-,"if (no_done)
    strbuf_addstr(&c, "" no-done"");
",,
implicit_predicate,fetch-pack.c,387,+,-,"if (prefer_ofs_delta)
    strbuf_addstr(&c, "" ofs-delta"");
",,
implicit_predicate,fetch-pack.c,388,+,-,"if (deepen_since_ok)
    strbuf_addstr(&c, "" deepen-since"");
",,
implicit_predicate,fetch-pack.c,389,+,-,"if (deepen_not_ok)
    strbuf_addstr(&c, "" deepen-not"");
",,
implicit_predicate,fetch-pack.c,390,+,-,"if (agent_supported)
    strbuf_addf(&c, "" agent=%s"", git_user_agent_sanitized());
",,
implicit_predicate,fetch-pack.c,392,+,-,"if (advertise_sid)
    strbuf_addf(&c, "" session-id=%s"", trace2_session_id());
",,
implicit_predicate,fetch-pack.c,499,+,-,"do{
    ack = get_ack(&reader, result_oid);
    if (ack)
        print_verbose(args, _(""got %s %d %s""), ""ack"", ack, oid_to_hex(result_oid));

    switch (ack){
        case ACK:
            trace2_region_leave_printf(""negotiation_v0_v1"", ""round"", the_repository, ""%d"", negotiation_round);
            flushes = 0;
            multi_ack = 0;
            retval = 0;
            goto done;
        case ACK_common:
        case ACK_ready:
        case ACK_continue:
            {
                struct commit* commit = lookup_commit(the_repository, result_oid);
                int was_common;
                if (!commit)
                    die(_(""invalid commit %s""), oid_to_hex(result_oid));

                was_common = negotiator->ack(negotiator, commit);
                if (args->stateless_rpc && ack == ACK_common && !was_common){
                    const char* hex = oid_to_hex(result_oid);
                    packet_buf_write(&req_buf, ""have %s\n"", hex);
                    state_len = req_buf.len;
                    haves++;
                    in_vain = 0;
            }else
                if (!args->stateless_rpc || ack != ACK_common)
                    in_vain = 0;

            retval = 0;
            got_continue = 1;
            if (ack == ACK_ready)
                got_ready = 1;

            break;
        }
    }
} while (ack);
",,
implicit_predicate,fetch-pack.c,501,+,-,"if (ack)
    print_verbose(args, _(""got %s %d %s""), ""ack"", ack, oid_to_hex(result_oid));
",,
implicit_predicate,fetch-pack.c,560,+,-,"if (got_ready)
    break;
",,
implicit_predicate,fetch-pack.c,583,+,-,"if (ack){
    print_verbose(args, _(""got %s (%d) %s""), ""ack"", ack, oid_to_hex(result_oid));
    if (ack == ACK)
        return 0;

    multi_ack = 1;
    continue;
}
",,
implicit_predicate,fetch-pack.c,594,+,+,count ? retval : 0,9,	return count ? retval : 0;
implicit_predicate,fetch-pack.c,687,+,-,"if (keep){
    *newtail = ref;
    ref->next = NULL;
    newtail = &ref->next;
}else{
    ref->next = unmatched;
    unmatched = ref;
}
",,
implicit_predicate,fetch-pack.c,697,+,-,"if (strict){
    for (i = 0;i < nr_sought;i++){
        ref = sought[i];
        if (!is_unmatched_ref(ref))
            continue;

        add_refs_to_oidset(&tip_oids, unmatched);
        add_refs_to_oidset(&tip_oids, newlist);
        break;
    }
}
",,
implicit_predicate,fetch-pack.c,879,+,-,"do{
    char hex_hash[GIT_MAX_HEXSZ + 1];
    int read_len = read_in_full(fd, hex_hash, len);
    struct object_id oid;
    const char* end;
    if (!read_len)
        return;

    if (read_len != len)
        die(""invalid length read %d"", read_len);

    if (parse_oid_hex(hex_hash, &oid, &end) || *end != '\n')
        die(""invalid hash"");

    oidset_insert(gitmodules_oids, &oid);
} while (1);
",,
implicit_predicate,fetch-pack.c,926,+,-,"if (use_sideband){
    demux.proc = sideband_demux;
    demux.data = xd;
    demux.out = -1;
    demux.isolate_sigpipe = 1;
    if (start_async(&demux))
        die(_(""fetch-pack: unable to fork off sideband demultiplexer""));
}else
    demux.out = xd[0];
",,
implicit_predicate,fetch-pack.c,957,+,-,"if (fetch_fsck_objects >= 0 ? fetch_fsck_objects : transfer_fsck_objects >= 0 ? transfer_fsck_objects : 0)
    fsck_objects = 1;
",,
implicit_predicate,fetch-pack.c,1009,+,-,"if (fsck_objects){
    if (args->from_promisor || index_pack_args)
        strvec_push(&cmd.args, ""--fsck-objects"");
    else
        strvec_pushf(&cmd.args, ""--strict%s"", fsck_msg_types.buf);
}
",,
implicit_predicate,fetch-pack.c,1366,+,-,"if (prefer_ofs_delta)
    packet_buf_write(&req_buf, ""ofs-delta"");
",,
implicit_predicate,fetch-pack.c,1368,+,-,"if (sideband_all)
    packet_buf_write(&req_buf, ""sideband-all"");
",,
implicit_predicate,fetch-pack.c,1730,+,-,"while (process_ack(negotiator, &reader, &common_oid, &received_ready)){
    in_vain = 0;
    seen_ack = 1;
    oidset_insert(&common, &common_oid);
}
",,
implicit_predicate,fetch-pack.c,1739,+,-,"if (received_ready){
    state = FETCH_GET_PACK;
}else{
    do_check_stateless_delimiter(args->stateless_rpc, &reader);
    state = FETCH_SEND_REQUEST;
}
",,
implicit_predicate,fetch-pack.c,1757,+,-,"if (process_section_header(&reader, ""shallow-info"", 1))
    receive_shallow_info(args, &reader, shallows, si);
",,
implicit_predicate,fetch-pack.c,1760,+,-,"if (process_section_header(&reader, ""wanted-refs"", 1))
    receive_wanted_refs(&reader, sought, nr_sought);
",,
implicit_predicate,fetch-pack.c,1766,+,-,"if (process_section_header(&reader, ""packfile-uris"", 1))
    receive_packfile_uris(&reader, &packfile_uris);
",,
implicit_predicate,fetch-pack.c,1782,-,+,,10,"				     packfile_uris.nr ? &index_pack_args : NULL,"
implicit_predicate,fetch-pack.c,1868,-,+,,4,"			fsck_msg_types.len ? ',' : '=', path);"
implicit_predicate,fetch-pack.c,1878,-,+,,5,"				fsck_msg_types.len ? ',' : '=', msg_id, value);"
implicit_predicate,fetch-pack.c,1910,+,-,"if (did_setup)
    return;
",,
implicit_predicate,fetch-pack.c,2031,+,-,"if (status[i])
    sought[i]->status = REF_STATUS_REJECT_SHALLOW;
",,
implicit_predicate,fetch-pack.c,2062,+,-,"if (nr_sought)
    nr_sought = remove_duplicates_in_refs(sought, nr_sought);
",,
implicit_predicate,fetch-pack.c,2187,+,-,"while (process_ack(&negotiator, &reader, &common_oid, &received_ready)){
    struct commit* commit = lookup_commit(the_repository, &common_oid);
    if (commit){
        timestamp_t generation;
        parse_commit_or_die(commit);
        commit->object.flags |= COMMON;
        generation = commit_graph_generation(commit);
        if (generation < min_generation)
            min_generation = generation;
    }
    in_vain = 0;
    seen_ack = 1;
    oidset_insert(acked_commits, &common_oid);
}
",,
implicit_predicate,fetch-pack.c,2204,+,-,"if (received_ready)
    die(_(""unexpected 'ready' from remote""));
else
    do_check_stateless_delimiter(stateless_rpc, &reader);
",,
implicit_predicate,fetch.c,138,-,+,,11,"		int r = git_config_bool(k, v) ?
			RECURSE_SUBMODULES_ON : RECURSE_SUBMODULES_OFF;"
implicit_predicate,fetch.c,272,-,+,,29,"	return strcmp(e1->refname, keydata ? keydata : e2->refname);"
implicit_predicate,fetch.c,423,+,-,"if (item->ignore)
    continue;
",,
implicit_predicate,fetch.c,653,+,-,"if (dry_run)
    return 0;
",,
implicit_predicate,fetch.c,674,+,+,check_old ? &ref->old_oid : NULL,10,"				     check_old ? &ref->old_oid : NULL,"
implicit_predicate,fetch.c,676,+,-,"if (ret){
    ret = STORE_REF_ERROR_OTHER;
    goto out;
}
",,
implicit_predicate,fetch.c,696,+,-,"if (ret)
    error(""%s"", err.buf);
",,
implicit_predicate,fetch.c,709,+,-,"if (compact_format)
    max = max * 2 / 3;
",,
implicit_predicate,fetch.c,939,+,+,r ? '!' : 't',38,"			display_ref_update(display_state, r ? '!' : 't', _(""[tag update]""),"
implicit_predicate,fetch.c,940,+,+,"r ? _(""unable to update local ref"") : NULL",9,"					   r ? _(""unable to update local ref"") : NULL,"
implicit_predicate,fetch.c,978,+,+,r ? '!' : '*',37,"		display_ref_update(display_state, r ? '!' : '*', what,"
implicit_predicate,fetch.c,979,+,+,"r ? _(""unable to update local ref"") : NULL",8,"				   r ? _(""unable to update local ref"") : NULL,"
implicit_predicate,fetch.c,996,+,-,"if (fast_forward){
    struct strbuf quickref = STRBUF_INIT;
    int r;
    strbuf_add_unique_abbrev(&quickref, &current->object.oid, DEFAULT_ABBREV);
    strbuf_addstr(&quickref, "".."");
    strbuf_add_unique_abbrev(&quickref, &ref->new_oid, DEFAULT_ABBREV);
    r = s_update_ref(""fast-forward"", ref, transaction, 1);
    display_ref_update(display_state, r ? '!' : ' ', quickref.buf, r ? _(""unable to update local ref"") : NULL, remote_ref->name, ref->name, &ref->old_oid, &ref->new_oid, summary_width);
    strbuf_release(&quickref);
    return r;
}else
    if (force || ref->force){
        struct strbuf quickref = STRBUF_INIT;
        int r;
        strbuf_add_unique_abbrev(&quickref, &current->object.oid, DEFAULT_ABBREV);
        strbuf_addstr(&quickref, ""..."");
        strbuf_add_unique_abbrev(&quickref, &ref->new_oid, DEFAULT_ABBREV);
        r = s_update_ref(""forced-update"", ref, transaction, 1);
        display_ref_update(display_state, r ? '!' : '+', quickref.buf, r ? _(""unable to update local ref"") : _(""forced update""), remote_ref->name, ref->name, &ref->old_oid, &ref->new_oid, summary_width);
        strbuf_release(&quickref);
        return r;
    }else{
        display_ref_update(display_state, '!', _(""[rejected]""), _(""non-fast-forward""), remote_ref->name, ref->name, &ref->old_oid, &ref->new_oid, summary_width);
        return 1;
    }
",,
implicit_predicate,fetch.c,1004,+,+,r ? '!' : ' ',37,"		display_ref_update(display_state, r ? '!' : ' ', quickref.buf,"
implicit_predicate,fetch.c,1005,+,+,"r ? _(""unable to update local ref"") : NULL",8,"				   r ? _(""unable to update local ref"") : NULL,"
implicit_predicate,fetch.c,1017,+,+,r ? '!' : '+',37,"		display_ref_update(display_state, r ? '!' : '+', quickref.buf,"
implicit_predicate,fetch.c,1018,+,+,"r ? _(""unable to update local ref"") : _(""forced update"")",8,"				   r ? _(""unable to update local ref"") : _(""forced update""),"
implicit_predicate,fetch.c,1053,+,-,"if (write_fetch_head){
    fetch_head->fp = fopen(filename, ""a"");
    if (!fetch_head->fp)
        return error_errno(_(""cannot open '%s'""), filename);

    strbuf_init(&fetch_head->buf, 0);
}else{
    fetch_head->fp = NULL;
}
",,
implicit_predicate,fetch.c,1179,-,+,,7,						rm->peer_ref ? rm->peer_ref->name : rm->name);
implicit_predicate,fetch.c,1266,-,+,,10,"						   *kind ? kind : ""branch"", NULL,"
implicit_predicate,fetch.c,1275,+,-,"if (rc & STORE_REF_ERROR_DF_CONFLICT)
    error(_(""some local refs could not be updated; try running\n 'git remote prune %s' to remove any old, conflicting branches""), remote_name);
",,
implicit_predicate,fetch.c,1312,+,-,"if (deepen)
    return -1;
",,
implicit_predicate,fetch.c,1319,+,-,"if (refetch)
    return -1;
",,
implicit_predicate,fetch.c,1353,+,-,"if (ret){
    trace2_region_enter(""fetch"", ""fetch_refs"", the_repository);
    ret = transport_fetch_refs(transport, ref_map);
    trace2_region_leave(""fetch"", ""fetch_refs"", the_repository);
    if (ret)
        goto out;

    connectivity_checked = transport->smart_options ? transport->smart_options->connectivity_checked : 0;
}
",,
implicit_predicate,fetch.c,1357,+,-,"if (ret)
    goto out;
",,
implicit_predicate,fetch.c,1359,-,+,,26,"		connectivity_checked = transport->smart_options ?
			transport->smart_options->connectivity_checked : 0;"
implicit_predicate,fetch.c,1382,+,+,"dry_run ? _(""   (%s will become dangling)"") : _(""   (%s has become dangling)"")",29,"	const char *dangling_msg = dry_run
		? _(""   (%s will become dangling)"")
		: _(""   (%s has become dangling)"");"
implicit_predicate,fetch.c,1391,+,-,"if (result)
    goto cleanup;
",,
implicit_predicate,fetch.c,1506,+,-,"if (keep)
    set_option(transport, TRANS_OPT_KEEP, ""yes"");
",,
implicit_predicate,fetch.c,1515,+,-,"if (deepen_relative)
    set_option(transport, TRANS_OPT_DEEPEN_RELATIVE, ""yes"");
",,
implicit_predicate,fetch.c,1517,+,-,"if (update_shallow)
    set_option(transport, TRANS_OPT_UPDATE_SHALLOW, ""yes"");
",,
implicit_predicate,fetch.c,1519,+,-,"if (refetch)
    set_option(transport, TRANS_OPT_REFETCH, ""yes"");
",,
implicit_predicate,fetch.c,1554,+,-,"if (cannot_reuse){
    gsecondary = prepare_transport(transport->remote, 0);
    transport = gsecondary;
}
",,
implicit_predicate,fetch.c,1599,+,-,"if (retcode)
    goto cleanup;
",,
implicit_predicate,fetch.c,1642,+,-,"if (must_list_refs){
    trace2_region_enter(""fetch"", ""remote_refs"", the_repository);
    remote_refs = transport_get_remote_refs(transport, &transport_ls_refs_options);
    trace2_region_leave(""fetch"", ""remote_refs"", the_repository);
}else
    remote_refs = NULL;
",,
implicit_predicate,fetch.c,1658,+,-,"if (retcode)
    goto cleanup;
",,
implicit_predicate,fetch.c,1664,+,-,"if (atomic_fetch){
    transaction = ref_store_transaction_begin(get_main_ref_store(the_repository), &err);
    if (!transaction){
        retcode = -1;
        goto cleanup;
    }
}
",,
implicit_predicate,fetch.c,1675,+,-,"if (prune){
    if (rs->nr){
        retcode = prune_refs(&display_state, rs, transaction, ref_map);
    }else{
        retcode = prune_refs(&display_state, &transport->remote->fetch, transaction, ref_map);
    }
    if (retcode != 0)
        retcode = 1;
}
",,
implicit_predicate,fetch.c,1691,+,-,"if (fetch_and_consume_refs(&display_state, transport, transaction, ref_map, &fetch_head, config)){
    retcode = 1;
    goto cleanup;
}
",,
implicit_predicate,fetch.c,1714,+,-,"if (backfill_tags(&display_state, transport, transaction, tags_ref_map, &fetch_head, config))
    retcode = 1;
",,
implicit_predicate,fetch.c,1723,+,-,"if (retcode)
    goto cleanup;
",,
implicit_predicate,fetch.c,1727,+,-,"if (retcode){
    ref_transaction_free(transaction);
    transaction = NULL;
    goto cleanup;
}
",,
implicit_predicate,fetch.c,1736,+,-,"if (set_upstream){
    struct branch* branch = branch_get(""HEAD"");
    struct ref* rm;
    struct ref* source_ref = NULL;
    for (rm = ref_map;rm;rm = rm->next){
        if (!rm->peer_ref){
            if (source_ref){
                warning(_(""multiple branches detected, incompatible with --set-upstream""));
                goto cleanup;
            }else{
                source_ref = rm;
            }
        }
    }
    if (source_ref){
        if (!branch){
            const char* shortname = source_ref->name;
            skip_prefix(shortname, ""refs/heads/"", &shortname);
            warning(_(""could not set upstream of HEAD to '%s' from '%s' when it does not point to any branch.""), shortname, transport->remote->name);
            goto cleanup;
        }
        if (!strcmp(source_ref->name, ""HEAD"") || starts_with(source_ref->name, ""refs/heads/""))
            install_branch_config(0, branch->name, transport->remote->name, source_ref->name);
        else
            if (starts_with(source_ref->name, ""refs/remotes/""))
                warning(_(""not setting upstream for a remote remote-tracking branch""));
            else
                if (starts_with(source_ref->name, ""refs/tags/""))
                    warning(_(""not setting upstream for a remote tag""));
                else
                    warning(_(""unknown branch type""));
    }else{
        warning(_(""no source branch found;\nyou need to specify exactly one branch with the --set-upstream option""));
    }
}
",,
implicit_predicate,fetch.c,1791,+,-,"if (retcode){
    if (err.len){
        error(""%s"", err.buf);
        strbuf_reset(&err);
    }
    if (transaction && ref_transaction_abort(transaction, &err) && err.len)
        error(""%s"", err.buf);
}
",,
implicit_predicate,fetch.c,1861,+,-,"if (dry_run)
    strvec_push(argv, ""--dry-run"");
",,
implicit_predicate,fetch.c,1864,+,+,"prune ? ""--prune"" : ""--no-prune""",21,"		strvec_push(argv, prune ? ""--prune"" : ""--no-prune"");"
implicit_predicate,fetch.c,1866,+,+,"prune_tags ? ""--prune-tags"" : ""--no-prune-tags""",21,"		strvec_push(argv, prune_tags ? ""--prune-tags"" : ""--no-prune-tags"");"
implicit_predicate,fetch.c,1867,+,-,"if (update_head_ok)
    strvec_push(argv, ""--update-head-ok"");
",,
implicit_predicate,fetch.c,1869,+,-,"if (force)
    strvec_push(argv, ""--force"");
",,
implicit_predicate,fetch.c,1871,+,-,"if (keep)
    strvec_push(argv, ""--keep"");
",,
implicit_predicate,fetch.c,1948,+,-,"if (result){
    strbuf_addf(out, _(""could not fetch '%s' (exit code: %d)\n""), remote, result);
    state->result = -1;
}
",,
implicit_predicate,fetch.c,1965,+,-,"if (errcode)
    return errcode;
",,
implicit_predicate,fetch.c,2113,+,-,"if (use_stdin_refspecs){
    struct strbuf line = STRBUF_INIT;
    while (strbuf_getline_lf(&line, stdin) != EOF)
        refspec_append(&rs, line.buf);
    strbuf_release(&line);
}
",,
implicit_predicate,fetch.c,2271,+,-,"if (negotiate_only){
    switch (recurse_submodules_cli){
        case RECURSE_SUBMODULES_OFF:
        case RECURSE_SUBMODULES_DEFAULT:
            config.recurse_submodules = RECURSE_SUBMODULES_OFF;
            break;
        default:
            die(_(""options '%s' and '%s' cannot be used together""), ""--negotiate-only"", ""--recurse-submodules"");
    }
}
",,
implicit_predicate,fetch.c,2299,+,-,"if (porcelain){
    switch (recurse_submodules_cli){
        case RECURSE_SUBMODULES_OFF:
        case RECURSE_SUBMODULES_DEFAULT:
            config.recurse_submodules = RECURSE_SUBMODULES_OFF;
            break;
        default:
            die(_(""options '%s' and '%s' cannot be used together""), ""--porcelain"", ""--recurse-submodules"");
    }
    config.display_format = DISPLAY_FORMAT_PORCELAIN;
}
",,
implicit_predicate,fetch.c,2321,+,-,"if (deepen_relative){
    if (deepen_relative < 0)
        die(_(""negative depth in --deepen is not supported""));

    if (depth)
        die(_(""options '%s' and '%s' cannot be used together""), ""--deepen"", ""--depth"");

    depth = xstrfmt(""%d"", deepen_relative);
}
",,
implicit_predicate,fetch.c,2328,+,-,"if (unshallow){
    if (depth)
        die(_(""options '%s' and '%s' cannot be used together""), ""--depth"", ""--unshallow"");
    else
        if (!is_repository_shallow(the_repository))
            die(_(""--unshallow on a complete repository does not make sense""));
        else
            depth = xstrfmt(""%d"", INFINITE_DEPTH);
}
",,
implicit_predicate,fetch.c,2344,+,-,"if (dry_run)
    write_fetch_head = 0;
",,
implicit_predicate,fetch.c,2362,+,-,"if (all){
    if (argc == 1)
        die(_(""fetch --all does not take a repository argument""));
    else
        if (argc > 1)
            die(_(""fetch --all does not make sense with refspecs""));

    (void)for_each_remote(get_one_remote_for_fetch, &list);
    if (list.nr == 1)
        remote = remote_get(list.items[0].string);
}else
    if (argc == 0){
        remote = remote_get(NULL);
    }else
        if (multiple){
            for (i = 0;i < argc;i++)
                if (!add_remote_or_group(argv[i], &list))
                    die(_(""no such remote or remote group: %s""), argv[i]);
        }else{
            (void)add_remote_or_group(argv[0], &list);
            if (list.nr > 1){
                if (argc > 1)
                    die(_(""fetching a group and specifying refspecs does not make sense""));
            }else{
                remote = remote_get(argv[0]);
                prune_tags_ok = (argc == 1);
                argc--;
                argv++;
            }
        }
",,
implicit_predicate,fetch.c,2376,+,-,"if (multiple){
    for (i = 0;i < argc;i++)
        if (!add_remote_or_group(argv[i], &list))
            die(_(""no such remote or remote group: %s""), argv[i]);
}else{
    (void)add_remote_or_group(argv[0], &list);
    if (list.nr > 1){
        if (argc > 1)
            die(_(""fetching a group and specifying refspecs does not make sense""));
    }else{
        remote = remote_get(argv[0]);
        prune_tags_ok = (argc == 1);
        argc--;
        argv++;
    }
}
",,
implicit_predicate,fetch.c,2399,+,-,"if (negotiate_only){
    struct oidset acked_commits = OIDSET_INIT;
    struct oidset_iter iter;
    const struct object_id* oid;
    if (!remote)
        die(_(""must supply remote when using --negotiate-only""));

    gtransport = prepare_transport(remote, 1);
    if (gtransport->smart_options){
        gtransport->smart_options->acked_commits = &acked_commits;
    }else{
        warning(_(""protocol does not support --negotiate-only, exiting""));
        result = 1;
        goto cleanup;
    }
    if (server_options.nr)
        gtransport->server_options = &server_options;

    result = transport_fetch_refs(gtransport, NULL);
    oidset_iter_init(&acked_commits, &iter);
    while ((oid = oidset_iter_next(&iter)))
        printf(""%s\n"", oid_to_hex(oid));
    oidset_clear(&acked_commits);
}else
    if (remote){
        if (filter_options.choice || repo_has_promisor_remote(the_repository))
            fetch_one_setup_partial(remote);

        result = fetch_one(remote, argc, argv, prune_tags_ok, stdin_refspecs, &config);
    }else{
        int max_children = max_jobs;
        if (filter_options.choice)
            die(_(""--filter can only be used with the remote configured in extensions.partialclone""));

        if (atomic_fetch)
            die(_(""--atomic can only be used when fetching from one remote""));

        if (stdin_refspecs)
            die(_(""--stdin can only be used when fetching from one remote""));

        if (max_children < 0)
            max_children = config.parallel;

        result = fetch_multiple(&list, max_children, &config);
    }
",,
implicit_predicate,fetch.c,2434,+,-,"if (atomic_fetch)
    die(_(""--atomic can only be used when fetching from one remote""));
",,
implicit_predicate,fetch.c,2438,+,-,"if (stdin_refspecs)
    die(_(""--stdin can only be used when fetching from one remote""));
",,
implicit_predicate,fetch.c,2486,+,-,"if (negotiate_only)
    goto cleanup;
",,
implicit_predicate,fetch.c,2495,+,-,"if (progress)
    commit_graph_flags |= COMMIT_GRAPH_WRITE_PROGRESS;
",,
implicit_predicate,fetch.c,2503,+,-,"if (enable_auto_gc){
    if (refetch){
        int opt_val;
        if (git_config_get_int(""gc.autopacklimit"", &opt_val))
            opt_val = -1;

        if (opt_val != 0)
            git_config_push_parameter(""gc.autoPackLimit=1"");

        if (git_config_get_int(""maintenance.incremental-repack.auto"", &opt_val))
            opt_val = -1;

        if (opt_val != 0)
            git_config_push_parameter(""maintenance.incremental-repack.auto=-1"");
    }
    run_auto_maintenance(verbosity < 0);
}
",,
implicit_predicate,fetch.c,2504,+,-,"if (refetch){
    int opt_val;
    if (git_config_get_int(""gc.autopacklimit"", &opt_val))
        opt_val = -1;

    if (opt_val != 0)
        git_config_push_parameter(""gc.autoPackLimit=1"");

    if (git_config_get_int(""maintenance.incremental-repack.auto"", &opt_val))
        opt_val = -1;

    if (opt_val != 0)
        git_config_push_parameter(""maintenance.incremental-repack.auto=-1"");
}
",,
implicit_predicate,files-backend.c,543,+,-,"if (ret)
    return ret;
",,
implicit_predicate,files-backend.c,551,+,-,"if (ret)
    return ret;
",,
implicit_predicate,files-backend.c,653,+,-,"if (mustexist){
    strbuf_reset(err);
    strbuf_addf(err, ""unable to resolve reference '%s'"", refname);
}else{
    ret = TRANSACTION_NAME_CONFLICT;
}
",,
implicit_predicate,files-backend.c,661,+,-,"if (mustexist){
    strbuf_reset(err);
    strbuf_addf(err, ""unable to resolve reference '%s'"", refname);
}else{
    ret = TRANSACTION_NAME_CONFLICT;
}
",,
implicit_predicate,files-backend.c,715,+,-,"if (files_read_raw_ref(&refs->base, refname, &lock->old_oid, referent, type, &failure_errno)){
    if (failure_errno == ENOENT){
        if (mustexist){
            strbuf_addf(err, ""unable to resolve reference '%s'"", refname);
            goto error_return;
        }else{
        }
    }else
        if (failure_errno == EISDIR){
            if (mustexist){
                strbuf_addf(err, ""unable to resolve reference '%s'"", refname);
                goto error_return;
            }else
                if (remove_dir_recursively(&ref_file, REMOVE_DIR_EMPTY_ONLY)){
                    if (refs_verify_refname_available(&refs->base, refname, extras, NULL, err)){
                        ret = TRANSACTION_NAME_CONFLICT;
                        goto error_return;
                    }else{
                        strbuf_addf(err, ""there is a non-empty directory '%s' blocking reference '%s'"", ref_file.buf, refname);
                        goto error_return;
                    }
                }
        }else
            if (failure_errno == EINVAL && (*type & REF_ISBROKEN)){
                strbuf_addf(err, ""unable to resolve reference '%s': reference broken"", refname);
                goto error_return;
            }else{
                strbuf_addf(err, ""unable to resolve reference '%s': %s"", refname, strerror(failure_errno));
                goto error_return;
            }

    if (refs_verify_refname_available(refs->packed_ref_store, refname, extras, NULL, err)){
        ret = TRANSACTION_NAME_CONFLICT;
        goto error_return;
    }
}
",,
implicit_predicate,files-backend.c,718,+,-,"if (mustexist){
    strbuf_addf(err, ""unable to resolve reference '%s'"", refname);
    goto error_return;
}else{
}
",,
implicit_predicate,files-backend.c,723,+,-,"if (files_read_raw_ref(&refs->base, refname, &lock->old_oid, referent, type, &failure_errno)){
    if (failure_errno == ENOENT){
        if (mustexist){
            strbuf_addf(err, ""unable to resolve reference '%s'"", refname);
            goto error_return;
        }else{
        }
    }else
        if (failure_errno == EISDIR){
            if (mustexist){
                strbuf_addf(err, ""unable to resolve reference '%s'"", refname);
                goto error_return;
            }else
                if (remove_dir_recursively(&ref_file, REMOVE_DIR_EMPTY_ONLY)){
                    if (refs_verify_refname_available(&refs->base, refname, extras, NULL, err)){
                        ret = TRANSACTION_NAME_CONFLICT;
                        goto error_return;
                    }else{
                        strbuf_addf(err, ""there is a non-empty directory '%s' blocking reference '%s'"", ref_file.buf, refname);
                        goto error_return;
                    }
                }
        }else
            if (failure_errno == EINVAL && (*type & REF_ISBROKEN)){
                strbuf_addf(err, ""unable to resolve reference '%s': reference broken"", refname);
                goto error_return;
            }else{
                strbuf_addf(err, ""unable to resolve reference '%s': %s"", refname, strerror(failure_errno));
                goto error_return;
            }

    if (refs_verify_refname_available(refs->packed_ref_store, refname, extras, NULL, err)){
        ret = TRANSACTION_NAME_CONFLICT;
        goto error_return;
    }
}
",,
implicit_predicate,files-backend.c,726,+,-,"if (mustexist){
    strbuf_addf(err, ""unable to resolve reference '%s'"", refname);
    goto error_return;
}else{
}
",,
implicit_predicate,files-backend.c,750,+,-,"if (mustexist){
    strbuf_addf(err, ""unable to resolve reference '%s'"", refname);
    goto error_return;
}else
    if (remove_dir_recursively(&ref_file, REMOVE_DIR_EMPTY_ONLY)){
        if (refs_verify_refname_available(&refs->base, refname, extras, NULL, err)){
            ret = TRANSACTION_NAME_CONFLICT;
            goto error_return;
        }else{
            strbuf_addf(err, ""there is a non-empty directory '%s' blocking reference '%s'"", ref_file.buf, refname);
            goto error_return;
        }
    }
",,
implicit_predicate,files-backend.c,758,+,-,"if (mustexist){
    strbuf_addf(err, ""unable to resolve reference '%s'"", refname);
    goto error_return;
}else
    if (remove_dir_recursively(&ref_file, REMOVE_DIR_EMPTY_ONLY)){
        if (refs_verify_refname_available(&refs->base, refname, extras, NULL, err)){
            ret = TRANSACTION_NAME_CONFLICT;
            goto error_return;
        }else{
            strbuf_addf(err, ""there is a non-empty directory '%s' blocking reference '%s'"", ref_file.buf, refname);
            goto error_return;
        }
    }
",,
implicit_predicate,files-backend.c,1163,+,-,"while (flags & (REMOVE_EMPTY_PARENTS_REF | REMOVE_EMPTY_PARENTS_REFLOG)){
    while (q > p && *q != '/')
        q--;
    while (q > p && *(q - 1) == '/')
        q--;
    if (q == p)
        break;

    strbuf_setlen(&buf, q - buf.buf);
    strbuf_reset(&sb);
    files_ref_path(refs, &sb, buf.buf);
    if ((flags & REMOVE_EMPTY_PARENTS_REF) && rmdir(sb.buf))
        flags &= ~REMOVE_EMPTY_PARENTS_REF;

    strbuf_reset(&sb);
    files_reflog_path(refs, &sb, buf.buf);
    if ((flags & REMOVE_EMPTY_PARENTS_REFLOG) && rmdir(sb.buf))
        flags &= ~REMOVE_EMPTY_PARENTS_REFLOG;
}
",,
implicit_predicate,files-backend.c,1171,+,-,"while (flags & (REMOVE_EMPTY_PARENTS_REF | REMOVE_EMPTY_PARENTS_REFLOG)){
    while (q > p && *q != '/')
        q--;
    while (q > p && *(q - 1) == '/')
        q--;
    if (q == p)
        break;

    strbuf_setlen(&buf, q - buf.buf);
    strbuf_reset(&sb);
    files_ref_path(refs, &sb, buf.buf);
    if ((flags & REMOVE_EMPTY_PARENTS_REF) && rmdir(sb.buf))
        flags &= ~REMOVE_EMPTY_PARENTS_REF;

    strbuf_reset(&sb);
    files_reflog_path(refs, &sb, buf.buf);
    if ((flags & REMOVE_EMPTY_PARENTS_REFLOG) && rmdir(sb.buf))
        flags &= ~REMOVE_EMPTY_PARENTS_REFLOG;
}
",,
implicit_predicate,files-backend.c,1209,+,-,"if (ret)
    error(""%s"", err.buf);
",,
implicit_predicate,files-backend.c,1217,+,-,"if (ret)
    error(""%s"", err.buf);
",,
implicit_predicate,files-backend.c,1371,+,-,"if (ret){
    if (errno == EISDIR)
        error(""directory not empty: %s"", path.buf);
    else
        error(""unable to move logfile %s to %s: %s"", tmp.buf, path.buf, strerror(cb.true_errno));
}
",,
implicit_predicate,files-backend.c,1380,+,-,"if (ret){
    if (errno == EISDIR)
        error(""directory not empty: %s"", path.buf);
    else
        error(""unable to move logfile %s to %s: %s"", tmp.buf, path.buf, strerror(cb.true_errno));
}
",,
implicit_predicate,files-backend.c,1456,+,-,"if (copy)
    ret = error(""refname %s is a symbolic ref, copying it is not supported"", oldrefname);
else
    ret = error(""refname %s is a symbolic ref, renaming it is not supported"", oldrefname);
",,
implicit_predicate,files-backend.c,1466,+,-,"if (copy)
    ret = error(""refname %s is a symbolic ref, copying it is not supported"", oldrefname);
else
    ret = error(""refname %s is a symbolic ref, renaming it is not supported"", oldrefname);
",,
implicit_predicate,files-backend.c,1507,+,-,"if (result){
    error(""Directory not empty: %s"", newrefname);
    goto rollback;
}
",,
implicit_predicate,files-backend.c,1517,+,-,"if (result){
    error(""Directory not empty: %s"", newrefname);
    goto rollback;
}
",,
implicit_predicate,files-backend.c,1524,+,-,"if (copy)
    error(""unable to copy '%s' to '%s': %s"", oldrefname, newrefname, err.buf);
else
    error(""unable to rename '%s' to '%s': %s"", oldrefname, newrefname, err.buf);
",,
implicit_predicate,files-backend.c,1534,+,-,"if (copy)
    error(""unable to copy '%s' to '%s': %s"", oldrefname, newrefname, err.buf);
else
    error(""unable to rename '%s' to '%s': %s"", oldrefname, newrefname, err.buf);
",,
implicit_predicate,files-backend.c,1660,+,-,"if (raceproof_create_file(logfile, open_or_create_logfile, logfd)){
    if (errno == ENOENT)
        strbuf_addf(err, ""unable to create directory for '%s': %s"", logfile, strerror(errno));
    else
        if (errno == EISDIR)
            strbuf_addf(err, ""there are still logs under '%s'"", logfile);
        else
            strbuf_addf(err, ""unable to append to '%s': %s"", logfile, strerror(errno));

    goto error;
}
",,
implicit_predicate,files-backend.c,1670,+,-,"if (raceproof_create_file(logfile, open_or_create_logfile, logfd)){
    if (errno == ENOENT)
        strbuf_addf(err, ""unable to create directory for '%s': %s"", logfile, strerror(errno));
    else
        if (errno == EISDIR)
            strbuf_addf(err, ""there are still logs under '%s'"", logfile);
        else
            strbuf_addf(err, ""unable to append to '%s': %s"", logfile, strerror(errno));

    goto error;
}
",,
implicit_predicate,files-backend.c,1710,+,-,"if (log_ref_setup(refs, refname, 1, &fd, err))
    return -1;
",,
implicit_predicate,files-backend.c,1720,+,-,"if (log_ref_setup(refs, refname, 1, &fd, err))
    return -1;
",,
implicit_predicate,files-backend.c,1746,-,+,,25,		log_all_ref_updates = is_bare_repository() ? LOG_REFS_NONE : LOG_REFS_NORMAL;
implicit_predicate,files-backend.c,1752,+,-,"if (result)
    return result;
",,
implicit_predicate,files-backend.c,1759,+,-,"if (result){
    struct strbuf sb = STRBUF_INIT;
    int save_errno = errno;
    files_reflog_path(refs, &sb, refname);
    strbuf_addf(err, ""unable to append to '%s': %s"", sb.buf, strerror(save_errno));
    strbuf_release(&sb);
    close(logfd);
    return -1;
}
",,
implicit_predicate,files-backend.c,1762,+,-,"if (result)
    return result;
",,
implicit_predicate,files-backend.c,1769,+,-,"if (result){
    struct strbuf sb = STRBUF_INIT;
    int save_errno = errno;
    files_reflog_path(refs, &sb, refname);
    strbuf_addf(err, ""unable to append to '%s': %s"", sb.buf, strerror(save_errno));
    strbuf_release(&sb);
    close(logfd);
    return -1;
}
",,
implicit_predicate,files-backend.c,1840,+,-,"if (files_log_ref_write(refs, lock->ref_name, &lock->old_oid, oid, logmsg, 0, err)){
    char* old_msg = strbuf_detach(err, NULL);
    strbuf_addf(err, ""cannot update the ref '%s': %s"", lock->ref_name, old_msg);
    free(old_msg);
    unlock_ref(lock);
    return -1;
}
",,
implicit_predicate,files-backend.c,1851,+,-,"if (files_log_ref_write(refs, lock->ref_name, &lock->old_oid, oid, logmsg, 0, err)){
    char* old_msg = strbuf_detach(err, NULL);
    strbuf_addf(err, ""cannot update the ref '%s': %s"", lock->ref_name, old_msg);
    free(old_msg);
    unlock_ref(lock);
    return -1;
}
",,
implicit_predicate,files-backend.c,1873,+,-,"if (files_log_ref_write(refs, ""HEAD"", &lock->old_oid, oid, logmsg, 0, &log_err)){
    error(""%s"", log_err.buf);
    strbuf_release(&log_err);
}
",,
implicit_predicate,files-backend.c,1882,+,-,"if (commit_ref(lock)){
    strbuf_addf(err, ""couldn't set '%s'"", lock->ref_name);
    unlock_ref(lock);
    return -1;
}
",,
implicit_predicate,files-backend.c,1884,+,-,"if (files_log_ref_write(refs, ""HEAD"", &lock->old_oid, oid, logmsg, 0, &log_err)){
    error(""%s"", log_err.buf);
    strbuf_release(&log_err);
}
",,
implicit_predicate,files-backend.c,1893,+,-,"if (commit_ref(lock)){
    strbuf_addf(err, ""couldn't set '%s'"", lock->ref_name);
    unlock_ref(lock);
    return -1;
}
",,
implicit_predicate,files-backend.c,1901,+,-,"if (ret)
    fprintf(stderr, ""no symlink - falling back to symbolic ref\n"");
",,
implicit_predicate,files-backend.c,1912,+,-,"if (ret)
    fprintf(stderr, ""no symlink - falling back to symbolic ref\n"");
",,
implicit_predicate,files-backend.c,2067,+,-,"if (ret)
    break;
",,
implicit_predicate,files-backend.c,2078,+,-,"if (ret)
    break;
",,
implicit_predicate,files-backend.c,2332,-,+,,4,"			update->new_target ? NULL : &update->new_oid,"
implicit_predicate,files-backend.c,2333,-,+,,4,"			update->old_target ? NULL : &update->old_oid,"
implicit_predicate,files-backend.c,2428,+,-,"if (ret)
    goto out;
",,
implicit_predicate,files-backend.c,2436,+,-,"if (ret){
    char* reason;
    reason = strbuf_detach(err, NULL);
    strbuf_addf(err, ""cannot lock ref '%s': %s"", ref_update_original_update_refname(update), reason);
    free(reason);
    goto out;
}
",,
implicit_predicate,files-backend.c,2439,+,-,"if (ret)
    goto out;
",,
implicit_predicate,files-backend.c,2447,+,-,"if (ret){
    char* reason;
    reason = strbuf_detach(err, NULL);
    strbuf_addf(err, ""cannot lock ref '%s': %s"", ref_update_original_update_refname(update), reason);
    free(reason);
    goto out;
}
",,
implicit_predicate,files-backend.c,2472,+,-,"if (check_old_oid(update, &lock->old_oid, err)){
    ret = TRANSACTION_GENERIC_ERROR;
    goto out;
}
",,
implicit_predicate,files-backend.c,2483,+,-,"if (check_old_oid(update, &lock->old_oid, err)){
    ret = TRANSACTION_GENERIC_ERROR;
    goto out;
}
",,
implicit_predicate,files-backend.c,2487,+,-,"if (ret)
    goto out;
",,
implicit_predicate,files-backend.c,2498,+,-,"if (ret)
    goto out;
",,
implicit_predicate,files-backend.c,2503,+,-,"if (check_old_oid(update, &lock->old_oid, err)){
    ret = TRANSACTION_GENERIC_ERROR;
    goto out;
}
",,
implicit_predicate,files-backend.c,2514,+,-,"if (check_old_oid(update, &lock->old_oid, err)){
    ret = TRANSACTION_GENERIC_ERROR;
    goto out;
}
",,
implicit_predicate,files-backend.c,2528,+,-,"if (close_ref_gently(lock)){
    strbuf_addf(err, ""couldn't close '%s.lock'"", update->refname);
    ret = TRANSACTION_GENERIC_ERROR;
    goto out;
}
",,
implicit_predicate,files-backend.c,2539,+,-,"if (close_ref_gently(lock)){
    strbuf_addf(err, ""couldn't close '%s.lock'"", update->refname);
    ret = TRANSACTION_GENERIC_ERROR;
    goto out;
}
",,
implicit_predicate,files-backend.c,2576,+,-,"if (close_ref_gently(lock)){
    strbuf_addf(err, ""couldn't close '%s.lock'"", update->refname);
    ret = TRANSACTION_GENERIC_ERROR;
    goto out;
}
",,
implicit_predicate,files-backend.c,2587,+,-,"if (close_ref_gently(lock)){
    strbuf_addf(err, ""couldn't close '%s.lock'"", update->refname);
    ret = TRANSACTION_GENERIC_ERROR;
    goto out;
}
",,
implicit_predicate,files-backend.c,2623,+,-,"if (backend_data->packed_refs_locked)
    packed_refs_unlock(refs->packed_ref_store);
",,
implicit_predicate,files-backend.c,2634,+,-,"if (backend_data->packed_refs_locked)
    packed_refs_unlock(refs->packed_ref_store);
",,
implicit_predicate,files-backend.c,2724,+,-,"if (ret)
    goto cleanup;
",,
implicit_predicate,files-backend.c,2735,+,-,"if (ret)
    goto cleanup;
",,
implicit_predicate,files-backend.c,2770,+,-,"if (ret){
    ref_transaction_free(packed_transaction);
    backend_data->packed_transaction = NULL;
}
",,
implicit_predicate,files-backend.c,2781,+,-,"if (ret){
    ref_transaction_free(packed_transaction);
    backend_data->packed_transaction = NULL;
}
",,
implicit_predicate,files-backend.c,2797,+,-,"if (ret)
    files_transaction_cleanup(refs, transaction);
else
    transaction->state = REF_TRANSACTION_PREPARED;
",,
implicit_predicate,files-backend.c,2808,+,-,"if (ret)
    files_transaction_cleanup(refs, transaction);
else
    transaction->state = REF_TRANSACTION_PREPARED;
",,
implicit_predicate,files-backend.c,2872,+,-,"if (parse_and_write_reflog(refs, update, lock, err)){
    ret = TRANSACTION_GENERIC_ERROR;
    goto cleanup;
}
",,
implicit_predicate,files-backend.c,2883,+,-,"if (parse_and_write_reflog(refs, update, lock, err)){
    ret = TRANSACTION_GENERIC_ERROR;
    goto cleanup;
}
",,
implicit_predicate,files-backend.c,2888,+,-,"if (commit_ref(lock)){
    strbuf_addf(err, ""couldn't set '%s'"", lock->ref_name);
    unlock_ref(lock);
    update->backend_data = NULL;
    ret = TRANSACTION_GENERIC_ERROR;
    goto cleanup;
}
",,
implicit_predicate,files-backend.c,2899,+,-,"if (commit_ref(lock)){
    strbuf_addf(err, ""couldn't set '%s'"", lock->ref_name);
    unlock_ref(lock);
    update->backend_data = NULL;
    ret = TRANSACTION_GENERIC_ERROR;
    goto cleanup;
}
",,
implicit_predicate,files-backend.c,2930,+,-,"if (ret)
    goto cleanup;
",,
implicit_predicate,files-backend.c,2941,+,-,"if (ret)
    goto cleanup;
",,
implicit_predicate,files-backend.c,3106,+,-,"if (cb->rewrite)
    ooid = &cb->last_kept_oid;
",,
implicit_predicate,files-backend.c,3112,+,-,"if (cb->dry_run)
    return 0;
",,
implicit_predicate,files-backend.c,3117,+,-,"if (cb->rewrite)
    ooid = &cb->last_kept_oid;
",,
implicit_predicate,files-backend.c,3123,+,-,"if (cb->dry_run)
    return 0;
",,
implicit_predicate,fmt-merge-msg.c,66,+,-,"if (ret)
    return ret;
",,
implicit_predicate,fmt-merge-msg.c,135,+,-,"if (i)
    return 3;
",,
implicit_predicate,fmt-merge-msg.c,171,+,-,"if (pulling_head){
    origin = src;
    src_data->head_status |= 1;
}else
    if (skip_prefix(line, ""branch "", &origin)){
        origin_data->is_local_branch = 1;
        string_list_append(&src_data->branch, origin);
        src_data->head_status |= 2;
    }else
        if (skip_prefix(line, ""tag "", &tag_name)){
            origin = line;
            string_list_append(&src_data->tag, tag_name);
            src_data->head_status |= 2;
        }else
            if (skip_prefix(line, ""remote-tracking branch "", &origin)){
                string_list_append(&src_data->r_branch, origin);
                src_data->head_status |= 2;
            }else{
                origin = src;
                string_list_append(&src_data->generic, line);
                src_data->head_status |= 2;
            }
",,
implicit_predicate,fmt-merge-msg.c,254,+,-,"if (*name_end)
    name_end--;
",,
implicit_predicate,fmt-merge-msg.c,602,-,+,,9,		len = newline ? newline - p : strlen(p);
implicit_predicate,fmt-merge-msg.c,636,+,-,"if (result->item[i].used){
    if (i != j)
        result->item[j] = result->item[i];

    j++;
}
",,
implicit_predicate,fmt-merge-msg.c,683,-,+,,9,		len = newline ? newline - p : strlen(p);
implicit_predicate,fmt-merge-msg.c,687,+,-,"if (handle_line(p, &merge_parents))
    die(""error in line %d: %.*s"", i, len, p);
",,
implicit_predicate,for-each-ref.c,83,+,-,"if (from_stdin){
    struct strbuf line = STRBUF_INIT;
    if (argv[0])
        die(_(""unknown arguments supplied with --stdin""));

    while (strbuf_getline(&line, stdin) != EOF)
        strvec_push(&vec, line.buf);
    strbuf_release(&line);
    filter.name_patterns = vec.v;
}else{
    filter.name_patterns = argv;
}
",,
implicit_predicate,for-each-ref.c,100,+,-,"if (include_root_refs)
    flags |= FILTER_REFS_ROOT_REFS | FILTER_REFS_DETACHED_HEAD;
",,
implicit_predicate,for-each-repo.c,58,+,-,"if (err)
    return 0;
",,
implicit_predicate,for-each-repo.c,63,+,-,"if (ret){
    if (!keep_going)
        return ret;

    result = 1;
}
",,
implicit_predicate,fsck.c,196,+,-,"if (show_progress)
    progress = start_delayed_progress(_(""Checking connectivity""), 0);
",,
implicit_predicate,fsck.c,239,+,-,"if (object_on_skiplist(options, oid))
    return 0;
",,
implicit_predicate,fsck.c,300,+,-,"if (show_unreachable){
    printf_ln(_(""unreachable %s %s""), printable_type(&obj->oid, obj->type), describe_object(&obj->oid));
    return;
}
",,
implicit_predicate,fsck.c,320,+,-,"if (show_dangling)
    printf_ln(_(""dangling %s %s""), printable_type(&obj->oid, obj->type), describe_object(&obj->oid));
",,
implicit_predicate,fsck.c,324,+,-,"if (write_lost_and_found){
    char* filename = git_pathdup(""lost-found/%s/%s"", obj->type == OBJ_COMMIT ? ""commit"" : ""other"", describe_object(&obj->oid));
    FILE* f;
    if (safe_create_leading_directories_const(filename)){
        error(_(""could not create lost-found""));
        free(filename);
        return;
    }
    f = xfopen(filename, ""w"");
    if (obj->type == OBJ_BLOB){
        if (stream_blob_to_fd(fileno(f), &obj->oid, NULL, 1))
            die_errno(_(""could not write '%s'""), filename);
    }else
        fprintf(f, ""%s\n"", describe_object(&obj->oid));

    if (fclose(f))
        die_errno(_(""could not finish '%s'""), filename);

    free(filename);
}
",,
implicit_predicate,fsck.c,358,+,-,"if (verbose)
    fprintf_ln(stderr, _(""Checking %s""), describe_object(&obj->oid));
",,
implicit_predicate,fsck.c,396,+,-,"if (verbose)
    fprintf_ln(stderr, _(""Checking connectivity (%d objects)""), max);
",,
implicit_predicate,fsck.c,415,+,-,"if (verbose)
    fprintf_ln(stderr, _(""Checking %s %s""), printable_type(&obj->oid, obj->type), describe_object(&obj->oid));
",,
implicit_predicate,fsck.c,416,+,-,"if (counter++)
    fsck_put_object_name(options, oid, ""%s^%d"", name, counter);
else
    if (generation > 0)
        fsck_put_object_name(options, oid, ""%.*s~%d"", name_prefix_len, name, generation + 1);
    else
        fsck_put_object_name(options, oid, ""%s^"", name);
",,
implicit_predicate,fsck.c,423,+,-,"if (err)
    goto out;
",,
implicit_predicate,fsck.c,484,-,+,,9,	return stack->nr ? stack->names[--stack->nr] : NULL;
implicit_predicate,fsck.c,571,+,-,"if (is_less_than_slash(*p)){
    name_stack_push(candidates, f_name);
    break;
}
",,
implicit_predicate,fsck.c,582,+,-,"if (include_reflogs)
    refs_for_each_reflog(get_worktree_ref_store(wt), fsck_handle_reflog, wt);
",,
implicit_predicate,fsck.c,664,+,-,"if (fsck_obj(obj, contents, size))
    errors_found |= ERROR_OBJECT;
",,
implicit_predicate,fsck.c,696,+,-,"if (verbose)
    fprintf_ln(stderr, _(""Checking object directory""));
",,
implicit_predicate,fsck.c,699,+,-,"if (show_progress)
    progress = start_progress(_(""Checking object directories""), 256);
",,
implicit_predicate,fsck.c,715,+,-,"if (verbose)
    fprintf_ln(stderr, _(""Checking %s link""), head_ref_name);
",,
implicit_predicate,fsck.c,730,+,-,"if (has_null_sha1)
    retval += report(options, tree_oid, OBJ_TREE, FSCK_MSG_NULL_SHA1, ""contains entries pointing to null sha1"");
",,
implicit_predicate,fsck.c,732,+,-,"if (has_null_sha1)
    retval += report(options, tree_oid, OBJ_TREE, FSCK_MSG_NULL_SHA1, ""contains entries pointing to null sha1"");
",,
implicit_predicate,fsck.c,734,+,-,"if (has_full_path)
    retval += report(options, tree_oid, OBJ_TREE, FSCK_MSG_FULL_PATHNAME, ""contains full pathnames"");
",,
implicit_predicate,fsck.c,736,+,-,"if (has_full_path)
    retval += report(options, tree_oid, OBJ_TREE, FSCK_MSG_FULL_PATHNAME, ""contains full pathnames"");
",,
implicit_predicate,fsck.c,738,+,-,"if (has_empty_name)
    retval += report(options, tree_oid, OBJ_TREE, FSCK_MSG_EMPTY_NAME, ""contains empty pathname"");
",,
implicit_predicate,fsck.c,740,+,-,"if (has_empty_name)
    retval += report(options, tree_oid, OBJ_TREE, FSCK_MSG_EMPTY_NAME, ""contains empty pathname"");
",,
implicit_predicate,fsck.c,742,+,-,"if (has_dot)
    retval += report(options, tree_oid, OBJ_TREE, FSCK_MSG_HAS_DOT, ""contains '.'"");
",,
implicit_predicate,fsck.c,744,+,-,"if (has_dot)
    retval += report(options, tree_oid, OBJ_TREE, FSCK_MSG_HAS_DOT, ""contains '.'"");
",,
implicit_predicate,fsck.c,746,+,-,"if (has_dotdot)
    retval += report(options, tree_oid, OBJ_TREE, FSCK_MSG_HAS_DOTDOT, ""contains '..'"");
",,
implicit_predicate,fsck.c,748,+,-,"if (has_dotdot)
    retval += report(options, tree_oid, OBJ_TREE, FSCK_MSG_HAS_DOTDOT, ""contains '..'"");
",,
implicit_predicate,fsck.c,750,+,-,"if (has_dotgit)
    retval += report(options, tree_oid, OBJ_TREE, FSCK_MSG_HAS_DOTGIT, ""contains '.git'"");
",,
implicit_predicate,fsck.c,751,+,-,"if (verbose)
    fprintf_ln(stderr, _(""Checking cache tree of %s""), index_path);
",,
implicit_predicate,fsck.c,752,+,-,"if (has_dotgit)
    retval += report(options, tree_oid, OBJ_TREE, FSCK_MSG_HAS_DOTGIT, ""contains '.git'"");
",,
implicit_predicate,fsck.c,754,+,-,"if (has_zero_pad)
    retval += report(options, tree_oid, OBJ_TREE, FSCK_MSG_ZERO_PADDED_FILEMODE, ""contains zero-padded file modes"");
",,
implicit_predicate,fsck.c,756,+,-,"if (has_zero_pad)
    retval += report(options, tree_oid, OBJ_TREE, FSCK_MSG_ZERO_PADDED_FILEMODE, ""contains zero-padded file modes"");
",,
implicit_predicate,fsck.c,758,+,-,"if (has_bad_modes)
    retval += report(options, tree_oid, OBJ_TREE, FSCK_MSG_BAD_FILEMODE, ""contains bad file modes"");
",,
implicit_predicate,fsck.c,760,+,-,"if (has_bad_modes)
    retval += report(options, tree_oid, OBJ_TREE, FSCK_MSG_BAD_FILEMODE, ""contains bad file modes"");
",,
implicit_predicate,fsck.c,762,+,-,"if (has_dup_entries)
    retval += report(options, tree_oid, OBJ_TREE, FSCK_MSG_DUPLICATE_ENTRIES, ""contains duplicate file entries"");
",,
implicit_predicate,fsck.c,764,+,-,"if (has_dup_entries)
    retval += report(options, tree_oid, OBJ_TREE, FSCK_MSG_DUPLICATE_ENTRIES, ""contains duplicate file entries"");
",,
implicit_predicate,fsck.c,766,+,-,"if (not_properly_sorted)
    retval += report(options, tree_oid, OBJ_TREE, FSCK_MSG_TREE_NOT_SORTED, ""not properly sorted"");
",,
implicit_predicate,fsck.c,768,+,-,"if (not_properly_sorted)
    retval += report(options, tree_oid, OBJ_TREE, FSCK_MSG_TREE_NOT_SORTED, ""not properly sorted"");
",,
implicit_predicate,fsck.c,770,+,-,"if (has_large_name)
    retval += report(options, tree_oid, OBJ_TREE, FSCK_MSG_LARGE_PATHNAME, ""contains excessively large pathname"");
",,
implicit_predicate,fsck.c,772,+,-,"if (has_large_name)
    retval += report(options, tree_oid, OBJ_TREE, FSCK_MSG_LARGE_PATHNAME, ""contains excessively large pathname"");
",,
implicit_predicate,fsck.c,835,+,+,"is_current_worktree ? """" : index_path",10,"				     is_current_worktree ? """" : index_path,"
implicit_predicate,fsck.c,873,+,-,"if (show_progress){
    for (struct packed_git* p = get_all_packs(r);p;p = p->next)
        pack_count++;
    progress = start_delayed_progress(""Verifying reverse pack-indexes"", pack_count);
    pack_count = 0;
}
",,
implicit_predicate,fsck.c,909,+,-,"if (err)
    return err;
",,
implicit_predicate,fsck.c,911,+,-,"if (err)
    return err;
",,
implicit_predicate,fsck.c,916,+,-,"if (err)
    return err;
",,
implicit_predicate,fsck.c,918,+,-,"if (err)
    return err;
",,
implicit_predicate,fsck.c,925,+,-,"if (err)
    return err;
",,
implicit_predicate,fsck.c,927,+,-,"if (err)
    return err;
",,
implicit_predicate,fsck.c,932,+,-,"if (err)
    return err;
",,
implicit_predicate,fsck.c,934,+,-,"if (err)
    return err;
",,
implicit_predicate,fsck.c,937,+,-,"if (err)
    return err;
",,
implicit_predicate,fsck.c,939,+,-,"if (err)
    return err;
",,
implicit_predicate,fsck.c,942,+,-,"if (err)
    return err;
",,
implicit_predicate,fsck.c,944,+,-,"if (err)
    return err;
",,
implicit_predicate,fsck.c,947,+,-,"if (verbose)
    show_progress = 0;
",,
implicit_predicate,fsck.c,950,+,-,"if (write_lost_and_found){
    check_full = 1;
    include_reflogs = 0;
}
",,
implicit_predicate,fsck.c,955,+,-,"if (name_objects)
    fsck_enable_object_names(&fsck_walk_options);
",,
implicit_predicate,fsck.c,961,+,-,"if (connectivity_only){
    for_each_loose_object(mark_loose_for_connectivity, NULL, 0);
    for_each_packed_object(mark_packed_for_connectivity, NULL, 0);
}else{
    prepare_alt_odb(the_repository);
    for (odb = the_repository->objects->odb;odb;odb = odb->next)
        fsck_object_dir(odb->path);
    if (check_full){
        struct packed_git* p;
        uint32_t total = 0, count = 0;
        struct progress* progress = NULL;
        if (show_progress){
            for (p = get_all_packs(the_repository);p;p = p->next){
                if (open_pack_index(p))
                    continue;

                total += p->num_objects;
            }
            progress = start_progress(_(""Checking objects""), total);
        }
        for (p = get_all_packs(the_repository);p;p = p->next){
            if (verify_pack(the_repository, p, fsck_obj_buffer, progress, count))
                errors_found |= ERROR_PACK;

            count += p->num_objects;
        }
        stop_progress(&progress);
    }
    if (fsck_finish(&fsck_obj_options))
        errors_found |= ERROR_OBJECT;
}
",,
implicit_predicate,fsck.c,969,+,-,"if (check_full){
    struct packed_git* p;
    uint32_t total = 0, count = 0;
    struct progress* progress = NULL;
    if (show_progress){
        for (p = get_all_packs(the_repository);p;p = p->next){
            if (open_pack_index(p))
                continue;

            total += p->num_objects;
        }
        progress = start_progress(_(""Checking objects""), total);
    }
    for (p = get_all_packs(the_repository);p;p = p->next){
        if (verify_pack(the_repository, p, fsck_obj_buffer, progress, count))
            errors_found |= ERROR_PACK;

        count += p->num_objects;
    }
    stop_progress(&progress);
}
",,
implicit_predicate,fsck.c,974,+,-,"if (ret)
    goto done;
",,
implicit_predicate,fsck.c,976,+,-,"if (ret)
    goto done;
",,
implicit_predicate,fsck.c,983,+,-,"if (ret)
    goto done;
",,
implicit_predicate,fsck.c,985,+,-,"if (ret)
    goto done;
",,
implicit_predicate,fsck.c,1000,+,-,"if (ret)
    goto done;
",,
implicit_predicate,fsck.c,1002,+,-,"if (ret)
    goto done;
",,
implicit_predicate,fsck.c,1019,+,-,"if (ret)
    goto done;
",,
implicit_predicate,fsck.c,1021,+,-,"if (ret)
    goto done;
",,
implicit_predicate,fsck.c,1027,+,-,"if (ret)
    goto done;
",,
implicit_predicate,fsck.c,1029,+,-,"if (ret)
    goto done;
",,
implicit_predicate,fsck.c,1035,+,-,"if (keep_cache_objects){
    struct worktree **worktrees, **p;
    verify_index_checksum = 1;
    verify_ce_order = 1;
    worktrees = get_worktrees();
    for (p = worktrees;*p;p++){
        struct worktree* wt = *p;
        struct index_state istate = INDEX_STATE_INIT(the_repository);
        char* path;
        path = xstrdup(worktree_git_path(wt, ""index""));
        read_index_from(&istate, path, get_worktree_git_dir(wt));
        fsck_index(&istate, path, wt->is_current);
        discard_index(&istate);
        free(path);
    }
    free_worktrees(worktrees);
}
",,
implicit_predicate,fsck.c,1042,+,-,"if (ret)
    goto done;
",,
implicit_predicate,fsck.c,1044,+,-,"if (ret)
    goto done;
",,
implicit_predicate,fsck.c,1077,+,-,"if (show_progress)
    strvec_push(&commit_graph_verify.args, ""--progress"");
else
    strvec_push(&commit_graph_verify.args, ""--no-progress"");
",,
implicit_predicate,fsck.c,1095,+,-,"if (show_progress)
    strvec_push(&midx_verify.args, ""--progress"");
else
    strvec_push(&midx_verify.args, ""--no-progress"");
",,
implicit_predicate,fsck.c,1107,+,-,"if (object_on_skiplist(options, oid))
    return 0;
",,
implicit_predicate,fsck.c,1109,+,-,"if (object_on_skiplist(options, oid))
    return 0;
",,
implicit_predicate,fsck.c,1167,-,+,,10,			ptr = *eol ? eol + 1 : eol;
implicit_predicate,fsck.c,1217,+,+,c ? slash + 1 : NULL,10,			ptr = c ? slash + 1 : NULL;
implicit_predicate,fsm-health-win32.c,161,+,-,"if (r)
    return r;
",,
implicit_predicate,fsm-health-win32.c,228,+,-,"if (r)
    return r;
",,
implicit_predicate,fsm-listen-darwin.c,473,+,-,"if (data->stream_started)
    FSEventStreamStop(data->stream);
",,
implicit_predicate,fsm-listen-darwin.c,475,+,-,"if (data->stream_scheduled)
    FSEventStreamInvalidate(data->stream);
",,
implicit_predicate,fsm-listen-win32.c,150,+,-,"for (last = p = buf_out;*p;p++)
    if (*p == L'/' || *p == '\\')
        last = p + 1;
",,
implicit_predicate,fsm-path-utils-darwin.c,43,+,-,"if (fsmonitor__get_fs_info(path, &fs))
    return -1;
",,
implicit_predicate,fsm-path-utils-win32.c,127,+,-,"if (fsmonitor__get_fs_info(path, &fs))
    return -1;
",,
implicit_predicate,fsm-settings-darwin.c,56,+,-,"if (ipc){
    reason = check_uds_volume(r);
    if (reason != FSMONITOR_REASON_OK)
        return reason;
}
",,
implicit_predicate,fsmonitor-settings.c,121,+,-,"if (bool_value)
    fsm_settings__set_ipc(r);
else
    fsm_settings__set_disabled(r);
",,
implicit_predicate,fsmonitor.c,176,+,-,"if (result)
    trace2_data_intmax(""fsm_hook"", NULL, ""query/failed"", result);
else
    trace2_data_intmax(""fsm_hook"", NULL, ""query/response-length"", query_result->len);
",,
implicit_predicate,fsmonitor.c,534,-,+,,4,"			istate->fsmonitor_last_update ?
			istate->fsmonitor_last_update : ""builtin:fake"","
implicit_predicate,fsmonitor.c,537,+,-,"if (query_success){
    buf = query_result.buf;
    strbuf_addstr(&last_update_token, buf);
    bol = last_update_token.len + 1;
    is_trivial = query_result.buf[bol] == '/';
    if (is_trivial)
        trace2_data_intmax(""fsm_client"", NULL, ""query/trivial-response"", 1);
}else{
    strbuf_addstr(&last_update_token, ""builtin:fake"");
}
",,
implicit_predicate,fsmonitor.c,551,+,-,"if (is_trivial)
    trace2_data_intmax(""fsm_client"", NULL, ""query/trivial-response"", 1);
",,
implicit_predicate,fsmonitor.c,593,+,-,<!!!>,,
implicit_predicate,fsmonitor.c,624,+,-,"if (query_success)
    is_trivial = query_result.buf[0] == '/';
",,
implicit_predicate,fsmonitor.c,628,+,-,"if (is_trivial)
    trace2_data_intmax(""fsm_hook"", NULL, ""query/trivial-response"", 1);
",,
implicit_predicate,fsmonitor.c,637,+,-,"query_success ? ""success"" : ""failure""",,
implicit_predicate,fsmonitor.c,709,+,-,"if (is_cache_changed)
    istate->cache_changed |= FSMONITOR_CHANGED;
",,
implicit_predicate,fsmonitor.c,795,+,-,"if (fsmonitor_enabled){
    for (i = 0;i < istate->cache_nr;i++){
        if (S_ISGITLINK(istate->cache[i]->ce_mode))
            continue;

        istate->cache[i]->ce_flags |= CE_FSMONITOR_VALID;
    }
    assert_index_minimum(istate, istate->fsmonitor_dirty->bit_size);
    ewah_each_bit(istate->fsmonitor_dirty, fsmonitor_ewah_callback, istate);
    refresh_fsmonitor(istate);
}
",,
implicit_predicate,fsmonitor.c,814,+,-,"if (fsmonitor_enabled)
    add_fsmonitor(istate);
else
    remove_fsmonitor(istate);
",,
implicit_predicate,gc.c,272,+,-,"if (limit){
    if (p->pack_size >= limit)
        string_list_append(packs, p->pack_name);
}else
    if (!base || base->pack_size < p->pack_size){
        base = p;
    }
",,
implicit_predicate,gc.c,391,+,-,"if (cruft_packs){
    strvec_push(&repack, ""--cruft"");
    if (prune_expire)
        strvec_pushf(&repack, ""--cruft-expiration=%s"", prune_expire);

    if (max_cruft_size)
        strvec_pushf(&repack, ""--max-cruft-size=%lu"", max_cruft_size);
}else{
    strvec_push(&repack, ""-A"");
    if (prune_expire)
        strvec_pushf(&repack, ""--unpack-unreachable=%s"", prune_expire);
}
",,
implicit_predicate,gc.c,395,+,-,"if (max_cruft_size)
    strvec_pushf(&repack, ""--max-cruft-size=%lu"", max_cruft_size);
",,
implicit_predicate,gc.c,433,+,-,"if (too_many_packs()){
    struct string_list keep_pack = STRING_LIST_INIT_NODUP;
    if (big_pack_threshold){
        find_base_packs(&keep_pack, big_pack_threshold);
        if (keep_pack.nr >= gc_auto_pack_limit){
            big_pack_threshold = 0;
            string_list_clear(&keep_pack, 0);
            find_base_packs(&keep_pack, 0);
        }
    }else{
        struct packed_git* p = find_base_packs(&keep_pack, 0);
        uint64_t mem_have, mem_want;
        mem_have = total_ram();
        mem_want = estimate_repack_memory(p);
        if (!mem_have || mem_want < mem_have / 2)
            string_list_clear(&keep_pack, 0);
    }
    add_repack_all_option(&keep_pack);
    string_list_clear(&keep_pack, 0);
}else
    if (too_many_loose_objects())
        add_repack_incremental_option();
    else
        return 0;
",,
implicit_predicate,gc.c,436,+,-,"if (big_pack_threshold){
    find_base_packs(&keep_pack, big_pack_threshold);
    if (keep_pack.nr >= gc_auto_pack_limit){
        big_pack_threshold = 0;
        string_list_clear(&keep_pack, 0);
        find_base_packs(&keep_pack, 0);
    }
}else{
    struct packed_git* p = find_base_packs(&keep_pack, 0);
    uint64_t mem_have, mem_want;
    mem_have = total_ram();
    mem_want = estimate_repack_memory(p);
    if (!mem_have || mem_want < mem_have / 2)
        string_list_clear(&keep_pack, 0);
}
",,
implicit_predicate,gc.c,461,+,-,"if (too_many_loose_objects())
    add_repack_incremental_option();
else
    return 0;
",,
implicit_predicate,gc.c,520,+,-,"if (should_exit){
    if (fd >= 0)
        rollback_lock_file(&lock);

    *ret_pid = pid;
    free(pidfile_path);
    return locking_host;
}
",,
implicit_predicate,gc.c,596,+,-,"if (done++)
    return;
",,
implicit_predicate,gc.c,602,+,-,"if (prune_reflogs){
    struct child_process cmd = CHILD_PROCESS_INIT;
    cmd.git_cmd = 1;
    strvec_pushv(&cmd.args, reflog.v);
    if (run_command(&cmd))
        die(FAILED_RUN, reflog.v[0]);
}
",,
implicit_predicate,gc.c,669,+,-,"if (aggressive){
    strvec_push(&repack, ""-f"");
    if (aggressive_depth > 0)
        strvec_pushf(&repack, ""--depth=%d"", aggressive_depth);

    if (aggressive_window > 0)
        strvec_pushf(&repack, ""--window=%d"", aggressive_window);
}
",,
implicit_predicate,gc.c,676,+,-,"if (quiet)
    strvec_push(&repack, ""-q"");
",,
implicit_predicate,gc.c,679,+,-,"if (opts.auto_flag){
    if (!need_to_gc())
        return 0;

    if (!quiet){
        if (detach_auto)
            fprintf(stderr, _(""Auto packing the repository in background for optimum performance.\n""));
        else
            fprintf(stderr, _(""Auto packing the repository for optimum performance.\n""));

        fprintf(stderr, _(""See \""git help gc\"" for manual housekeeping.\n""));
    }
    if (detach_auto){
        int ret = report_last_gc_error();
        if (ret == 1)
            return 0;
        else
            if (ret)
                return ret;

        if (lock_repo_for_gc(force, &pid))
            return 0;

        gc_before_repack(&opts);
        delete_tempfile(&pidfile);
        daemonized = !daemonize();
    }
}else{
    struct string_list keep_pack = STRING_LIST_INIT_NODUP;
    if (keep_largest_pack != -1){
        if (keep_largest_pack)
            find_base_packs(&keep_pack, 0);
    }else
        if (big_pack_threshold){
            find_base_packs(&keep_pack, big_pack_threshold);
        }

    add_repack_all_option(&keep_pack);
    string_list_clear(&keep_pack, 0);
}
",,
implicit_predicate,gc.c,686,+,-,"if (detach_auto)
    fprintf(stderr, _(""Auto packing the repository in background for optimum performance.\n""));
else
    fprintf(stderr, _(""Auto packing the repository for optimum performance.\n""));
",,
implicit_predicate,gc.c,692,+,-,"if (detach_auto){
    int ret = report_last_gc_error();
    if (ret == 1)
        return 0;
    else
        if (ret)
            return ret;

    if (lock_repo_for_gc(force, &pid))
        return 0;

    gc_before_repack(&opts);
    delete_tempfile(&pidfile);
    daemonized = !daemonize();
}
",,
implicit_predicate,gc.c,698,+,-,"if (ret)
    return ret;
",,
implicit_predicate,gc.c,717,+,-,"if (keep_largest_pack)
    find_base_packs(&keep_pack, 0);
",,
implicit_predicate,gc.c,719,+,-,"if (big_pack_threshold){
    find_base_packs(&keep_pack, big_pack_threshold);
}
",,
implicit_predicate,gc.c,729,+,-,"if (opts.auto_flag)
    return 0;
",,
implicit_predicate,gc.c,735,+,-,"if (daemonized){
    hold_lock_file_for_update(&log_lock, git_path(""gc.log""), LOCK_DIE_ON_ERROR);
    dup2(get_lock_file_fd(&log_lock), 2);
    sigchain_push_common(process_log_file_on_signal);
    atexit(process_log_file_at_exit);
}
",,
implicit_predicate,gc.c,760,+,-,"if (quiet)
    strvec_push(&prune, ""--no-progress"");
",,
implicit_predicate,gc.c,819,+,-,"if (unset)
    die(_(""--no-schedule is not allowed""));
",,
implicit_predicate,gc.c,926,+,-,"if (opts->quiet)
    strvec_push(&child.args, ""--no-progress"");
",,
implicit_predicate,gc.c,938,+,-,"if (run_write_commit_graph(opts)){
    error(_(""failed to write commit-graph""));
    return 1;
}
",,
implicit_predicate,gc.c,960,+,-,"if (opts->quiet)
    strvec_push(&child.args, ""--quiet"");
",,
implicit_predicate,gc.c,983,+,-,"if (opts->auto_flag)
    strvec_push(&child.args, ""--auto"");
",,
implicit_predicate,gc.c,985,+,-,"if (opts->quiet)
    strvec_push(&child.args, ""--quiet"");
else
    strvec_push(&child.args, ""--no-quiet"");
",,
implicit_predicate,gc.c,1000,+,-,"if (opts->quiet)
    strvec_push(&child.args, ""--quiet"");
",,
implicit_predicate,gc.c,1078,+,-,"if (opts->quiet)
    strvec_push(&pack_proc.args, ""--quiet"");
",,
implicit_predicate,gc.c,1149,+,-,"if (opts->quiet)
    strvec_push(&child.args, ""--no-progress"");
",,
implicit_predicate,gc.c,1165,+,-,"if (opts->quiet)
    strvec_push(&child.args, ""--no-progress"");
",,
implicit_predicate,gc.c,1221,+,-,"if (opts->quiet)
    strvec_push(&child.args, ""--no-progress"");
",,
implicit_predicate,gc.c,1241,+,-,"if (multi_pack_index_write(opts))
    return 1;
",,
implicit_predicate,gc.c,1243,+,-,"if (multi_pack_index_expire(opts))
    return 1;
",,
implicit_predicate,gc.c,1245,+,-,"if (multi_pack_index_repack(opts))
    return 1;
",,
implicit_predicate,gc.c,1351,+,-,"if (found_selected)
    QSORT(tasks, TASK__COUNT, compare_tasks_by_selection);
",,
implicit_predicate,gc.c,1370,+,-,"if (tasks[i].fn(opts)){
    error(_(""task '%s' failed""), tasks[i].name);
    result = 1;
}
",,
implicit_predicate,gc.c,1409,+,-,"if (schedule)
    initialize_maintenance_strategy();
",,
implicit_predicate,gc.c,1510,-,+,,18,"	const char *p = the_repository->worktree ?
		the_repository->worktree : the_repository->gitdir;"
implicit_predicate,gc.c,1537,+,-,"if (argc)
    usage_with_options(builtin_maintenance_register_usage, options);
",,
implicit_predicate,gc.c,1572,+,-,"if (rc)
    die(_(""unable to add '%s' value of '%s'""), key, maintpath);
",,
implicit_predicate,gc.c,1606,+,-,"if (argc)
    usage_with_options(builtin_maintenance_unregister_usage, options);
",,
implicit_predicate,gc.c,1614,-,+,,8,"	if (!(config_file
	      ? git_configset_get_string_multi(&cs, key, &list)
	      : git_config_get_string_multi(key, &list))) {"
implicit_predicate,gc.c,1625,+,-,"if (found){
    int rc;
    char* global_config_file = NULL;
    if (!config_file){
        global_config_file = git_global_config();
        config_file = global_config_file;
    }
    if (!config_file)
        die(_(""$HOME not set""));

    rc = git_config_set_multivar_in_file_gently(config_file, key, NULL, maintpath, NULL, CONFIG_FLAGS_MULTI_REPLACE | CONFIG_FLAGS_FIXED_VALUE);
    free(global_config_file);
    if (rc && (!force || rc == CONFIG_NOTHING_SET))
        die(_(""unable to unset '%s' value of '%s'""), key, maintpath);
}else
    if (!force){
        die(_(""repository '%s' is not registered""), maintpath);
    }
",,
implicit_predicate,gc.c,1753,+,-,"if (get_schedule_cmd(&cmd, &is_available))
    return is_available;
",,
implicit_predicate,gc.c,1798,+,+,"enable ? ""bootstrap"" : ""bootout""",28,"	strvec_pushl(&child.args, enable ? ""bootstrap"" : ""bootout"", uid,"
implicit_predicate,gc.c,1947,+,-,"if (launchctl_boot_plist(1, filename))
    die(_(""failed to bootstrap service %s""), filename);
",,
implicit_predicate,gc.c,1979,+,-,"if (get_schedule_cmd(&cmd, &is_available))
    return is_available;
",,
implicit_predicate,gc.c,2180,+,-,"if (get_schedule_cmd(&cmd, &is_available))
    return is_available;
",,
implicit_predicate,gc.c,2250,+,-,"if (run_maintenance){
    struct strbuf line_format = STRBUF_INIT;
    const char* exec_path = git_exec_path();
    fprintf(cron_in, ""%s\n"", BEGIN_LINE);
    fprintf(cron_in, ""# The following schedule was created by Git\n"");
    fprintf(cron_in, ""# Any edits made in this region might be\n"");
    fprintf(cron_in, ""# replaced in the future by a Git command.\n\n"");
    strbuf_addf(&line_format, ""%%d %%s * * %%s \""%s/git\"" --exec-path=\""%s\"" for-each-repo --keep-going --config=maintenance.repo maintenance run --schedule=%%s\n"", exec_path, exec_path);
    fprintf(cron_in, line_format.buf, minute, ""1-23"", ""*"", ""hourly"");
    fprintf(cron_in, line_format.buf, minute, ""0"", ""1-6"", ""daily"");
    fprintf(cron_in, line_format.buf, minute, ""0"", ""0"", ""weekly"");
    strbuf_release(&line_format);
    fprintf(cron_in, ""\n%s\n"", END_LINE);
}
",,
implicit_predicate,gc.c,2314,+,-,"if (get_schedule_cmd(&cmd, &is_available))
    return is_available;
",,
implicit_predicate,gc.c,2510,+,-,"if (systemd_timer_write_timer_file(schedule, minute))
    return -1;
",,
implicit_predicate,gc.c,2515,+,+,"enable ? ""enable"" : ""disable""",38,"	strvec_pushl(&child.args, ""--user"", enable ? ""enable"" : ""disable"","
implicit_predicate,gc.c,2529,+,-,"if (enable)
    return error(_(""failed to run systemctl""));
",,
implicit_predicate,gc.c,2581,+,-,"if (ret)
    systemd_timer_delete_units();
else
    systemd_timer_delete_stale_timer_templates();
",,
implicit_predicate,gc.c,2726,+,-,"if (enable)
    result = scheduler_fn[opts->scheduler].update_schedule(1, get_lock_file_fd(&lk));
",,
implicit_predicate,gc.c,2755,+,-,"if (argc)
    usage_with_options(builtin_maintenance_start_usage, options);
",,
implicit_predicate,gc.c,2761,+,-,"if (update_background_schedule(&opts, 1))
    die(_(""failed to set up maintenance schedule""));
",,
implicit_predicate,gc.c,2781,+,-,"if (argc)
    usage_with_options(builtin_maintenance_stop_usage, options);
",,
implicit_predicate,generic.c,41,+,-,"if (err)
    goto done;
",,
implicit_predicate,generic.c,45,+,-,"if (err)
    goto done;
",,
implicit_predicate,generic.c,70,+,-,"while (1){
    err = reftable_iterator_next_ref(&it, &ref);
    if (err > 0){
        break;
    }
    if (err < 0){
        return err;
    }
    reftable_ref_record_print(&ref, hash_id);
}
",,
implicit_predicate,generic.c,75,+,-,"if (err)
    goto done;
",,
implicit_predicate,generic.c,79,+,-,"if (err)
    goto done;
",,
implicit_predicate,generic.c,87,+,-,"while (1){
    err = reftable_iterator_next_log(&it, &log);
    if (err > 0){
        break;
    }
    if (err < 0){
        return err;
    }
    reftable_log_record_print(&log, hash_id);
}
",,
implicit_predicate,generic.c,107,+,-,"while (1){
    err = reftable_iterator_next_ref(&it, &ref);
    if (err > 0){
        break;
    }
    if (err < 0){
        return err;
    }
    reftable_ref_record_print(&ref, hash_id);
}
",,
implicit_predicate,generic.c,126,+,-,"while (1){
    err = reftable_iterator_next_log(&it, &log);
    if (err > 0){
        break;
    }
    if (err < 0){
        return err;
    }
    reftable_log_record_print(&log, hash_id);
}
",,
implicit_predicate,gettext.c,136,+,+,is_utf8 ? utf8_strwidth(s) : strlen(s),9,	return is_utf8 ? utf8_strwidth(s) : strlen(s);
implicit_predicate,git-compat-util.h,1244,-,+,,9,	return str ? xstrdup(str) : NULL;
implicit_predicate,git-compat-util.h,1552,-,+,,9,	return ptr ? (char *)ptr - offset : NULL;
implicit_predicate,git-credential-libsecret.c,82,+,-,"if (c->port)
    return g_strdup_printf(""Git: %s://%s:%hu/%s"", c->protocol, c->host, c->port, c->path ? c->path : """");
else
    return g_strdup_printf(""Git: %s://%s/%s"", c->protocol, c->host, c->path ? c->path : """");
",,
implicit_predicate,git-credential-libsecret.c,100,+,-,"if (c->port)
    g_hash_table_insert(al, ""port"", g_strdup_printf(""%hu"", c->port));
",,
implicit_predicate,git-credential-libsecret.c,367,+,-,"while (*value)
    *value++ = '\0';
",,
implicit_predicate,git-credential-libsecret.c,372,+,-,"while (*value)
    *value++ = '\0';
",,
implicit_predicate,git-credential-libsecret.c,443,+,-,"if (ret)
    goto out;
",,
implicit_predicate,git-credential-osxkeychain.c,291,+,-,"if (state_seen)
    return errSecSuccess;
",,
implicit_predicate,git-credential-wincred.c,82,+,-,"last ? wcsstr_last(start, delim) : wcsstr(start, delim)",,
implicit_predicate,git-zlib.c,78,-,+,,6,"	    strm->z.msg ? strm->z.msg : ""no message"");"
implicit_predicate,git-zlib.c,96,-,+,,6,"	    strm->z.msg ? strm->z.msg : ""no message"");"
implicit_predicate,git-zlib.c,170,-,+,,6,"	    strm->z.msg ? strm->z.msg : ""no message"");"
implicit_predicate,git-zlib.c,186,-,+,,6,"	    strm->z.msg ? strm->z.msg : ""no message"");"
implicit_predicate,git.c,89,+,-,"if (match_token(spec, len, ""builtins""))
    list_builtins(&list, 0);
else
    if (match_token(spec, len, ""main""))
        list_all_main_cmds(&list);
    else
        if (match_token(spec, len, ""others""))
            list_all_other_cmds(&list);
        else
            if (match_token(spec, len, ""nohelpers""))
                exclude_helpers_from_list(&list);
            else
                if (match_token(spec, len, ""alias""))
                    list_aliases(&list);
                else
                    if (match_token(spec, len, ""config""))
                        list_cmds_by_config(&list);
                    else
                        if (len > 5 && !strncmp(spec, ""list-"", 5)){
                            struct strbuf sb = STRBUF_INIT;
                            strbuf_add(&sb, spec + 5, len - 5);
                            list_cmds_by_category(&list, sb.buf);
                            strbuf_release(&sb);
                        }else
                            die(_(""unsupported command listing type '%s'""), spec);
",,
implicit_predicate,git.c,91,+,-,"if (match_token(spec, len, ""main""))
    list_all_main_cmds(&list);
else
    if (match_token(spec, len, ""others""))
        list_all_other_cmds(&list);
    else
        if (match_token(spec, len, ""nohelpers""))
            exclude_helpers_from_list(&list);
        else
            if (match_token(spec, len, ""alias""))
                list_aliases(&list);
            else
                if (match_token(spec, len, ""config""))
                    list_cmds_by_config(&list);
                else
                    if (len > 5 && !strncmp(spec, ""list-"", 5)){
                        struct strbuf sb = STRBUF_INIT;
                        strbuf_add(&sb, spec + 5, len - 5);
                        list_cmds_by_category(&list, sb.buf);
                        strbuf_release(&sb);
                    }else
                        die(_(""unsupported command listing type '%s'""), spec);
",,
implicit_predicate,git.c,93,+,-,"if (match_token(spec, len, ""others""))
    list_all_other_cmds(&list);
else
    if (match_token(spec, len, ""nohelpers""))
        exclude_helpers_from_list(&list);
    else
        if (match_token(spec, len, ""alias""))
            list_aliases(&list);
        else
            if (match_token(spec, len, ""config""))
                list_cmds_by_config(&list);
            else
                if (len > 5 && !strncmp(spec, ""list-"", 5)){
                    struct strbuf sb = STRBUF_INIT;
                    strbuf_add(&sb, spec + 5, len - 5);
                    list_cmds_by_category(&list, sb.buf);
                    strbuf_release(&sb);
                }else
                    die(_(""unsupported command listing type '%s'""), spec);
",,
implicit_predicate,git.c,95,+,-,"if (match_token(spec, len, ""nohelpers""))
    exclude_helpers_from_list(&list);
else
    if (match_token(spec, len, ""alias""))
        list_aliases(&list);
    else
        if (match_token(spec, len, ""config""))
            list_cmds_by_config(&list);
        else
            if (len > 5 && !strncmp(spec, ""list-"", 5)){
                struct strbuf sb = STRBUF_INIT;
                strbuf_add(&sb, spec + 5, len - 5);
                list_cmds_by_category(&list, sb.buf);
                strbuf_release(&sb);
            }else
                die(_(""unsupported command listing type '%s'""), spec);
",,
implicit_predicate,git.c,97,+,-,"if (match_token(spec, len, ""alias""))
    list_aliases(&list);
else
    if (match_token(spec, len, ""config""))
        list_cmds_by_config(&list);
    else
        if (len > 5 && !strncmp(spec, ""list-"", 5)){
            struct strbuf sb = STRBUF_INIT;
            strbuf_add(&sb, spec + 5, len - 5);
            list_cmds_by_category(&list, sb.buf);
            strbuf_release(&sb);
        }else
            die(_(""unsupported command listing type '%s'""), spec);
",,
implicit_predicate,git.c,99,+,-,"if (match_token(spec, len, ""config""))
    list_cmds_by_config(&list);
else
    if (len > 5 && !strncmp(spec, ""list-"", 5)){
        struct strbuf sb = STRBUF_INIT;
        strbuf_add(&sb, spec + 5, len - 5);
        list_cmds_by_category(&list, sb.buf);
        strbuf_release(&sb);
    }else
        die(_(""unsupported command listing type '%s'""), spec);
",,
implicit_predicate,git.c,401,+,-,"if (envchanged)
    die(_(""alias '%s' changes environment variables.\nYou can use '!git' in the alias to do this""), alias_command);
",,
implicit_predicate,git.c,447,+,-,"if (run_setup & RUN_SETUP){
    prefix = setup_git_directory();
}else
    if (run_setup & RUN_SETUP_GENTLY){
        int nongit_ok;
        prefix = setup_git_directory_gently(&nongit_ok);
    }else{
        prefix = NULL;
    }
",,
implicit_predicate,git.c,449,+,-,"if (run_setup & RUN_SETUP_GENTLY){
    int nongit_ok;
    prefix = setup_git_directory_gently(&nongit_ok);
}else{
    prefix = NULL;
}
",,
implicit_predicate,git.c,477,+,-,"if (status)
    return status;
",,
implicit_predicate,git.c,782,+,-,"while (1){
    if (!done_alias)
        handle_builtin(*argcp, *argv);
    else
        if (get_builtin(**argv)){
            struct child_process cmd = CHILD_PROCESS_INIT;
            int i;
            trace2_cmd_name(""_run_git_alias_"");
            commit_pager_choice();
            strvec_push(&cmd.args, ""git"");
            for (i = 0;i < *argcp;i++)
                strvec_push(&cmd.args, (*argv)[i]);
            trace_argv_printf(cmd.args.v, ""trace: exec:"");
            cmd.silent_exec_failure = 1;
            cmd.clean_on_exit = 1;
            cmd.wait_after_clean = 1;
            cmd.trace2_child_class = ""git_alias"";
            i = run_command(&cmd);
            if (i >= 0 || errno != ENOENT)
                exit(i);

            die(""could not execute builtin %s"", **argv);
        }

    execv_dashed_external(*argv);
    seen = unsorted_string_list_lookup(&cmd_list, *argv[0]);
    if (seen){
        int i;
        struct strbuf sb = STRBUF_INIT;
        for (i = 0;i < cmd_list.nr;i++){
            struct string_list_item* item = &cmd_list.items[i];
            strbuf_addf(&sb, ""\n  %s"", item->string);
            if (item == seen)
                strbuf_addstr(&sb, "" <=="");
            else
                if (i == cmd_list.nr - 1)
                    strbuf_addstr(&sb, "" ==>"");
        }
        die(_(""alias loop detected: expansion of '%s' does not terminate:%s""), cmd_list.items[0].string, sb.buf);
    }
    string_list_append(&cmd_list, *argv[0]);
    if (!handle_alias(argcp, argv))
        break;

    done_alias = 1;
}
",,
implicit_predicate,git.c,927,+,-,"while (1){
    int was_alias = run_argv(&argc, &argv);
    if (errno != ENOENT)
        break;

    if (was_alias){
        fprintf(stderr, _(""expansion of alias '%s' failed; '%s' is not a git command\n""), cmd, argv[0]);
        exit(1);
    }
    if (!done_help){
        cmd = argv[0] = help_unknown_cmd(cmd);
        done_help = 1;
    }else
        break;
}
",,
implicit_predicate,git.c,931,+,-,"if (was_alias){
    fprintf(stderr, _(""expansion of alias '%s' failed; '%s' is not a git command\n""), cmd, argv[0]);
    exit(1);
}
",,
implicit_predicate,gpg-interface.c,23,+,-,"if (done)
    return;
",,
implicit_predicate,gpg-interface.c,252,+,-,"if (sigcheck_gpg_status[i].flags & GPG_STATUS_EXCLUSIVE){
    if (seen_exclusive_status++)
        goto error;
}
",,
implicit_predicate,gpg-interface.c,253,+,-,"if (seen_exclusive_status++)
    goto error;
",,
implicit_predicate,gpg-interface.c,257,+,-,"if (sigcheck_gpg_status[i].result)
    sigc->result = sigcheck_gpg_status[i].result;
",,
implicit_predicate,gpg-interface.c,260,+,-,"if (sigcheck_gpg_status[i].flags & GPG_STATUS_KEYID){
    next = strchrnul(line, ' ');
    replace_cstring(&sigc->key, line, next);
    if (*next && (sigcheck_gpg_status[i].flags & GPG_STATUS_UID)){
        line = next + 1;
        next = strchrnul(line, '\n');
        replace_cstring(&sigc->signer, line, next);
    }
}
",,
implicit_predicate,gpg-interface.c,272,+,-,"if (sigcheck_gpg_status[i].flags & GPG_STATUS_TRUST_LEVEL){
    size_t trust_size = strcspn(line, "" \n"");
    char* trust = xmemdupz(line, trust_size);
    if (parse_gpg_trust_level(trust, &sigc->trust_level)){
        free(trust);
        goto error;
    }
    free(trust);
}
",,
implicit_predicate,gpg-interface.c,290,+,-,"if (sigcheck_gpg_status[i].flags & GPG_STATUS_FINGERPRINT){
    const char* limit;
    char** field;
    next = strchrnul(line, ' ');
    replace_cstring(&sigc->fingerprint, line, next);
    limit = strchrnul(line, '\n');
    for (j = 9;j > 0;j--){
        if (!*next || limit <= next)
            break;

        line = next + 1;
        next = strchrnul(line, ' ');
    }
    field = &sigc->primary_key_fingerprint;
    if (!j){
        next = strchrnul(line, '\n');
        replace_cstring(field, line, next);
    }else{
        replace_cstring(field, NULL, NULL);
    }
}
",,
implicit_predicate,gpg-interface.c,661,+,-,"if (parse_payload_metadata(sigc))
    return 1;
",,
implicit_predicate,gpg-interface.c,677,-,+,,23,"	const char *output = flags & GPG_VERIFY_RAW ? sigc->gpg_status :
							    sigc->output;"
implicit_predicate,gpg-interface.c,698,-,+,,10,		len += eol ? eol - (buf + len) + 1 : size - len;
implicit_predicate,gpg-interface.c,818,+,-,"if (is_literal_ssh_key(signing_key, &literal_key)){
    strvec_pushl(&ssh_keygen.args, ""ssh-keygen"", ""-lf"", ""-"", NULL);
    ret = pipe_command(&ssh_keygen, literal_key, strlen(literal_key), &fingerprint_stdout, 0, NULL, 0);
}else{
    strvec_pushl(&ssh_keygen.args, ""ssh-keygen"", ""-lf"", configured_signing_key, NULL);
    ret = pipe_command(&ssh_keygen, NULL, 0, &fingerprint_stdout, 0, NULL, 0);
}
",,
implicit_predicate,gpg-interface.c,1000,+,-,"if (ret){
    error(_(""gpg failed to sign the data:\n%s""), gpg_status.len ? gpg_status.buf : ""(no gpg output)"");
    strbuf_release(&gpg_status);
    return -1;
}
",,
implicit_predicate,gpg-interface.c,1031,+,-,"if (is_literal_ssh_key(signing_key, &literal_key)){
    literal_ssh_key = 1;
    key_file = mks_tempfile_t("".git_signing_key_tmpXXXXXX"");
    if (!key_file)
        return error_errno(_(""could not create temporary file""));

    keylen = strlen(literal_key);
    if (write_in_full(key_file->fd, literal_key, keylen) < 0 || close_tempfile_gently(key_file) < 0){
        error_errno(_(""failed writing ssh signing key to '%s'""), key_file->filename.buf);
        goto out;
    }
    ssh_signing_key_file = strbuf_detach(&key_file->filename, NULL);
}else{
    ssh_signing_key_file = interpolate_path(signing_key, 1);
}
",,
implicit_predicate,gpg-interface.c,1069,+,-,"if (literal_ssh_key)
    strvec_push(&signer.args, ""-U"");
",,
implicit_predicate,gpg-interface.c,1077,+,-,"if (ret){
    if (strstr(signer_stderr.buf, ""usage:""))
        error(_(""ssh-keygen -Y sign is needed for ssh signing (available in openssh version 8.2p1+)""));

    ret = error(""%s"", signer_stderr.buf);
    goto out;
}
",,
implicit_predicate,graph.c,653,+,-,"if (seen_this)
    break;
",,
implicit_predicate,graph.c,792,+,-,"if (graph_needs_pre_commit_line(graph))
    graph->state = GRAPH_PRE_COMMIT;
else
    graph->state = GRAPH_COMMIT;
",,
implicit_predicate,graph.c,862,+,-,"if (graph_needs_pre_commit_line(graph))
    graph_update_state(graph, GRAPH_PRE_COMMIT);
else
    graph_update_state(graph, GRAPH_COMMIT);
",,
implicit_predicate,graph.c,1013,+,-,"if (seen_this)
    break;
",,
implicit_predicate,graph.c,1064,+,-,"if (graph_is_mapping_correct(graph))
    graph_update_state(graph, GRAPH_PADDING);
else
    graph_update_state(graph, GRAPH_COLLAPSING);
",,
implicit_predicate,graph.c,1087,+,-,"if (seen_this)
    break;
",,
implicit_predicate,graph.c,1124,+,-,"if (seen_this){
    if (graph->edges_added > 0)
        graph_line_write_column(line, col, '\\');
    else
        graph_line_write_column(line, col, '|');

    graph_line_addch(line, ' ');
}else{
    graph_line_write_column(line, col, '|');
    if (graph->merge_layout != 0 || i != graph->commit_index - 1){
        if (parent_col)
            graph_line_write_column(line, parent_col, '_');
        else
            graph_line_addch(line, ' ');
    }
}
",,
implicit_predicate,graph.c,1148,+,-,"if (graph_is_mapping_correct(graph))
    graph_update_state(graph, GRAPH_PADDING);
else
    graph_update_state(graph, GRAPH_COLLAPSING);
",,
implicit_predicate,graph.c,1303,+,-,"if (graph_is_mapping_correct(graph))
    graph_update_state(graph, GRAPH_PADDING);
",,
implicit_predicate,graph.c,1406,+,-,"if (graph_is_commit_finished(graph)){
    graph_show_padding(graph);
    shown_commit_line = 1;
}
",,
implicit_predicate,graph.c,1463,+,-,"if (graph_is_commit_finished(graph))
    return 0;
",,
implicit_predicate,graph.c,1545,+,-,"if (newline_terminated)
    putc('\n', file);
",,
implicit_predicate,grep.c,157,+,-,"if (skip_first_line){
    while (len){
        len--;
        if (*p++ == '\n')
            break;
    }
    skip_first_line = 0;
}
",,
implicit_predicate,grep.c,198,+,-,"while (1){
    struct work_item* w = get_work();
    if (!w)
        break;

    opt->output_priv = w;
    hit |= grep_source(opt, &w->source);
    grep_source_clear_data(&w->source);
    work_done(w);
}
",,
implicit_predicate,grep.c,244,+,-,"if (err)
    die(_(""grep: failed to create thread: %s""), strerror(err));
",,
implicit_predicate,grep.c,334,+,-,"if (tree_name_len)
    strbuf_add(out, filename, tree_name_len);
",,
implicit_predicate,grep.c,350,+,-,"if (tree_name_len)
    strbuf_insert(out, 0, filename, tree_name_len);
",,
implicit_predicate,grep.c,429,+,-,"if (status)
    exit(status);
",,
implicit_predicate,grep.c,482,+,-,"if (err){
    char errbuf[1024];
    regerror(err, &p->regexp, errbuf, sizeof (errbuf));
    compile_regexp_failed(p, errbuf);
}
",,
implicit_predicate,grep.c,496,-,+,,31,"		opt->pattern_type_option = (opt->extended_regexp_option
					    ? GREP_PATTERN_TYPE_ERE
					    : GREP_PATTERN_TYPE_BRE);"
implicit_predicate,grep.c,566,+,-,"if (err){
    char errbuf[1024];
    regerror(err, &p->regexp, errbuf, 1024);
    compile_regexp_failed(p, errbuf);
}
",,
implicit_predicate,grep.c,658,+,+,check_attr ? base->buf + tn_len : NULL,7,					 check_attr ? base->buf + tn_len : NULL);
implicit_predicate,grep.c,710,-,+,,9,		len = name ? strlen(name) : 0;
implicit_predicate,grep.c,712,+,-,"if (len){
    strbuf_add(&base, name, len);
    strbuf_addch(&base, ':');
}
",,
implicit_predicate,grep.c,753,+,-,"if (recurse_submodules){
    submodule_free(opt->repo);
    obj_read_lock();
    gitmodules_config_oid(&real_obj->oid);
    obj_read_unlock();
}
",,
implicit_predicate,grep.c,777,+,-,"if (exc_std)
    setup_standard_excludes(&dir);
",,
implicit_predicate,grep.c,797,+,-,"if (unset){
    grep_opt->pre_context = grep_opt->post_context = 0;
    return 0;
}
",,
implicit_predicate,grep.c,827,+,+,"from_stdin ? stdin : fopen(filename, ""r"")",13,"	patterns = from_stdin ? stdin : fopen(filename, ""r"");"
implicit_predicate,grep.c,902,-,+,,19,"	opt->output(opt, opt->null_following_name ? ""\0"" : ""\n"", 1);"
implicit_predicate,grep.c,996,+,-,"if (hit){
    pmatch[0].rm_so += bol - start;
    pmatch[0].rm_eo += bol - start;
}
",,
implicit_predicate,grep.c,1051,+,-,"if (fallback)
    use_index = 0;
else
    setup_git_directory();
",,
implicit_predicate,grep.c,1089,+,-,"if (collect_hits)
    x->u.binary.left->hit |= h;
",,
implicit_predicate,grep.c,1097,+,-,"if (collect_hits)
    x->hit |= h;
",,
implicit_predicate,grep.c,1126,+,-,"if (seen_dashdash)
    die(_(""--no-index or --untracked cannot be used with revs""));
",,
implicit_predicate,grep.c,1134,+,-,"if (seen_dashdash)
    die(_(""unable to resolve revision: %s""), arg);
",,
implicit_predicate,grep.c,1199,+,-,"if (recurse_submodules)
    repo_read_gitmodules(the_repository, 1);
",,
implicit_predicate,grep.c,1231,-,+,,6,"					strcmp(""less"", pager) ? """" : ""*"","
implicit_predicate,grep.c,1256,+,-,"if (cached)
    die(_(""both --cached and trees are given""));
",,
implicit_predicate,grep.c,1311,+,-,"if (grep_use_locks)
    pthread_mutex_lock(&grep_attr_mutex);
",,
implicit_predicate,grep.c,1317,+,-,"if (grep_use_locks)
    pthread_mutex_unlock(&grep_attr_mutex);
",,
implicit_predicate,grep.c,1361,+,-,"if (match_funcname(opt, gs, bol, eol)){
    show_line(opt, bol, eol, gs->name, lno, 0, '=');
    break;
}
",,
implicit_predicate,grep.c,1382,+,-,"if (match_funcname(opt, gs, bol, end))
    comment_needed = 1;
else
    funcname_needed = 1;
",,
implicit_predicate,grep.c,1640,+,-,"while (left){
    const char* eol;
    int hit;
    ssize_t cno;
    ssize_t col = -1, icol = -1;
    if (try_lookahead && !(last_hit && (show_function || lno <= last_hit + opt->post_context)) && look_ahead(opt, &left, &lno, &bol))
        break;

    eol = end_of_line(bol, &left);
    if ((ctx == GREP_CONTEXT_HEAD) && (eol == bol))
        ctx = GREP_CONTEXT_BODY;

    hit = match_line(opt, bol, eol, &col, &icol, ctx, collect_hits);
    if (collect_hits)
        goto next_line;

    if (opt->invert)
        hit = !hit;

    if (opt->unmatch_name_only){
        if (hit)
            return 0;

        goto next_line;
    }
    if (hit && (opt->max_count < 0 || count < opt->max_count)){
        count++;
        if (opt->status_only)
            return 1;

        if (opt->name_only){
            show_name(opt, gs->name);
            return 1;
        }
        if (opt->count)
            goto next_line;

        if (binary_match_only){
            opt->output(opt, ""Binary file "", 12);
            output_color(opt, gs->name, strlen(gs->name), opt->colors[GREP_COLOR_FILENAME]);
            opt->output(opt, "" matches\n"", 9);
            return 1;
        }
        if (opt->pre_context || opt->funcbody)
            show_pre_context(opt, gs, bol, eol, lno);
        else
            if (opt->funcname)
                show_funcname_line(opt, gs, bol, lno);

        cno = opt->invert ? icol : col;
        if (cno < 0){
            cno = 0;
        }
        show_line(opt, bol, eol, gs->name, lno, cno + 1, ':');
        last_hit = lno;
        if (opt->funcbody)
            show_function = 1;

        goto next_line;
    }
    if (show_function && (!peek_bol || peek_bol < bol)){
        unsigned long peek_left = left;
        const char* peek_eol = eol;
        peek_bol = bol;
        while (is_empty_line(peek_bol, peek_eol)){
            peek_bol = peek_eol + 1;
            peek_eol = end_of_line(peek_bol, &peek_left);
        }
        if (match_funcname(opt, gs, peek_bol, peek_eol))
            show_function = 0;
    }
    if (show_function || (last_hit && lno <= last_hit + opt->post_context)){
        show_line(opt, bol, eol, gs->name, lno, col + 1, '-');
    }
    next_line:
    bol = eol + 1;
    if (!left)
        break;

    left--;
    lno++;
}
",,
implicit_predicate,grep.c,1668,+,-,"if (collect_hits)
    goto next_line;
",,
implicit_predicate,grep.c,1678,+,-,"if (hit)
    return 0;
",,
implicit_predicate,grep.c,1692,+,-,"if (binary_match_only){
    opt->output(opt, ""Binary file "", 12);
    output_color(opt, gs->name, strlen(gs->name), opt->colors[GREP_COLOR_FILENAME]);
    opt->output(opt, "" matches\n"", 9);
    return 1;
}
",,
implicit_predicate,grep.c,1706,-,+,,10,			cno = opt->invert ? icol : col;
implicit_predicate,grep.c,1733,+,-,"while (is_empty_line(peek_bol, peek_eol)){
    peek_bol = peek_eol + 1;
    peek_eol = end_of_line(peek_bol, &peek_left);
}
",,
implicit_predicate,grep.c,1738,+,-,"if (match_funcname(opt, gs, peek_bol, peek_eol))
    show_function = 0;
",,
implicit_predicate,grep.c,1757,+,-,"if (collect_hits)
    return 0;
",,
implicit_predicate,grep.c,1795,+,-,"while (1){
    x->hit = 0;
    if (x->node != GREP_NODE_OR)
        return;

    x->u.binary.left->hit = 0;
    x = x->u.binary.right;
}
",,
implicit_predicate,grep.c,1807,+,-,"while (1){
    if (x->node != GREP_NODE_OR)
        return x->hit;

    if (!x->u.binary.left->hit)
        return 0;

    x = x->u.binary.right;
}
",,
implicit_predicate,grep.c,1974,-,+,,10,		return gs->buf ? 0 : -1;
implicit_predicate,hash-object.c,48,+,+,"literally ? hash_literally(&oid, fd, type, flags) : index_fd(the_repository->index, &oid, fd, &st, type_from_string(type), path, flags)",7,"	    (literally
	     ? hash_literally(&oid, fd, type, flags)
	     : index_fd(the_repository->index, &oid, fd, &st,
			type_from_string(type), path, flags)))"
implicit_predicate,hash-object.c,52,-,+,,7,"		die((flags & HASH_WRITE_OBJECT)
		    ? ""Unable to add %s to database""
		    : ""Unable to hash %s"", path);"
implicit_predicate,hash-object.c,80,+,+,no_filters ? NULL : buf.buf,30,"		hash_object(buf.buf, type, no_filters ? NULL : buf.buf, flags,"
implicit_predicate,hash-object.c,133,+,-,"if (stdin_paths){
    if (hashstdin)
        errstr = ""Can't use --stdin-paths with --stdin"";
    else
        if (argc)
            errstr = ""Can't specify files with --stdin-paths"";
        else
            if (vpath)
                errstr = ""Can't use --stdin-paths with --path"";
}else{
    if (hashstdin > 1)
        errstr = ""Multiple --stdin arguments are not supported"";

    if (vpath && no_filters)
        errstr = ""Can't use --path with --no-filters"";
}
",,
implicit_predicate,hash-object.c,134,+,-,"if (hashstdin)
    errstr = ""Can't use --stdin-paths with --stdin"";
else
    if (argc)
        errstr = ""Can't specify files with --stdin-paths"";
    else
        if (vpath)
            errstr = ""Can't use --stdin-paths with --path"";
",,
implicit_predicate,hash-object.c,136,+,-,"if (argc)
    errstr = ""Can't specify files with --stdin-paths"";
else
    if (vpath)
        errstr = ""Can't use --stdin-paths with --path"";
",,
implicit_predicate,hash-object.c,153,+,-,"if (hashstdin)
    hash_fd(0, type, vpath, flags, literally);
",,
implicit_predicate,hash-object.c,162,+,+,no_filters ? NULL : vpath ? vpath : arg,46,"		hash_object(arg, type, no_filters ? NULL : vpath ? vpath : arg,"
implicit_predicate,hash-object.c,167,+,-,"if (stdin_paths)
    hash_stdin_paths(type, no_filters, flags, literally);
",,
implicit_predicate,hashmap.c,13,+,-,"while ((c = (unsigned char)*str++))
    hash = (hash * FNV32_PRIME) ^ c;
",,
implicit_predicate,hashmap.c,21,+,-,"while ((c = (unsigned char)*str++)){
    if (c >= 'a' && c <= 'z')
        c -= 'a' - 'A';

    hash = (hash * FNV32_PRIME) ^ c;
}
",,
implicit_predicate,hashmap.c,160,-,+,,15,	map->cmpfn = equals_function ? equals_function : always_equal;
implicit_predicate,hashmap.h,305,+,-,"if (map->do_count_items)
    return map->private_size;
",,
implicit_predicate,hashmap.h,545,+,-,"if (map->do_count_items)
    return;
",,
implicit_predicate,help.c,140,+,-,"if (i)
    putchar('\n');
",,
implicit_predicate,help.c,293,+,-,"while (1){
    if ((colon = strchr(path, PATH_SEP)))
        *colon = 0;

    if (!exec_path || strcmp(path, exec_path))
        list_commands_in_dir(other_cmds, path, prefix);

    if (!colon)
        break;

    path = colon + 1;
}
",,
implicit_predicate,help.c,445,+,-,"if (is_git_command(git_cmd))
    return xstrfmt(""git-%s"", git_cmd);
else
    if (!strcmp(""scalar"", git_cmd))
        return xstrdup(git_cmd);
    else
        return xstrfmt(""git%s"", git_cmd);
",,
implicit_predicate,help.c,527,+,-,"if (show_external_commands)
    list_all_cmds_help_external_commands();
",,
implicit_predicate,help.c,529,+,-,"if (show_aliases)
    list_all_cmds_help_aliases(longest);
",,
implicit_predicate,help.c,554,+,-,"if (is_git_command(cmd))
    return cmd;
",,
implicit_predicate,help.c,592,+,-,"if (exclude_guides)
    return help_unknown_cmd(cmd);
",,
implicit_predicate,help.c,626,+,-,"if (argc)
    usage_msg_optf(_(""the '%s' option doesn't take any non-option arguments""), builtin_help_usage, builtin_help_options, opt_mode);
",,
implicit_predicate,help.c,653,+,-,"if (verbose){
    setup_pager();
    list_all_cmds_help(show_external_commands, show_aliases);
    return 0;
}
",,
implicit_predicate,help.c,746,+,-,"if (show_build_options){
    strbuf_addf(buf, ""cpu: %s\n"", GIT_HOST_CPU);
    if (git_built_from_commit_string[0])
        strbuf_addf(buf, ""built from commit: %s\n"", git_built_from_commit_string);
    else
        strbuf_addstr(buf, ""no commit associated with this build\n"");

    strbuf_addf(buf, ""sizeof-long: %d\n"", (int)sizeof (long ));
    strbuf_addf(buf, ""sizeof-size_t: %d\n"", (int)sizeof (size_t));
    strbuf_addf(buf, ""shell-path: %s\n"", SHELL_PATH);
    if (fsmonitor_ipc__is_supported())
        strbuf_addstr(buf, ""feature: fsmonitor--daemon\n"");
}
",,
implicit_predicate,help.h,18,+,-,"while (num--)
    putchar(c);
",,
implicit_predicate,hex-ll.c,44,+,-,"if (val & ~0xff)
    return -1;
",,
implicit_predicate,hex-ll.h,17,+,+,(val & ~0xf) ? val : (val << 4) | hexval(s[1]),9,	return (val & ~0xf) ? val : (val << 4) | hexval(s[1]);
implicit_predicate,hex.c,65,+,-,"if (ret)
    *end = hex + hash_algos[ret].hexsz;
",,
implicit_predicate,http-backend.c,70,-,+,,9,	return i ? i->util : NULL;
implicit_predicate,http-backend.c,308,+,-,"while (1){
    ssize_t cnt;
    cnt = read_in_full(fd, buf + len, alloc - len);
    if (cnt < 0){
        free(buf);
        return -1;
    }
    len += cnt;
    if (len < alloc){
        *out = buf;
        return len;
    }
    if (alloc == max_request_buffer)
        die(""request was larger than our maximum size (%lu); try setting GIT_HTTP_MAX_REQUEST_BUFFER"", max_request_buffer);

    alloc = alloc_nr(alloc);
    if (alloc > max_request_buffer)
        alloc = max_request_buffer;

    REALLOC_ARRAY(buf, alloc);
}
",,
implicit_predicate,http-backend.c,389,+,-,"while (1){
    ssize_t n;
    if (buffer_input){
        if (full_request)
            n = 0;
        else
            n = read_request(0, &full_request, req_len);

        stream.next_in = full_request;
    }else{
        ssize_t buffer_len;
        if (req_len_defined && req_remaining_len <= sizeof (in_buf))
            buffer_len = req_remaining_len;
        else
            buffer_len = sizeof (in_buf);

        n = xread(0, in_buf, buffer_len);
        stream.next_in = in_buf;
        if (req_len_defined && n > 0)
            req_remaining_len -= n;
    }
    if (n <= 0)
        die(""request ended in the middle of the gzip stream"");

    stream.avail_in = n;
    while (0 < stream.avail_in){
        int ret;
        stream.next_out = out_buf;
        stream.avail_out = sizeof (out_buf);
        ret = git_inflate(&stream, Z_NO_FLUSH);
        if (ret != Z_OK && ret != Z_STREAM_END)
            die(""zlib error inflating request, result %d"", ret);

        n = stream.total_out - cnt;
        write_to_child(out, out_buf, stream.total_out - cnt, prog_name);
        cnt = stream.total_out;
        if (ret == Z_STREAM_END)
            goto done;
    }
}
",,
implicit_predicate,http-backend.c,392,+,-,"if (buffer_input){
    if (full_request)
        n = 0;
    else
        n = read_request(0, &full_request, req_len);

    stream.next_in = full_request;
}else{
    ssize_t buffer_len;
    if (req_len_defined && req_remaining_len <= sizeof (in_buf))
        buffer_len = req_remaining_len;
    else
        buffer_len = sizeof (in_buf);

    n = xread(0, in_buf, buffer_len);
    stream.next_in = in_buf;
    if (req_len_defined && n > 0)
        req_remaining_len -= n;
}
",,
implicit_predicate,http-backend.c,500,+,-,"if (gzipped_request)
    inflate_request(argv[0], cld.in, buffer_input, req_len);
else
    if (buffer_input)
        copy_request(argv[0], cld.in, req_len);
    else
        if (req_len >= 0)
            pipe_fixed_length(argv[0], cld.in, req_len);
        else
            close(0);
",,
implicit_predicate,http-backend.c,502,+,-,"if (buffer_input)
    copy_request(argv[0], cld.in, req_len);
else
    if (req_len >= 0)
        pipe_fixed_length(argv[0], cld.in, req_len);
    else
        close(0);
",,
implicit_predicate,http-fetch.c,35,+,-,"if (commits_on_stdin)
    walker_targets_free(commits, commit_id, write_ref);
",,
implicit_predicate,http-fetch.c,141,+,-,"if (nongit)
    die(_(""not a git repository""));
",,
implicit_predicate,http-fetch.c,148,+,-,"if (packfile){
    if (!index_pack_args.nr)
        die(_(""the option '%s' requires '%s'""), ""--packfile"", ""--index-pack-args"");

    fetch_single_packfile(&packfile_hash, argv[arg], index_pack_args.v);
    return 0;
}
",,
implicit_predicate,http-fetch.c,161,+,-,"if (commits_on_stdin){
    commits = walker_targets_stdin(&commit_id, &write_ref);
}else{
    commit_id = (char**)&argv[arg++];
    commits = 1;
}
",,
implicit_predicate,http-push.c,223,+,-,"if (options & DAV_HEADER_IF){
    strbuf_addf(&buf, ""If: (<%s>)"", lock->token);
    dav_headers = curl_slist_append(dav_headers, buf.buf);
    strbuf_reset(&buf);
}
",,
implicit_predicate,http-push.c,228,+,-,"if (options & DAV_HEADER_LOCK){
    strbuf_addf(&buf, ""Lock-Token: <%s>"", lock->token);
    dav_headers = curl_slist_append(dav_headers, buf.buf);
    strbuf_reset(&buf);
}
",,
implicit_predicate,http-push.c,233,+,-,"if (options & DAV_HEADER_TIMEOUT){
    strbuf_addf(&buf, ""Timeout: Second-%ld"", lock->timeout);
    dav_headers = curl_slist_append(dav_headers, buf.buf);
    strbuf_reset(&buf);
}
",,
implicit_predicate,http-push.c,560,+,-,"if (push_verbosely)
    fprintf(stderr, ""    sent %s\n"", oid_to_hex(&request->obj->oid));
",,
implicit_predicate,http-push.c,600,+,-,"if (fail)
    repo->can_update_info_refs = 0;
else
    http_install_packfile(request->target, &repo->packs);
",,
implicit_predicate,http-push.c,705,+,-,"if (push_verbosely)
    fprintf(stderr, ""Getting pack list\n"");
",,
implicit_predicate,http-push.c,741,+,-,"if (tag_closed){
    if (!strcmp(ctx->name, DAV_CTX_LOCKENTRY)){
        if ((*lock_flags & DAV_PROP_LOCKEX) && (*lock_flags & DAV_PROP_LOCKWR)){
            *lock_flags |= DAV_LOCK_OK;
        }
        *lock_flags &= DAV_LOCK_OK;
    }else
        if (!strcmp(ctx->name, DAV_CTX_LOCKTYPE_WRITE)){
            *lock_flags |= DAV_PROP_LOCKWR;
        }else
            if (!strcmp(ctx->name, DAV_CTX_LOCKTYPE_EXCLUSIVE)){
                *lock_flags |= DAV_PROP_LOCKEX;
            }
}
",,
implicit_predicate,http-push.c,1065,+,-,"if (tag_closed){
    if (!strcmp(ctx->name, DAV_PROPFIND_RESP) && ls->dentry_name){
        if (ls->dentry_flags & IS_DIR){
            str_end_url_with_slash(ls->dentry_name, &ls->dentry_name);
            if (ls->flags & PROCESS_DIRS){
                ls->userFunc(ls);
            }
            if (strcmp(ls->dentry_name, ls->path) && ls->flags & RECURSIVE){
                remote_ls(ls->dentry_name, ls->flags, ls->userFunc, ls->userData);
            }
        }else
            if (ls->flags & PROCESS_FILES){
                ls->userFunc(ls);
            }
    }else
        if (!strcmp(ctx->name, DAV_PROPFIND_NAME) && ctx->cdata){
            char* path = ctx->cdata;
            if (*ctx->cdata == 'h'){
                path = strstr(path, ""//"");
                if (path){
                    path = strchr(path + 2, '/');
                }
            }
            if (path){
                const char* url = repo->url;
                if (repo->path)
                    url = repo->path;

                if (strncmp(path, url, repo->path_len))
                    error(""Parsed path '%s' does not match url: '%s'"", path, url);
                else{
                    path += repo->path_len;
                    ls->dentry_name = xstrdup(path);
                }
            }
        }else
            if (!strcmp(ctx->name, DAV_PROPFIND_COLLECTION)){
                ls->dentry_flags |= IS_DIR;
            }
}else
    if (!strcmp(ctx->name, DAV_PROPFIND_RESP)){
        FREE_AND_NULL(ls->dentry_name);
        ls->dentry_flags = 0;
    }
",,
implicit_predicate,http-push.c,1067,+,-,"if (ls->dentry_flags & IS_DIR){
    str_end_url_with_slash(ls->dentry_name, &ls->dentry_name);
    if (ls->flags & PROCESS_DIRS){
        ls->userFunc(ls);
    }
    if (strcmp(ls->dentry_name, ls->path) && ls->flags & RECURSIVE){
        remote_ls(ls->dentry_name, ls->flags, ls->userFunc, ls->userData);
    }
}else
    if (ls->flags & PROCESS_FILES){
        ls->userFunc(ls);
    }
",,
implicit_predicate,http-push.c,1072,+,-,"if (ls->flags & PROCESS_DIRS){
    ls->userFunc(ls);
}
",,
implicit_predicate,http-push.c,1082,+,-,"if (ls->flags & PROCESS_FILES){
    ls->userFunc(ls);
}
",,
implicit_predicate,http-push.c,1661,+,-,"if (dry_run)
    return 0;
",,
implicit_predicate,http-push.c,1790,+,-,"if (repo->has_info_refs){
    info_ref_lock = lock_remote(""info/refs"", LOCK_TIME);
    if (info_ref_lock)
        repo->can_update_info_refs = 1;
    else{
        error(""cannot lock existing info/refs"");
        rc = 1;
        goto cleanup;
    }
}
",,
implicit_predicate,http-push.c,1800,+,-,"if (repo->has_info_packs)
    fetch_indices();
",,
implicit_predicate,http-push.c,1810,+,-,"if (delete_branch){
    const char* branch = rs.items[i].src;
    if (delete_remote_branch(branch, force_delete) == -1){
        fprintf(stderr, ""Unable to delete remote branch %s\n"", branch);
        if (helper_status)
            printf(""error %s cannot remove\n"", branch);
    }
    goto cleanup;
}
",,
implicit_predicate,http-push.c,1815,+,-,"if (helper_status)
    printf(""error %s cannot remove\n"", branch);
",,
implicit_predicate,http-push.c,1828,+,-,"if (helper_status)
    printf(""error null no match\n"");
",,
implicit_predicate,http-push.c,1845,+,-,"if (helper_status)
    printf(""error %s cannot remove\n"", ref->name);
",,
implicit_predicate,http-push.c,1849,+,-,"if (helper_status)
    printf(""ok %s\n"", ref->name);
",,
implicit_predicate,http-push.c,1856,+,-,"if (push_verbosely)
    fprintf(stderr, ""'%s': up-to-date\n"", ref->name);
",,
implicit_predicate,http-push.c,1859,+,-,"if (helper_status)
    printf(""ok %s up to date\n"", ref->name);
",,
implicit_predicate,http-push.c,1885,+,-,"if (helper_status)
    printf(""error %s non-fast forward\n"", ref->name);
",,
implicit_predicate,http-push.c,1899,+,-,"if (dry_run){
    if (helper_status)
        printf(""ok %s\n"", ref->name);

    continue;
}
",,
implicit_predicate,http-push.c,1900,+,-,"if (helper_status)
    printf(""ok %s\n"", ref->name);
",,
implicit_predicate,http-push.c,1910,+,-,"if (helper_status)
    printf(""error %s lock error\n"", ref->name);
",,
implicit_predicate,http-push.c,1938,+,-,"if (objects_to_send)
    fprintf(stderr, ""    sending %d objects\n"", objects_to_send);
",,
implicit_predicate,http-push.c,1950,+,-,"if (helper_status)
    printf(""%s %s\n"", !rc ? ""ok"" : ""error"", ref->name);
",,
implicit_predicate,http-walker.c,214,+,-,"if (alt_req->http_specific){
    if (slot->curl_result != CURLE_OK || !alt_req->buffer->len){
        alt_req->http_specific = 0;
        strbuf_reset(alt_req->url);
        strbuf_addf(alt_req->url, ""%s/objects/info/alternates"", base);
        curl_easy_setopt(slot->curl, CURLOPT_URL, alt_req->url->buf);
        active_requests++;
        slot->in_use = 1;
        if (slot->finished)
            (*slot->finished) = 0;

        if (!start_active_slot(slot)){
            cdata->got_alternates = -1;
            slot->in_use = 0;
            if (slot->finished)
                (*slot->finished) = 1;
        }
        return;
    }
}else
    if (slot->curl_result != CURLE_OK){
        if (!missing_target(slot)){
            cdata->got_alternates = -1;
            return;
        }
    }
",,
implicit_predicate,http-walker.c,302,+,-,"if (alt_req->http_specific){
    char* colon = strchr(data + i, ':');
    char* slash = strchr(data + i, '/');
    if (colon && slash && colon < data + posn && slash < data + posn && colon < slash){
        okay = 1;
    }
}
",,
implicit_predicate,http-walker.c,310,+,-,"if (okay){
    struct strbuf target = STRBUF_INIT;
    strbuf_add(&target, base, serverlen);
    strbuf_add(&target, data + i, posn - i);
    if (!strbuf_strip_suffix(&target, ""objects"")){
        warning(""ignoring alternate that does not end in 'objects': %s"", target.buf);
        strbuf_release(&target);
    }else
        if (is_alternate_allowed(target.buf)){
            warning(""adding alternate object store: %s"", target.buf);
            newalt = xmalloc(sizeof (*newalt));
            newalt->next = NULL;
            newalt->base = strbuf_detach(&target, NULL);
            newalt->got_indices = 0;
            newalt->packs = NULL;
            while (tail->next != NULL)
                tail = tail->next;
            tail->next = newalt;
        }else{
            strbuf_release(&target);
        }
}
",,
implicit_predicate,http-walker.c,403,+,-,"if (repo->got_indices)
    return 0;
",,
implicit_predicate,http-walker.c,430,+,-,"if (fetch_indices(walker, repo))
    return -1;
",,
implicit_predicate,http-walker.c,463,+,-,"if (ret)
    return ret;
",,
implicit_predicate,http.c,267,-,+,,27,"			const char *const sp = *prev ? "" "" : """";"
implicit_predicate,http.c,581,+,-,"if (curl_empty_auth_enabled())
    curl_easy_setopt(result, CURLOPT_USERPWD, "":"");
",,
implicit_predicate,http.c,821,+,-,"if (hide_sensitive_header)
    redact_sensitive_header(*header, 0);
",,
implicit_predicate,http.c,1051,+,-,"if (http_proactive_auth)
    init_curl_http_auth(result);
",,
implicit_predicate,http.c,1080,+,-,"if (has_cert_password())
    curl_easy_setopt(result, CURLOPT_KEYPASSWD, cert_auth.password);
",,
implicit_predicate,http.c,1147,+,-,"if (curl_ftp_no_epsv)
    curl_easy_setopt(result, CURLOPT_FTP_USE_EPSV, 0);
",,
implicit_predicate,http.c,1150,+,-,"if (curl_ssl_try)
    curl_easy_setopt(result, CURLOPT_USE_SSL, CURLUSESSL_TRY);
",,
implicit_predicate,http.c,1466,+,-,"if (curl_save_cookies)
    curl_easy_setopt(slot->curl, CURLOPT_COOKIEJAR, curl_cookie_file);
",,
implicit_predicate,http.c,1548,+,-,"if (fill->fill(fill->data))
    break;
",,
implicit_predicate,http.c,1704,+,-,"if (needs_quote(ch))
    strbuf_addf(&buf, ""%%%02x"", ch);
else
    strbuf_addch(&buf, *cp);
",,
implicit_predicate,http.c,1967,+,-,"if (num_langs){
    int last_buf_len = 0;
    int max_q;
    int decimal_places;
    char q_format[32];
    REALLOC_ARRAY(language_tags, num_langs + 1);
    language_tags[num_langs++] = ""*"";
    for (max_q = 1, decimal_places = 0;max_q < num_langs && decimal_places <= MAX_DECIMAL_PLACES;decimal_places++, max_q *= 10);

    xsnprintf(q_format, sizeof (q_format), "";q=0.%%0%dd"", decimal_places);
    strbuf_addstr(buf, ""Accept-Language: "");
    for (i = 0;i < num_langs;i++){
        if (i > 0)
            strbuf_addstr(buf, "", "");

        strbuf_addstr(buf, language_tags[i]);
        if (i > 0)
            strbuf_addf(buf, q_format, max_q - i);

        if (buf->len > MAX_ACCEPT_LANGUAGE_HEADER_SIZE){
            strbuf_remove(buf, last_buf_len, buf->len - last_buf_len);
            break;
        }
        last_buf_len = buf->len;
    }
}
",,
implicit_predicate,http.c,2299,+,-,"if (http_is_verbose)
    fprintf(stderr, ""Getting index for pack %s\n"", hash_to_hex(hash));
",,
implicit_predicate,http.c,2350,+,-,"if (ret)
    return -1;
",,
implicit_predicate,http.c,2425,-,+,,25,"	strvec_pushv(&ip.args, preq->index_pack_args ?
		     preq->index_pack_args :
		     default_index_pack_args);"
implicit_predicate,ident.c,483,+,-,"if (want_name){
    int using_default = 0;
    if (!name){
        if (whose_ident == WANT_AUTHOR_IDENT && git_author_name.len)
            name = git_author_name.buf;
        else
            if (whose_ident == WANT_COMMITTER_IDENT && git_committer_name.len)
                name = git_committer_name.buf;
    }
    if (!name){
        if (strict && ident_use_config_only && !(ident_config_given & IDENT_NAME_GIVEN)){
            ident_env_hint(whose_ident);
            die(_(""no name was given and auto-detection is disabled""));
        }
        name = ident_default_name();
        using_default = 1;
        if (strict && default_name_is_bogus){
            ident_env_hint(whose_ident);
            die(_(""unable to auto-detect name (got '%s')""), name);
        }
    }
    if (!*name){
        struct passwd* pw;
        if (strict){
            if (using_default)
                ident_env_hint(whose_ident);

            die(_(""empty ident name (for <%s>) not allowed""), email);
        }
        pw = xgetpwuid_self(NULL);
        name = pw->pw_name;
    }
    if (strict && !has_non_crud(name))
        die(_(""name consists only of disallowed characters: %s""), name);
}
",,
implicit_predicate,ident.c,507,+,-,"if (strict){
    if (using_default)
        ident_env_hint(whose_ident);

    die(_(""empty ident name (for <%s>) not allowed""), email);
}
",,
implicit_predicate,ident.c,508,+,-,"if (using_default)
    ident_env_hint(whose_ident);
",,
implicit_predicate,ident.c,520,+,-,"if (want_name){
    strbuf_addstr_without_crud(ident, name);
    strbuf_addstr(ident, "" <"");
}
",,
implicit_predicate,ident.c,525,+,-,"if (want_name)
    strbuf_addch(ident, '>');
",,
implicit_predicate,ident.c,527,+,-,"if (want_date){
    strbuf_addch(ident, ' ');
    if (date_str && date_str[0]){
        if (parse_date(date_str, ident) < 0)
            die(_(""invalid date format: %s""), date_str);
    }else
        strbuf_addstr(ident, ident_default_date());
}
",,
implicit_predicate,ident.c,714,+,-,"if (cmp)
    return cmp;
",,
implicit_predicate,ident.c,727,+,-,"if (cmp)
    return cmp;
",,
implicit_predicate,imap-send.c,239,+,-,"if (found)
    return 0;
",,
implicit_predicate,imap-send.c,279,+,-,"if (use_tls_only)
    SSL_CTX_set_options(ctx, SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3);
",,
implicit_predicate,imap-send.c,282,+,-,"if (verify)
    SSL_CTX_set_verify(ctx, SSL_VERIFY_PEER, NULL);
",,
implicit_predicate,imap-send.c,320,+,-,"if (verify){
    cert = SSL_get_peer_certificate(sock->ssl);
    if (!cert)
        return error(""unable to get peer certificate."");

    if (verify_hostname(cert, server.host) < 0)
        return -1;
}
",,
implicit_predicate,imap-send.c,392,+,-,"if (start){
    *s = b->buf;
    assert(start <= b->bytes);
    n = b->bytes - start;
    if (n)
        memmove(b->buf, b->buf + start, n);

    b->offset -= start;
    b->bytes = n;
    start = 0;
}
",,
implicit_predicate,imap-send.c,399,+,-,"if (n)
    memmove(b->buf, b->buf + start, n);
",,
implicit_predicate,imap-send.c,478,+,-,"if (**s)
    *(*s)++ = 0;
",,
implicit_predicate,imap-send.c,504,+,-,"while (imap->literal_pending)
    get_cmd_result(ctx, NULL);
",,
implicit_predicate,imap-send.c,511,+,-,"CAP(LITERALPLUS) ? ""+"" : """"",,
implicit_predicate,imap-send.c,516,+,-,"if (imap->num_in_progress)
    printf(""(%d in progress) "", imap->num_in_progress);
",,
implicit_predicate,imap-send.c,533,+,-,"if (CAP(LITERALPLUS)){
    n = socket_write(&imap->buf.sock, cmd->cb.data, cmd->cb.dlen);
    free(cmd->cb.data);
    if (n != cmd->cb.dlen || socket_write(&imap->buf.sock, ""\r\n"", 2) != 2){
        free(cmd->cmd);
        free(cmd);
        return NULL;
    }
    cmd->cb.data = NULL;
}else
    imap->literal_pending = 1;
",,
implicit_predicate,imap-send.c,604,+,-,"if (skip_imap_list_l(&s, level + 1))
    goto bail;
",,
implicit_predicate,imap-send.c,706,+,-,"if (buffer_gets(&imap->buf, &cmd))
    return RESP_BAD;
",,
implicit_predicate,imap-send.c,749,-,+,,66,"			fprintf(stderr, ""IMAP error: unexpected reply: %s %s\n"", arg, cmd ? cmd : """");"
implicit_predicate,imap-send.c,762,+,-,"if (cmdp->cb.cont(ctx, cmd))
    return RESP_BAD;
",,
implicit_predicate,imap-send.c,800,-,+,,13,"							arg, cmd ? cmd : """");"
implicit_predicate,imap-send.c,914,+,+,"srvc->use_ssl ? ""imaps"" : ""imap""",27,"	cred->protocol = xstrdup(srvc->use_ssl ? ""imaps"" : ""imap"");"
implicit_predicate,imap-send.c,974,+,-,"if (gai){
    fprintf(stderr, ""getaddrinfo: %s\n"", gai_strerror(gai));
    goto bail;
}
",,
implicit_predicate,imap-send.c,1046,+,-,"if (buffer_gets(&imap->buf, &rsp)){
    fprintf(stderr, ""IMAP error: no greeting response\n"");
    goto bail;
}
",,
implicit_predicate,imap-send.c,1071,+,-,"if (ssl_socket_connect(&imap->buf.sock, 1, srvc->ssl_verify))
    goto bail;
",,
implicit_predicate,imap-send.c,1105,+,-,"if (CAP(NOLOGIN)){
    fprintf(stderr, ""Skipping account %s@%s, server forbids LOGIN\n"", srvc->user, srvc->host);
    goto bail;
}
",,
implicit_predicate,imap-send.c,1244,+,-,"while (1){
    if (starts_with(p, ""From "")){
        p = strstr(p + 5, ""\nFrom: "");
        if (!p)
            break;

        p = strstr(p + 7, ""\nDate: "");
        if (!p)
            break;

        p = strstr(p + 7, ""\nSubject: "");
        if (!p)
            break;

        p += 10;
        count++;
    }
    p = strstr(p + 5, ""\nFrom "");
    if (!p)
        break;

    p++;
}
",,
implicit_predicate,imap-send.c,1356,+,-,"while (1){
    unsigned percent = n * 100 / total;
    fprintf(stderr, ""%4u%% (%d/%d) done\r"", percent, n, total);
    if (!split_msg(all_msgs, &msg, &ofs))
        break;

    if (server->use_html)
        wrap_in_html(&msg);

    r = imap_store_msg(ctx, &msg);
    if (r != DRV_OK)
        break;

    n++;
}
",,
implicit_predicate,imap-send.c,1363,+,-,"if (server->use_html)
    wrap_in_html(&msg);
",,
implicit_predicate,imap-send.c,1396,-,+,,23,"	strbuf_addstr(&path, srvc->use_ssl ? ""imaps://"" : ""imap://"");"
implicit_predicate,imap-send.c,1509,+,-,"if (argc)
    usage_with_options(imap_send_usage, imap_send_options);
",,
implicit_predicate,imap-send.c,1513,+,-,"if (use_curl){
    warning(""--curl not supported in this build"");
    use_curl = 0;
}
",,
implicit_predicate,imap-send.c,1525,+,+,server.use_ssl ? 993 : 143,17,		server.port = server.use_ssl ? 993 : 143;
implicit_predicate,index-pack.c,174,+,-,"if (threads_active)
    pthread_mutex_lock(mutex);
",,
implicit_predicate,index-pack.c,180,+,-,"if (threads_active)
    pthread_mutex_unlock(mutex);
",,
implicit_predicate,index-pack.c,193,+,-,"if (show_stat)
    pthread_mutex_init(&deepest_delta_mutex, NULL);
",,
implicit_predicate,index-pack.c,213,+,-,"if (show_stat)
    pthread_mutex_destroy(&deepest_delta_mutex);
",,
implicit_predicate,index-pack.c,268,+,-,"if (verbose)
    progress = start_delayed_progress(_(""Checking objects""), max);
",,
implicit_predicate,index-pack.c,284,+,-,"if (input_offset){
    if (output_fd >= 0)
        write_or_die(output_fd, input_buffer, input_offset);

    the_hash_algo->update_fn(&input_ctx, input_buffer, input_offset);
    memmove(input_buffer, input_buffer + input_offset, input_len);
    input_offset = 0;
}
",,
implicit_predicate,index-pack.c,316,+,-,"if (from_stdin)
    display_throughput(progress, consumed_bytes + input_len);
",,
implicit_predicate,index-pack.c,344,+,-,"if (from_stdin){
    input_fd = 0;
    if (!pack_name){
        struct strbuf tmp_file = STRBUF_INIT;
        output_fd = odb_mkstemp(&tmp_file, ""pack/tmp_pack_XXXXXX"");
        pack_name = strbuf_detach(&tmp_file, NULL);
    }else{
        output_fd = xopen(pack_name, O_CREAT | O_EXCL | O_RDWR, 0600);
    }
    nothread_data.pack_fd = output_fd;
}else{
    input_fd = xopen(pack_name, O_RDONLY);
    output_fd = -1;
    nothread_data.pack_fd = input_fd;
}
",,
implicit_predicate,index-pack.c,520,+,-,"while (c & 0x80){
    p = fill(1);
    c = *p;
    use(1);
    size += (c & 0x7f) << shift;
    shift += 7;
}
",,
implicit_predicate,index-pack.c,539,+,-,"while (c & 128){
    base_offset += 1;
    if (!base_offset || MSB(base_offset, 7))
        bad_object(obj->idx.offset, _(""offset value overflow for delta base object""));

    p = fill(1);
    c = *p;
    use(1);
    base_offset = (base_offset << 7) + (c & 127);
}
",,
implicit_predicate,index-pack.c,577,-,+,,18,	data = xmallocz(consume ? 64*1024 : obj->size);
implicit_predicate,index-pack.c,583,-,+,,21,	stream.avail_out = consume ? 64*1024 : obj->size;
implicit_predicate,index-pack.c,604,+,-,"if (consume(data, stream.next_out - data, cb_data)){
    free(inbuf);
    free(data);
    return NULL;
}
",,
implicit_predicate,index-pack.c,637,+,-,"if (cmp)
    return cmp;
",,
implicit_predicate,index-pack.c,693,+,-,"if (cmp)
    return cmp;
",,
implicit_predicate,index-pack.c,759,+,-,"while (size){
    ssize_t len = read_istream(data->st, data->buf, size);
    if (len == 0)
        die(_(""SHA1 COLLISION FOUND WITH %s !""), oid_to_hex(&data->entry->idx.oid));

    if (len < 0)
        die(_(""unable to read %s""), oid_to_hex(&data->entry->idx.oid));

    if (memcmp(buf, data->buf, len))
        die(_(""SHA1 COLLISION FOUND WITH %s !""), oid_to_hex(&data->entry->idx.oid));

    size -= len;
    buf += len;
}
",,
implicit_predicate,index-pack.c,823,+,-,"if (collision_test_needed){
    void* has_data;
    enum object_type has_type;
    unsigned long has_size;
    read_lock();
    has_type = oid_object_info(the_repository, oid, &has_size);
    if (has_type < 0)
        die(_(""cannot read existing object info %s""), oid_to_hex(oid));

    if (has_type != type || has_size != size)
        die(_(""SHA1 COLLISION FOUND WITH %s !""), oid_to_hex(oid));

    has_data = repo_read_object_file(the_repository, oid, &has_type, &has_size);
    read_unlock();
    if (!data)
        data = new_data = get_data_from_pack(obj_entry);

    if (!has_data)
        die(_(""cannot read existing object %s""), oid_to_hex(oid));

    if (size != has_size || type != has_type || memcmp(data, has_data, size) != 0)
        die(_(""SHA1 COLLISION FOUND WITH %s !""), oid_to_hex(oid));

    free(has_data);
}
",,
implicit_predicate,index-pack.c,969,+,-,"if (show_stat){
    int i = delta_obj - objects;
    int j = base->obj - objects;
    obj_stat[i].delta_depth = obj_stat[j].delta_depth + 1;
    deepest_delta_lock();
    if (deepest_delta < obj_stat[i].delta_depth)
        deepest_delta = obj_stat[i].delta_depth;

    deepest_delta_unlock();
    obj_stat[i].base_object_no = j;
}
",,
implicit_predicate,index-pack.c,1101,+,-,"if (child->children_remaining){
    child->data = get_data_from_pack(child_obj);
    child->size = child_obj->size;
}
",,
implicit_predicate,index-pack.c,1138,+,-,"if (p->children_remaining)
    break;
",,
implicit_predicate,index-pack.c,1169,+,-,"if (verbose)
    progress = start_progress(progress_title ? progress_title : from_stdin ? _(""Receiving objects"") : _(""Indexing objects""), nr_objects);
",,
implicit_predicate,index-pack.c,1171,-,+,,5,"				progress_title ? progress_title :
				from_stdin ? _(""Receiving objects"") : _(""Indexing objects""),"
implicit_predicate,index-pack.c,1172,+,+,"from_stdin ? _(""Receiving objects"") : _(""Indexing objects"")",5,"				from_stdin ? _(""Receiving objects"") : _(""Indexing objects""),"
implicit_predicate,index-pack.c,1227,+,-,"if (nr_delays)
    die(_(""confusion beyond insanity in parse_pack_objects()""));
",,
implicit_predicate,index-pack.c,1262,+,-,"if (ret)
    die(_(""unable to create thread: %s""), strerror(ret));
",,
implicit_predicate,index-pack.c,1290,+,-,"if (fix_thin_pack){
    struct hashfile* f;
    unsigned char read_hash[GIT_MAX_RAWSZ], tail_hash[GIT_MAX_RAWSZ];
    struct strbuf msg = STRBUF_INIT;
    int nr_unresolved = nr_ofs_deltas + nr_ref_deltas - nr_resolved_deltas;
    int nr_objects_initial = nr_objects;
    if (nr_unresolved <= 0)
        die(_(""confusion beyond insanity""));

    REALLOC_ARRAY(objects, nr_objects + nr_unresolved + 1);
    memset(objects + nr_objects + 1, 0, nr_unresolved * sizeof (*objects));
    f = hashfd(output_fd, curr_pack);
    fix_unresolved_deltas(f);
    strbuf_addf(&msg, Q_(""completed with %d local object"", ""completed with %d local objects"", nr_objects - nr_objects_initial), nr_objects - nr_objects_initial);
    stop_progress_msg(&progress, msg.buf);
    strbuf_release(&msg);
    finalize_hashfile(f, tail_hash, FSYNC_COMPONENT_PACK, 0);
    hashcpy(read_hash, pack_hash);
    fixup_pack_header_footer(output_fd, pack_hash, curr_pack, nr_objects, read_hash, consumed_bytes - the_hash_algo->rawsz);
    if (!hasheq(read_hash, tail_hash))
        die(_(""Unexpected tail checksum for %s (disk corruption?)""), curr_pack);
}
",,
implicit_predicate,index-pack.c,1359,+,-,"while (s){
    header[n++] = c | 0x80;
    c = s & 0x7f;
    s >>= 7;
}
",,
implicit_predicate,index-pack.c,1512,+,-,"if (make_read_only_if_same){
    chmod(*final_name, 0444);
}
",,
implicit_predicate,index-pack.c,1551,+,-,"if (do_fsck_object){
    struct packed_git* p;
    p = add_packed_git(final_index_name, strlen(final_index_name), 0);
    if (p)
        install_packed_git(the_repository, p);
}
",,
implicit_predicate,index-pack.c,1680,+,-,"if (deepest_delta)
    CALLOC_ARRAY(chain_histogram, deepest_delta);
",,
implicit_predicate,index-pack.c,1688,+,-,"if (stat_only)
    continue;
",,
implicit_predicate,index-pack.c,1703,+,-,"if (baseobjects)
    printf_ln(Q_(""non delta: %d object"", ""non delta: %d objects"", baseobjects), baseobjects);
",,
implicit_predicate,index-pack.c,1812,+,-,"if (*c)
    die(_(""bad %s""), arg);
",,
implicit_predicate,index-pack.c,1871,+,-,"if (rev_index){
    opts.flags |= verify ? WRITE_REV_VERIFY : WRITE_REV;
    if (index_name)
        rev_index_name = derive_filename(index_name, ""idx"", ""rev"", &rev_index_name_buf);
}
",,
implicit_predicate,index-pack.c,1872,+,+,verify ? WRITE_REV_VERIFY : WRITE_REV,17,		opts.flags |= verify ? WRITE_REV_VERIFY : WRITE_REV;
implicit_predicate,index-pack.c,1879,+,-,"if (verify){
    if (!index_name)
        die(_(""--verify with no packfile name given""));

    read_idx_option(&opts, index_name);
    opts.flags |= WRITE_IDX_VERIFY | WRITE_IDX_STRICT;
}
",,
implicit_predicate,index-pack.c,1885,+,-,"if (strict)
    opts.flags |= WRITE_IDX_STRICT;
",,
implicit_predicate,index-pack.c,1911,+,-,"if (show_stat)
    CALLOC_ARRAY(obj_stat, st_add(nr_objects, 1));
",,
implicit_predicate,index-pack.c,1915,+,-,"if (report_end_of_input)
    write_in_full(2, ""\0"", 1);
",,
implicit_predicate,index-pack.c,1921,+,-,"if (strict)
    foreign_nr = check_objects();
",,
implicit_predicate,index-pack.c,1924,+,-,"if (show_stat)
    show_pack_info(stat_only);
",,
implicit_predicate,index-pack.c,1931,+,-,"if (rev_index)
    curr_rev_index = write_rev_file(rev_index_name, idx_objects, nr_objects, pack_hash, opts.flags);
",,
implicit_predicate,inet_pton.c,162,+,-,"if (saw_xdigit){
    if (tp + NS_INT16SZ > endp)
        return (0);

    *tp++ = (unsigned char)(val >> 8) & 0xff;
    *tp++ = (unsigned char)val & 0xff;
}
",,
implicit_predicate,init-db.c,33,+,-,"if (cwd_is_git_dir)
    return 1;
",,
implicit_predicate,init-db.c,54,-,+,,26,"	*((int *) opt->value) = (arg) ? git_config_perm(""arg"", arg) : PERM_GROUP;"
implicit_predicate,interpret-trailers.c,66,+,-,"if (unset){
    new_trailers_clear(trailers);
    return 0;
}
",,
implicit_predicate,interpret-trailers.c,229,+,-,"if (argc){
    int i;
    for (i = 0;i < argc;i++)
        interpret_trailers(&opts, &trailers, argv[i]);
}else{
    if (opts.in_place)
        die(_(""no input file given for in-place editing""));

    interpret_trailers(&opts, &trailers, NULL);
}
",,
implicit_predicate,ipc-shared.c,21,+,-,"if (ret)
    return ret;
",,
implicit_predicate,ipc-unix-socket.c,254,+,-,"if (make_nonblocking)
    flags |= O_NONBLOCK;
else
    flags &= ~O_NONBLOCK;
",,
implicit_predicate,ipc-unix-socket.c,401,+,-,"if (server_data->shutdown_requested)
    break;
",,
implicit_predicate,ipc-unix-socket.c,488,+,-,"if (in_shutdown)
    goto cleanup;
",,
implicit_predicate,ipc-unix-socket.c,732,+,-,"if (server_data->shutdown_requested){
    pthread_mutex_unlock(&server_data->work_available_mutex);
    if (client_fd >= 0)
        close(client_fd);

    break;
}
",,
implicit_predicate,ipc-unix-socket.c,790,+,-,"if (ret)
    return ret;
",,
implicit_predicate,ipc-unix-socket.c,850,+,-,"if (set_socket_blocking_flag(sv[1], 1)){
    int saved_errno = errno;
    close(sv[0]);
    close(sv[1]);
    errno = saved_errno;
    return -1;
}
",,
implicit_predicate,ipc-unix-socket.c,859,+,-,"if (ret){
    int saved_errno = errno;
    close(sv[0]);
    close(sv[1]);
    errno = saved_errno;
    return ret;
}
",,
implicit_predicate,ipc-win32.c,39,+,-,"for (;wpath[off];off++)
    if (wpath[off] == L'/')
        wpath[off] = L'\\';
",,
implicit_predicate,ipc-win32.c,734,+,-,"if (is_first){
    dwOpenMode |= FILE_FLAG_FIRST_PIPE_INSTANCE;
    get_sa(&my_sa_data);
}
",,
implicit_predicate,iter.c,32,+,-,"while (1){
    err = reftable_iterator_next_ref(&fri->it, ref);
    if (err != 0){
        break;
    }
    if (fri->double_check){
        struct reftable_iterator it = {NULL};
        err = reftable_table_seek_ref(&fri->tab, &it, ref->refname);
        if (err == 0){
            err = reftable_iterator_next_ref(&it, ref);
        }
        reftable_iterator_destroy(&it);
        if (err < 0){
            break;
        }
        if (err > 0){
            continue;
        }
    }
    if (ref->value_type == REFTABLE_REF_VAL2 && (!memcmp(fri->oid.buf, ref->value.val2.target_value, fri->oid.len) || !memcmp(fri->oid.buf, ref->value.val2.value, fri->oid.len)))
        return 0;

    if (ref->value_type == REFTABLE_REF_VAL1 && !memcmp(fri->oid.buf, ref->value.val1, fri->oid.len)){
        return 0;
    }
}
",,
implicit_predicate,iter.c,39,+,-,"while (1){
    err = reftable_iterator_next_ref(&fri->it, ref);
    if (err != 0){
        break;
    }
    if (fri->double_check){
        struct reftable_iterator it = {NULL};
        reftable_table_init_ref_iter(&fri->tab, &it);
        err = reftable_iterator_seek_ref(&it, ref->refname);
        if (err == 0)
            err = reftable_iterator_next_ref(&it, ref);

        reftable_iterator_destroy(&it);
        if (err < 0){
            break;
        }
        if (err > 0){
            continue;
        }
    }
    if (ref->value_type == REFTABLE_REF_VAL2 && (!memcmp(fri->oid.buf, ref->value.val2.target_value, fri->oid.len) || !memcmp(fri->oid.buf, ref->value.val2.value, fri->oid.len)))
        return 0;

    if (ref->value_type == REFTABLE_REF_VAL1 && !memcmp(fri->oid.buf, ref->value.val1, fri->oid.len)){
        return 0;
    }
}
",,
implicit_predicate,iter.c,127,+,-,"while (1){
    int err = block_iter_next(&it->cur, rec);
    if (err < 0){
        return err;
    }
    if (err > 0){
        err = indexed_table_ref_iter_next_block(it);
        if (err < 0){
            return err;
        }
        if (it->is_finished){
            return 1;
        }
        continue;
    }
    if (!memcmp(it->oid.buf, ref->value.val2.target_value, it->oid.len) || !memcmp(it->oid.buf, ref->value.val2.value, it->oid.len)){
        return 0;
    }
}
",,
implicit_predicate,iter.c,141,+,-,"while (1){
    int err = block_iter_next(&it->cur, rec);
    if (err < 0){
        return err;
    }
    if (err > 0){
        err = indexed_table_ref_iter_next_block(it);
        if (err < 0){
            return err;
        }
        if (it->is_finished){
            return 1;
        }
        continue;
    }
    if (!memcmp(it->oid.buf, ref->value.val2.target_value, it->oid.len) || !memcmp(it->oid.buf, ref->value.val2.value, it->oid.len)){
        return 0;
    }
}
",,
implicit_predicate,iterator.c,173,+,-,"while (1){
    struct ref_iterator** secondary;
    enum iterator_selection selection = iter->select(iter->iter0, iter->iter1, iter->cb_data);
    if (selection == ITER_SELECT_DONE){
        return ref_iterator_abort(ref_iterator);
    }else
        if (selection == ITER_SELECT_ERROR){
            ref_iterator_abort(ref_iterator);
            return ITER_ERROR;
        }

    if ((selection & ITER_CURRENT_SELECTION_MASK) == 0){
        iter->current = &iter->iter0;
        secondary = &iter->iter1;
    }else{
        iter->current = &iter->iter1;
        secondary = &iter->iter0;
    }
    if (selection & ITER_SKIP_SECONDARY){
        if ((ok = ref_iterator_advance(*secondary)) != ITER_OK){
            *secondary = NULL;
            if (ok == ITER_ERROR)
                goto error;
        }
    }
    if (selection & ITER_YIELD_CURRENT){
        iter->base.refname = (*iter->current)->refname;
        iter->base.oid = (*iter->current)->oid;
        iter->base.flags = (*iter->current)->flags;
        return ITER_OK;
    }
}
",,
implicit_predicate,iterator.c,286,-,+,,10,		return front ? ITER_SELECT_0 : ITER_SELECT_DONE;
implicit_predicate,iterator.c,308,+,-,"if (is_empty_ref_iterator(front)){
    ref_iterator_abort(front);
    return back;
}else
    if (is_empty_ref_iterator(back)){
        ref_iterator_abort(back);
        return front;
    }
",,
implicit_predicate,iterator.c,311,+,-,"if (is_empty_ref_iterator(back)){
    ref_iterator_abort(back);
    return front;
}
",,
implicit_predicate,iterator.c,363,+,-,"if (iter->trim){
    if (strlen(iter->iter0->refname) <= iter->trim)
        BUG(""attempt to trim too many characters"");

    iter->base.refname = iter->iter0->refname + iter->trim;
}else{
    iter->base.refname = iter->iter0->refname;
}
",,
implicit_predicate,iterator.c,452,+,-,"if (retval){
    ref_iterator_abort(iter);
    goto out;
}
",,
implicit_predicate,json-writer.c,191,+,-,"if (value)
    jw_object_true(jw, key);
else
    jw_object_false(jw, key);
",,
implicit_predicate,json-writer.c,336,+,-,"if (value)
    jw_array_true(jw);
else
    jw_array_false(jw);
",,
implicit_predicate,kwset.c,185,-,+,,15,      label = kwset->trans ? kwset->trans[U(*--text)] : *--text;
implicit_predicate,kwset.c,552,-,+,,14,      return tp ? tp - text : -1;
implicit_predicate,kwset.c,674,+,-,"if (d)
    continue;
",,
implicit_predicate,kwset.c,686,-,+,,8,	  c = trans ? trans[U(*--beg)] : *--beg;
implicit_predicate,kwset.c,737,-,+,,8,	  c = trans ? trans[U(*--beg)] : *--beg;
implicit_predicate,line-log.c,587,-,+,,35,"		full_name = prefix_path(prefix, prefix ? strlen(prefix) : 0,"
implicit_predicate,line-log.c,805,+,-,"if (keep_deletions)
    diff_q(&outq, p);
else
    diff_free_filepair(p);
",,
implicit_predicate,line-log.c,846,-,+,,20,	parent_tree_oid = parent ? get_commit_tree_oid(parent) : NULL;
implicit_predicate,line-log.c,938,-,+,,9,"	       pair->one->oid_valid ? ""a/"" : """","
implicit_predicate,line-log.c,939,-,+,,9,"	       pair->one->oid_valid ? pair->one->path : ""/dev/null"","
implicit_predicate,line-log.c,1110,+,-,"if (process_diff_filepair(rev, pair, *range_out, &pairdiff)){
    struct line_log_data* rg = range;
    changed++;
    while (rg && strcmp(rg->path, pair->two->path))
        rg = rg->next;
    assert(rg);
    rg->pair = diff_filepair_dup(queue->queue[i]);
    memcpy(&rg->diff, pairdiff, sizeof (struct diff_ranges));
}
",,
implicit_predicate,line-log.c,1311,+,-,"if (line_log_process_ranges_arbitrary_commit(rev, commit)){
    *pp = list;
    pp = &list->next;
}else
    to_free = list;
",,
implicit_predicate,line-range.c,142,+,-,"if (reg_error){
    char errbuf[1024];
    regerror(reg_error, regexp, errbuf, 1024);
    die(""-L parameter: regexec() failed: %s"", errbuf);
}
",,
implicit_predicate,line-range.c,210,+,-,"if (reg_error){
    char errbuf[1024];
    regerror(reg_error, &regexp, errbuf, 1024);
    die(""-L parameter '%s': %s"", pattern, errbuf);
}
",,
implicit_predicate,list-objects-filter-options.c,188,+,-,"if (result)
    list_objects_filter_release(filter_options);
",,
implicit_predicate,list-objects-filter-options.c,282,+,-,"if (parse_error)
    die(""%s"", errbuf.buf);
",,
implicit_predicate,list-objects-filter.c,153,+,-,"if (include_it)
    return oidset_remove(omits, &obj->oid);
else
    return oidset_insert(omits, &obj->oid);
",,
implicit_predicate,list-objects-filter.c,201,-,+,,10,		return include_it ? LOFR_MARK_SEEN | LOFR_DO_SHOW : LOFR_ZERO;
implicit_predicate,list-objects-filter.c,647,+,-,"if (sub->is_skipping_tree){
    if (filter_situation == LOFS_END_TREE && oideq(&obj->oid, &sub->skip_tree))
        sub->is_skipping_tree = 0;
    else
        return LOFR_ZERO;
}
",,
implicit_predicate,list-objects-filter.c,738,-,+,,4,"			filter->omits ? &d->sub[sub].omits : NULL,"
implicit_predicate,list-objects.c,170,+,-,"if (failed_parse){
    if (revs->ignore_missing_links)
        return;

    if (revs->exclude_promisor_objects && is_promisor_object(&obj->oid))
        return;

    if (!revs->do_not_die_on_missing_objects)
        die(""bad tree object %s"", oid_to_hex(&obj->oid));
}
",,
implicit_predicate,list-objects.c,286,+,-,"if (sparse){
    struct oidset set;
    oidset_init(&set, 16);
    for (list = revs->commits;list;list = list->next){
        struct commit* commit = list->item;
        struct tree* tree = repo_get_commit_tree(the_repository, commit);
        if (commit->object.flags & UNINTERESTING)
            tree->object.flags |= UNINTERESTING;

        oidset_insert(&set, &tree->object.oid);
        add_edge_parents(commit, revs, show_edge, &set);
    }
    mark_trees_uninteresting_sparse(revs->repo, &set);
    oidset_clear(&set);
}else{
    for (list = revs->commits;list;list = list->next){
        struct commit* commit = list->item;
        if (commit->object.flags & UNINTERESTING){
            mark_tree_uninteresting(revs->repo, repo_get_commit_tree(the_repository, commit));
            if (revs->edge_hint_aggressive && !(commit->object.flags & SHOWN)){
                commit->object.flags |= SHOWN;
                show_edge(commit);
            }
            continue;
        }
        mark_edge_parents_uninteresting(commit, revs, show_edge);
    }
}
",,
implicit_predicate,lockfile.c,55,+,-,"while (depth--){
    if (strbuf_readlink(&link, path->buf, path->len) < 0)
        break;

    if (is_absolute_path(link.buf))
        strbuf_reset(path);
    else
        trim_last_path_component(path);

    strbuf_addbuf(path, &link);
}
",,
implicit_predicate,lockfile.c,87,-,+,,9,	return lk->tempfile ? lk->tempfile->fd : -1;
implicit_predicate,lockfile.c,123,+,-,"while (1){
    long backoff_ms, wait_ms;
    int fd;
    fd = lock_file(lk, path, flags, mode);
    if (fd >= 0)
        return fd;
    else
        if (errno != EEXIST)
            return -1;
        else
            if (timeout_ms > 0 && remaining_ms <= 0)
                return -1;

    backoff_ms = multiplier * INITIAL_BACKOFF_MS;
    wait_ms = (750 + rand() % 500) * backoff_ms / 1000;
    sleep_millisec(wait_ms);
    remaining_ms -= wait_ms;
    multiplier += 2 * n + 1;
    if (multiplier > BACKOFF_MAX_MULTIPLIER)
        multiplier = BACKOFF_MAX_MULTIPLIER;
    else
        n++;
}
",,
implicit_predicate,log-tree.c,123,+,-,"if (match_ref_pattern(refname, item))
    return 0;
",,
implicit_predicate,log-tree.c,130,+,-,"if (match_ref_pattern(refname, item))
    return 1;
",,
implicit_predicate,log-tree.c,138,+,-,"if (match_ref_pattern(refname, item))
    return 0;
",,
implicit_predicate,log-tree.c,464,-,+,,8,"			    *opt->subject_prefix ? "" "" : """","
implicit_predicate,log-tree.c,481,-,+,,32,"	const char *name = oid_to_hex(opt->zero_commit ?
				      null_oid() : &commit->object.oid);"
implicit_predicate,log-tree.c,538,-,+,,5,"			 opt->no_inline ? ""attachment"" : ""inline"","
implicit_predicate,log-tree.c,543,-,+,,21,"	*extra_headers_p = headers.len ? strbuf_detach(&headers, NULL) : NULL;"
implicit_predicate,log-tree.c,551,+,-,status ? DIFF_WHITESPACE : DIFF_FRAGINFO,,
implicit_predicate,log-tree.c,556,-,+,,10,"		       *eol ? ""\n"" : """");"
implicit_predicate,log-tree.c,558,-,+,,9,		bol = (*eol) ? (eol + 1) : eol;
implicit_predicate,log-tree.c,668,-,+,,18,"	const char *x = opt->shown_dashes ? ""\n"" : ""---\n"";"
implicit_predicate,log-tree.c,681,-,+,,22,	int abbrev_commit = opt->abbrev_commit ? opt->abbrev : the_hash_algo->hexsz;
implicit_predicate,log-tree.c,1097,+,-,"if (is_merge){
    int octopus = (parents->next->next != NULL);
    if (opt->remerge_diff){
        if (octopus){
            show_log(opt);
            fprintf(opt->diffopt.file, ""diff: warning: Skipping remerge-diff for octopus merges.\n"");
            return 1;
        }
        return do_remerge_diff(opt, parents, oid);
    }
    if (opt->combine_merges)
        return do_diff_combined(opt, commit);

    if (opt->separate_merges){
        if (!opt->first_parent_merges){
            log->parent = parents->item;
        }
    }else
        return 0;
}
",,
implicit_predicate,log-tree.c,1101,+,-,"if (octopus){
    show_log(opt);
    fprintf(opt->diffopt.file, ""diff: warning: Skipping remerge-diff for octopus merges.\n"");
    return 1;
}
",,
implicit_predicate,log.c,88,+,+,session_is_interactive() ? DECORATE_SHORT_REFS : 0,9,	return session_is_interactive() ? DECORATE_SHORT_REFS : 0;
implicit_predicate,log.c,174,+,-,"if (default_follow)
    rev->diffopt.flags.default_follow_renames = 1;
",,
implicit_predicate,log.c,278,+,-,"if (quiet)
    rev->diffopt.output_format |= DIFF_FORMAT_NO_OUTPUT;
",,
implicit_predicate,log.c,306,+,-,"if (mailmap){
    rev->mailmap = xmalloc(sizeof (struct string_list));
    string_list_init_nodup(rev->mailmap);
    read_mailmap(rev->mailmap);
}
",,
implicit_predicate,log.c,343,+,-,"if (decoration_style)
    rev->show_decorations = 1;
",,
implicit_predicate,log.c,410,+,-,"if (show_header){
    int n = estimate_commit_count(list);
    show_early_header(revs, ""incomplete"", n);
    show_header = 0;
}
",,
implicit_predicate,log.c,787,+,-,"if (ret)
    break;
",,
implicit_predicate,log.c,1037,-,+,,12,"		thread = git_config_bool(var, value) ? THREAD_SHALLOW : THREAD_UNSET;"
implicit_predicate,log.c,1053,-,+,,25,"		config_cover_letter = git_config_bool(var, value) ? COVER_ON : COVER_OFF;"
implicit_predicate,log.c,1063,-,+,,15,"		auto_base = git_config_bool(var, value) ? AUTO_BASE_ALWAYS : AUTO_BASE_NEVER;"
implicit_predicate,log.c,1071,+,-,"if (b)
    from = xstrdup(git_committer_info(IDENT_NO_DATE));
else
    from = NULL;
",,
implicit_predicate,log.c,1085,+,-,"if (b)
    enable_default_display_notes(&notes_opt, &show_notes);
else
    disable_display_notes(&notes_opt, &show_notes);
",,
implicit_predicate,log.c,1348,-,+,,27,"	    open_next_file(NULL, rev->numbered_files ? NULL : ""cover-letter"", rev, quiet))"
implicit_predicate,log.c,1434,+,-,"while ((ch = *m)){
    if (!isspace(ch) && (ch != '>'))
        z = m;

    m++;
}
",,
implicit_predicate,log.c,1503,+,-,"if (unset)
    *rfc = NULL;
else
    *rfc = arg ? arg : ""RFC"";
",,
implicit_predicate,log.c,1506,-,+,,10,"		*rfc = arg ? arg : ""RFC"";"
implicit_predicate,log.c,1516,+,+,unset ? 0 : 1,46,	*(int *)opt->value = numbered_cmdline_opt = unset ? 0 : 1;
implicit_predicate,log.c,1517,+,-,"if (unset)
    auto_number = 0;
",,
implicit_predicate,log.c,1543,+,-,"if (unset)
    *thread = THREAD_UNSET;
else
    if (!arg || !strcmp(arg, ""shallow""))
        *thread = THREAD_SHALLOW;
    else
        if (!strcmp(arg, ""deep""))
            *thread = THREAD_DEEP;
        else
            return 1;
",,
implicit_predicate,log.c,1561,+,-,"if (unset)
    rev->mime_boundary = NULL;
else
    if (arg)
        rev->mime_boundary = arg;
    else
        rev->mime_boundary = git_version_string;
",,
implicit_predicate,log.c,1567,+,+,unset ? 0 : 1,19,	rev->no_inline = unset ? 0 : 1;
implicit_predicate,log.c,1574,+,-,"if (unset)
    rev->mime_boundary = NULL;
else
    if (arg)
        rev->mime_boundary = arg;
    else
        rev->mime_boundary = git_version_string;
",,
implicit_predicate,log.c,1603,+,-,"if (unset)
    *from = NULL;
else
    if (arg)
        *from = xstrdup(arg);
    else
        *from = xstrdup(git_committer_info(IDENT_NO_DATE));
",,
implicit_predicate,log.c,1616,+,-,"if (unset){
    auto_base = AUTO_BASE_NEVER;
    *base_commit = NULL;
}else
    if (!strcmp(arg, ""auto"")){
        auto_base = AUTO_BASE_ALWAYS;
        *base_commit = NULL;
    }else{
        auto_base = AUTO_BASE_NEVER;
        *base_commit = arg;
    }
",,
implicit_predicate,log.c,1679,+,-,"if (die_on_failure)
    die(_(""failed to resolve '%s' as a valid ref""), upstream);
else
    return NULL;
",,
implicit_predicate,log.c,1691,+,-,"if (die_on_failure){
    die(_(""could not find exact merge base""));
}else{
    free_commit_list(base_list);
    return NULL;
}
",,
implicit_predicate,log.c,1701,+,-,"if (die_on_failure)
    die(_(""failed to get upstream, if you want to record base commit automatically,\nplease use git branch --set-upstream-to to track a remote branch.\nOr you could specify base commit by --base=<base-commit-id> manually""));
else
    return NULL;
",,
implicit_predicate,log.c,1726,+,-,"if (die_on_failure){
    die(_(""failed to find exact merge base""));
}else{
    free(rev);
    return NULL;
}
",,
implicit_predicate,log.c,1737,+,-,"if (rev_nr % 2)
    rev[i] = rev[2 * i];
",,
implicit_predicate,log.c,1746,+,-,"if (die_on_failure){
    die(_(""base commit should be the ancestor of revision list""));
}else{
    free(rev);
    return NULL;
}
",,
implicit_predicate,log.c,1756,+,-,"if (die_on_failure){
    die(_(""base commit shouldn't be in revision list""));
}else{
    free(rev);
    return NULL;
}
",,
implicit_predicate,log.c,1870,+,-,"if (prev_is_range)
    strbuf_addstr(r1, prev);
else
    strbuf_addf(r1, ""%s..%s"", head_oid, prev);
",,
implicit_predicate,log.c,1877,+,-,"if (prev_is_range)
    die(_(""failed to infer range-diff origin of current series""));
else{
    warning(_(""using '%s' as range-diff origin of current series""), prev);
    strbuf_addf(r2, ""%s..%s"", prev, head_oid);
}
",,
implicit_predicate,log.c,2041,+,-,"if (format_no_prefix)
    diff_set_noprefix(&rev.diffopt);
",,
implicit_predicate,log.c,2091,+,-,"if (i)
    strbuf_addstr(&buf, ""    "");
",,
implicit_predicate,log.c,2102,+,-,"if (i)
    strbuf_addstr(&buf, ""    "");
",,
implicit_predicate,log.c,2174,+,-,"if (use_stdout){
    setup_pager();
}else
    if (!rev.diffopt.close_file){
        int saved;
        if (!output_directory)
            output_directory = config_output_directory;

        output_directory = set_outdir(prefix, output_directory);
        if (rev.diffopt.use_color != GIT_COLOR_ALWAYS)
            rev.diffopt.use_color = GIT_COLOR_NEVER;

        saved = get_shared_repository();
        set_shared_repository(0);
        switch (safe_create_leading_directories_const(output_directory)){
            case SCLD_OK:
            case SCLD_EXISTS:
                break;
            default:
                die(_(""could not create leading directories of '%s'""), output_directory);
        }
        set_shared_repository(saved);
        if (mkdir(output_directory, 0777) < 0 && errno != EEXIST)
            die_errno(_(""could not create directory '%s'""), output_directory);
    }
",,
implicit_predicate,log.c,2227,+,-,"if (check_head){
    const char *ref, *v;
    ref = refs_resolve_ref_unsafe(get_main_ref_store(the_repository), ""HEAD"", RESOLVE_REF_READING, NULL, NULL);
    if (ref && skip_prefix(ref, ""refs/heads/"", &v))
        branch_name = xstrdup(v);
    else
        branch_name = xstrdup("""");
}
",,
implicit_predicate,log.c,2246,+,-,"if (ignore_if_in_upstream){
    if (rev.pending.nr == 2){
        struct object_array_entry* o = rev.pending.objects;
        if (oideq(&o[0].item->oid, &o[1].item->oid))
            goto done;
    }
    get_patch_ids(&rev, &ids);
}
",,
implicit_predicate,log.c,2285,+,-,"if (numbered)
    rev.total = total + start_number - 1;
",,
implicit_predicate,log.c,2347,+,-,"if (cover_letter){
    if (thread)
        gen_message_id(&rev, ""cover"");

    make_cover_letter(&rev, !!output_directory, origin, nr, list, description_file, branch_name, quiet);
    print_bases(&bases, rev.diffopt.file);
    print_signature(rev.diffopt.file);
    total++;
    start_number--;
    rev.idiff_oid1 = NULL;
    rev.rdiff1 = NULL;
}
",,
implicit_predicate,log.c,2362,+,-,"if (show_progress)
    progress = start_delayed_progress(_(""Generating patches""), total);
",,
implicit_predicate,log.c,2406,-,+,,22,"		    open_next_file(rev.numbered_files ? NULL : commit, NULL, &rev, quiet))"
implicit_predicate,log.c,2420,+,-,"if (shown){
    print_bases(&bases, rev.diffopt.file);
    if (rev.mime_boundary)
        fprintf(rev.diffopt.file, ""\n--%s%s--\n\n\n"", mime_boundary_leader, rev.mime_boundary);
    else
        print_signature(rev.diffopt.file);
}
",,
implicit_predicate,log.c,2438,+,-,"if (ignore_if_in_upstream)
    free_patch_ids(&ids);
",,
implicit_predicate,log.c,2536,+,-,"if (add_pending_commit(head, &revs, 0))
    die(_(""unknown commit %s""), head);
",,
implicit_predicate,loose.c,55,+,-,"if (inserted)
    oidtree_insert(odb->loose_objects_cache, compat_oid);
",,
implicit_predicate,loose.c,215,+,-,"if (inserted)
    return write_one_object(repo, oid, compat_oid);
",,
implicit_predicate,ls-files.c,71,+,-,"if (show_eol){
    struct stat st;
    const char* i_txt = """";
    const char* w_txt = """";
    const char* a_txt = get_convert_attr_ascii(istate, path);
    if (ce && S_ISREG(ce->ce_mode))
        i_txt = get_cached_convert_stats_ascii(istate, ce->name);

    if (!lstat(path, &st) && S_ISREG(st.st_mode))
        w_txt = get_wt_convert_stats_ascii(path);

    printf(""i/%-5s w/%-5s attr/%-17s\t"", i_txt, w_txt, a_txt);
}
",,
implicit_predicate,ls-files.c,91,+,+,prefix_len ? prefix : NULL,35,"	write_name_quoted_relative(name, prefix_len ? prefix : NULL,"
implicit_predicate,ls-files.c,98,+,+,prefix_len ? prefix : NULL,40,"	const char *rel = relative_path(name, prefix_len ? prefix : NULL, &buf);"
implicit_predicate,ls-files.c,100,+,-,"if (line_terminator)
    quote_c_style(rel, sb, NULL, 0);
else
    strbuf_addstr(sb, rel);
",,
implicit_predicate,ls-files.c,135,+,-,"if (debug_mode){
    const struct stat_data* sd = &ce->ce_stat_data;
    printf(""  ctime: %u:%u\n"", sd->sd_ctime.sec, sd->sd_ctime.nsec);
    printf(""  mtime: %u:%u\n"", sd->sd_mtime.sec, sd->sd_mtime.nsec);
    printf(""  dev: %u\tino: %u\n"", sd->sd_dev, sd->sd_ino);
    printf(""  uid: %u\tgid: %u\n"", sd->sd_uid, sd->sd_gid);
    printf(""  size: %u\tflags: %x\n"", sd->sd_size, ce->ce_flags);
}
",,
implicit_predicate,ls-files.c,222,+,-,"if (killed)
    show_dir_entry(istate, tag_killed, dir->entries[i]);
",,
implicit_predicate,ls-files.c,253,+,-,"if (padded)
    strbuf_addf(line, ""%7"", (uintmax_t)size);
else
    strbuf_addf(line, ""%"", (uintmax_t)size);
",,
implicit_predicate,ls-files.c,257,+,-,"if (padded){
    strbuf_addf(line, ""%7s"", ""-"");
}else{
    strbuf_addstr(line, ""-"");
}
",,
implicit_predicate,ls-files.c,403,+,-,"if (show_others)
    show_other_files(repo->index, dir);
",,
implicit_predicate,ls-files.c,405,+,-,"if (show_killed)
    show_killed_files(repo->index, dir);
",,
implicit_predicate,ls-files.c,433,+,-,"if (skipping_duplicates)
    goto skip_to_next_name;
",,
implicit_predicate,ls-files.c,446,+,-,"if (skipping_duplicates)
    goto skip_to_next_name;
",,
implicit_predicate,ls-files.c,452,+,-,"if (skipping_duplicates)
    goto skip_to_next_name;
",,
implicit_predicate,ls-files.c,680,+,-,"if (show_unmerged)
    show_stage = 1;
",,
implicit_predicate,ls-files.c,715,+,-,"if (recurse_submodules)
    max_prefix = NULL;
else
    max_prefix = common_prefix(&pathspec);
",,
implicit_predicate,ls-files.c,750,+,-,"if (show_resolve_undo)
    show_ru_info(the_repository->index);
",,
implicit_predicate,ls-refs.c,136,+,+,oid_is_null ? NULL : &oid,28,"		send_ref(namespaced.buf, oid_is_null ? NULL : &oid, flag, data);"
implicit_predicate,ls-remote.c,115,+,-,"if (get_url){
    printf(""%s\n"", *remote->url);
    return 0;
}
",,
implicit_predicate,ls-tree.c,31,+,-,"if (padded)
    strbuf_addf(line, ""%7"", (uintmax_t)size);
else
    strbuf_addf(line, ""%"", (uintmax_t)size);
",,
implicit_predicate,ls-tree.c,35,+,-,"if (padded){
    strbuf_addf(line, ""%7s"", ""-"");
}else{
    strbuf_addstr(line, ""-"");
}
",,
implicit_predicate,ls-tree.c,133,+,+,options->null_termination ? '\0' : '\n',20,"	strbuf_addch(&sb, options->null_termination ? '\0' : '\n');"
implicit_predicate,ls-tree.c,168,+,-,"if (options->null_termination){
    struct strbuf sb = STRBUF_INIT;
    const char* name = relative_path(base->buf, prefix, &sb);
    fputs(name, stdout);
    fputc('\0', stdout);
    strbuf_release(&sb);
}else{
    write_name_quoted_relative(base->buf, prefix, stdout, '\n');
}
",,
implicit_predicate,ls-tree.c,282,+,-,"if (options->null_termination){
    fputs(str, stdout);
    fputc('\0', stdout);
}else{
    puts(str);
}
",,
implicit_predicate,ls-tree.c,379,+,-,"if (full_tree)
    prefix = NULL;
",,
implicit_predicate,ls-tree.c,381,+,+,full_name ? NULL : prefix,19,	options.prefix = full_name ? NULL : prefix;
implicit_predicate,ls-tree.c,429,-,+,,9,			fn = options.format ? show_tree_fmt : show_tree_default;
implicit_predicate,mailinfo.c,182,-,+,,38,"	strbuf_remove(&f, at - f.buf, el + (at[el] ? 1 : 0));"
implicit_predicate,mailinfo.c,542,+,-,"if (found_error)
    mi->input_error = -1;
",,
implicit_predicate,mailinfo.c,555,+,-,"if (found_error)
    mi->input_error = -1;
",,
implicit_predicate,mailinfo.c,569,+,-,"if (cmp_header(line, ""Content-Type"")){
    len = strlen(""Content-Type: "");
    strbuf_add(&sb, line->buf + len, line->len - len);
    decode_header(mi, &sb);
    strbuf_insert(&sb, 0, ""Content-Type: "", len);
    handle_content_type(mi, &sb);
    ret = 1;
    goto check_header_out;
}
",,
implicit_predicate,mailinfo.c,578,+,-,"if (cmp_header(line, ""Content-Transfer-Encoding"")){
    len = strlen(""Content-Transfer-Encoding: "");
    strbuf_add(&sb, line->buf + len, line->len - len);
    decode_header(mi, &sb);
    handle_content_transfer_encoding(mi, &sb);
    ret = 1;
    goto check_header_out;
}
",,
implicit_predicate,mailinfo.c,586,+,-,"if (cmp_header(line, ""Message-Id"")){
    len = strlen(""Message-Id: "");
    strbuf_add(&sb, line->buf + len, line->len - len);
    decode_header(mi, &sb);
    if (mi->add_message_id)
        mi->message_id = strbuf_detach(&sb, NULL);

    ret = 1;
    goto check_header_out;
}
",,
implicit_predicate,mailinfo.c,596,+,-,"if (parse_header(line, ""Content-Type"", mi, &sb)){
    handle_content_type(mi, &sb);
    ret = 1;
    goto check_header_out;
}
",,
implicit_predicate,mailinfo.c,601,+,-,"if (parse_header(line, ""Content-Transfer-Encoding"", mi, &sb)){
    handle_content_transfer_encoding(mi, &sb);
    ret = 1;
    goto check_header_out;
}
",,
implicit_predicate,mailinfo.c,606,+,-,"if (parse_header(line, ""Message-ID"", mi, &sb)){
    if (mi->add_message_id)
        mi->message_id = strbuf_detach(&sb, NULL);

    ret = 1;
    goto check_header_out;
}
",,
implicit_predicate,mailinfo.c,682,+,-,"if (in_perforation){
    perforation++;
    gap++;
}
",,
implicit_predicate,mailinfo.c,700,+,-,"if (in_perforation){
    perforation++;
    gap++;
}
",,
implicit_predicate,mailinfo.c,764,+,-,"if (is_inbody_header(mi, line)){
    strbuf_addbuf(&mi->inbody_header_accum, line);
    return 1;
}
",,
implicit_predicate,mailinfo.c,782,+,-,"if (is_inbody_header(mi, line)){
    strbuf_addbuf(&mi->inbody_header_accum, line);
    return 1;
}
",,
implicit_predicate,mailinfo.c,817,+,-,"if (patchbreak(line)){
    if (mi->message_id)
        strbuf_addf(&mi->log_message, ""Message-Id: %s\n"", mi->message_id);

    return 1;
}
",,
implicit_predicate,mailinfo.c,835,+,-,"if (patchbreak(line)){
    if (mi->message_id)
        strbuf_addf(&mi->log_message, ""Message-ID: %s\n"", mi->message_id);

    return 1;
}
",,
implicit_predicate,mailinfo.c,865,+,-,"while ((ch = *cp++)){
    if (ch == ':')
        return 1;

    if ((33 <= ch && ch <= 57) || (59 <= ch && ch <= 126))
        continue;

    break;
}
",,
implicit_predicate,mailinfo.c,883,+,-,"while ((ch = *cp++)){
    if (ch == ':')
        return 1;

    if ((33 <= ch && ch <= 57) || (59 <= ch && ch <= 126))
        continue;

    break;
}
",,
implicit_predicate,mailinfo.c,1101,+,-,"while (1){
    char* ep = strchr(sp, '\n');
    int len;
    if (!ep)
        len = strlen(sp);
    else
        len = ep - sp;

    fprintf(fout, ""%s: %.*s\n"", hdr, len, sp);
    if (!ep)
        break;

    sp = ep + 1;
}
",,
implicit_predicate,mailinfo.c,1139,+,-,"while (1){
    char* ep = strchr(sp, '\n');
    int len;
    if (!ep)
        len = strlen(sp);
    else
        len = ep - sp;

    fprintf(fout, ""%s: %.*s\n"", hdr, len, sp);
    if (!ep)
        break;

    sp = ep + 1;
}
",,
implicit_predicate,mailmap.c,156,+,-,"if (flags & MAILMAP_NOFOLLOW)
    fd = open_nofollow(filename, O_RDONLY);
else
    fd = open(filename, O_RDONLY);
",,
implicit_predicate,mailmap.c,176,+,-,"while (*buf){
    char* end = strchrnul(buf, '\n');
    if (*end)
        *end++ = '\0';

    read_mailmap_line(map, buf);
    buf = end;
}
",,
implicit_predicate,mailmap.c,179,+,-,"if (*end)
    *end++ = '\0';
",,
implicit_predicate,mailmap.c,223,-,+,,7,"					 startup_info->have_repository ?
					 MAILMAP_NOFOLLOW : 0);"
implicit_predicate,malloc.c.h,4093,+,-,(NO_SEGMENT_TRAVERSAL) ? 0 : sp->next,,
implicit_predicate,malloc.c.h,4106,+,-,(NO_SEGMENT_TRAVERSAL) ? 0 : sp->next,,
implicit_predicate,malloc.c.h,4175,+,-,"if (NO_SEGMENT_TRAVERSAL)
    break;
",,
implicit_predicate,malloc.c.h,4212,+,-,"if (HAVE_MORECORE){
    if (extra >= HALF_MAX_SIZE_T)
        extra = (HALF_MAX_SIZE_T) + SIZE_T_ONE - unit;

    ;
    {
        char* old_br = (char*)(CALL_MORECORE(0));
        if (old_br == sp->base + sp->size){
            char* rel_br = (char*)(CALL_MORECORE(-extra));
            char* new_br = (char*)(CALL_MORECORE(0));
            if (rel_br != CMFAIL && new_br < old_br)
                released = old_br - new_br;
        }
    };
}
",,
implicit_predicate,malloc.c.h,4239,+,-,"if (HAVE_MMAP)
    released += release_unused_segments(m);
",,
implicit_predicate,malloc.c.h,4460,+,-,"if (PREACTION(m))
    return 0;
",,
implicit_predicate,malloc.c.h,4565,+,-,"if (opts & 0x1){
    element_size = request2size(*sizes);
    contents_size = n_elements * element_size;
}else{
    element_size = 0;
    contents_size = 0;
    for (i = 0;i != n_elements;++i)
        contents_size += request2size(sizes[i]);
}
",,
implicit_predicate,malloc.c.h,4591,+,-,"if (PREACTION(m))
    return 0;
",,
implicit_predicate,malloc.c.h,4597,+,-,"if (opts & 0x2){
    memset((size_t*)mem, 0, remainder_size - SIZE_T_SIZE - array_size);
}
",,
implicit_predicate,match-trees.c,158,+,-,"if (recurse_limit){
    char* newbase = xstrfmt(""%s%s/"", base, path);
    match_trees(elem, hash2, best_score, best_match, newbase, recurse_limit - 1);
    free(newbase);
}
",,
implicit_predicate,match-trees.c,191,+,-,"if (*subpath)
    subpath++;
",,
implicit_predicate,match-trees.c,230,+,-,"if (*subpath){
    struct object_id tree_oid;
    oidread(&tree_oid, rewrite_here);
    status = splice_tree(&tree_oid, subpath, oid2, &subtree);
    if (status)
        return status;

    rewrite_with = &subtree;
}else{
    rewrite_with = oid2;
}
",,
implicit_predicate,match-trees.c,234,+,-,"if (status)
    return status;
",,
implicit_predicate,mem-pool.c,78,+,-,"if (invalidate_memory)
    memset(block_to_free->space, 0xDD, ((char*)block_to_free->end) - ((char*)block_to_free->space));
",,
implicit_predicate,mem-pool.c,115,-,+,,20,	char *next_free = block ? block->next_free : NULL;
implicit_predicate,mem-pool.c,116,-,+,,21,	size_t available = block ? block->end - block->next_free : 0;
implicit_predicate,mem-pool.c,171,-,+,,23,	size_t actual_len = (p ? p - str : len);
implicit_predicate,merge-base.c,119,+,-,"if (ret)
    return 0;
else
    return 1;
",,
implicit_predicate,merge-base.c,173,+,-,"if (show_all)
    die(_(""options '%s' and '%s' cannot be used together""), ""--is-ancestor"", ""--all"");
",,
implicit_predicate,merge-file.c,101,+,-,"if (quiet){
    if (!freopen(""/dev/null"", ""w"", stderr))
        return error_errno(""failed to redirect stderr to /dev/null"");
}
",,
implicit_predicate,merge-file.c,106,+,-,"if (object_id)
    setup_git_directory();
",,
implicit_predicate,merge-file.c,119,+,-,"if (object_id){
    if (repo_get_oid(the_repository, argv[i], &oid))
        ret = error(_(""object '%s' does not exist""), argv[i]);
    else
        if (!oideq(&oid, the_hash_algo->empty_blob))
            read_mmblob(mmf, &oid);
        else
            read_mmfile(mmf, ""/dev/null"");
}else
    if (read_mmfile(mmf, fname)){
        ret = -1;
    }
",,
implicit_predicate,merge-file.c,137,+,-,"if (ret)
    goto cleanup;
",,
implicit_predicate,merge-file.c,161,+,+,"to_stdout ? stdout : fopen(fpath, ""wb"")",14,"			FILE *f = to_stdout ? stdout : fopen(fpath, ""wb"");"
implicit_predicate,merge-index.c,40,+,-,"if (one_shot)
    err++;
else{
    if (!quiet)
        die(""merge program failed"");

    exit(1);
}
",,
implicit_predicate,merge-ll.c,228,-,+,,23,"			sq_quote_buf(&cmd, orig_name ? orig_name : """");"
implicit_predicate,merge-ll.c,230,-,+,,23,"			sq_quote_buf(&cmd, name1 ? name1 : """");"
implicit_predicate,merge-ll.c,232,-,+,,23,"			sq_quote_buf(&cmd, name2 ? name2 : """");"
implicit_predicate,merge-ort-wrappers.c,33,+,-,"if (unclean(opt, head))
    return -1;
",,
implicit_predicate,merge-ort-wrappers.c,57,+,-,"if (unclean(opt, head))
    return -1;
",,
implicit_predicate,merge-ort.c,647,+,+,reinitialize ? strmap_partial_clear : strmap_clear,3,		reinitialize ? strmap_partial_clear : strmap_clear;
implicit_predicate,merge-ort.c,649,+,+,reinitialize ? strintmap_partial_clear : strintmap_clear,3,		reinitialize ? strintmap_partial_clear : strintmap_clear;
implicit_predicate,merge-ort.c,651,+,+,reinitialize ? strset_partial_clear : strset_clear,3,		reinitialize ? strset_partial_clear : strset_clear;
implicit_predicate,merge-ort.c,796,-,+,,10,	dest = (opt->record_conflict_msgs_as_headers ? &tmp : &buf);
implicit_predicate,merge-ort.c,1000,+,+,resolved ? sizeof (struct merged_info) : sizeof (struct conflict_info),9,"			     resolved ? sizeof(struct merged_info) :
					sizeof(struct conflict_info));"
implicit_predicate,merge-ort.c,1005,+,-,"if (resolved){
    mi->result.mode = merged_version->mode;
    oidcpy(&mi->result.oid, &merged_version->oid);
    mi->is_null = !!is_null;
}else{
    int i;
    struct conflict_info* ci;
    ASSIGN_AND_VERIFY_CI(ci, mi);
    for (i = MERGE_BASE;i <= MERGE_SIDE2;i++){
        ci->pathnames[i] = fullpath;
        ci->stages[i].mode = names[i].mode;
        oidcpy(&ci->stages[i].oid, &names[i].oid);
    }
    ci->filemask = filemask;
    ci->dirmask = dirmask;
    ci->df_conflict = !!df_conflict;
    if (dirmask)
        mi->is_null = 1;
}
",,
implicit_predicate,merge-ort.c,1013,+,-,"ASSIGN_AND_VERIFY_CI(ci, mi);
",,
implicit_predicate,merge-ort.c,1022,+,-,"if (dirmask)
    mi->is_null = 1;
",,
implicit_predicate,merge-ort.c,1049,+,+,is_add ? side : 0,18,	int names_idx = is_add ? side : 0;
implicit_predicate,merge-ort.c,1051,+,-,"if (is_add){
    assert(match_mask == 0 || match_mask == 6);
    if (strset_contains(&renames->cached_target_names[side], pathname))
        return;
}else{
    unsigned content_relevant = (match_mask == 0);
    unsigned location_relevant = (dir_rename_mask == 0x07);
    assert(match_mask == 0 || match_mask == 3 || match_mask == 5);
    if (content_relevant)
        strset_remove(&renames->cached_irrelevant[side], pathname);

    if (content_relevant || location_relevant){
        strintmap_set(&renames->relevant_sources[side], pathname, content_relevant ? RELEVANT_CONTENT : RELEVANT_LOCATION);
    }
    if (strmap_contains(&renames->cached_pairs[side], pathname) || strset_contains(&renames->cached_irrelevant[side], pathname))
        return;
}
",,
implicit_predicate,merge-ort.c,1067,+,-,"if (content_relevant)
    strset_remove(&renames->cached_irrelevant[side], pathname);
",,
implicit_predicate,merge-ort.c,1085,+,+,content_relevant ? RELEVANT_CONTENT : RELEVANT_LOCATION,11,				      content_relevant ? RELEVANT_CONTENT : RELEVANT_LOCATION);
implicit_predicate,merge-ort.c,1100,+,+,is_add ? two : one,16,"	fill_filespec(is_add ? two : one,"
implicit_predicate,merge-ort.c,1160,+,-,"if (sides & 1)
    strintmap_set(&renames->dirs_removed[1], fullname, relevance);
",,
implicit_predicate,merge-ort.c,1163,+,-,"if (sides & 2)
    strintmap_set(&renames->dirs_removed[2], fullname, relevance);
",,
implicit_predicate,merge-ort.c,1276,+,-,"if (side1_matches_mbase)
    match_mask = (side2_matches_mbase ? 7 : 3);
else
    if (side2_matches_mbase)
        match_mask = 5;
    else
        if (sides_match)
            match_mask = 6;
",,
implicit_predicate,merge-ort.c,1277,+,+,side2_matches_mbase ? 7 : 3,17,		match_mask = (side2_matches_mbase ? 7 : 3);
implicit_predicate,merge-ort.c,1278,+,-,"if (side2_matches_mbase)
    match_mask = 5;
else
    if (sides_match)
        match_mask = 6;
",,
implicit_predicate,merge-ort.c,1280,+,-,"if (sides_match)
    match_mask = 6;
",,
implicit_predicate,merge-ort.c,1374,+,-,"if (dirmask){
    struct traverse_info newinfo;
    struct tree_desc t[3];
    void* buf[3] = {NULL, NULL, NULL};
    const char* original_dir_name;
    int i, ret, side;
    assert(!side1_matches_mbase || !side2_matches_mbase);
    side = side1_matches_mbase ? MERGE_SIDE2 : side2_matches_mbase ? MERGE_SIDE1 : MERGE_BASE;
    if (filemask == 0 && (dirmask == 2 || dirmask == 4)){
        ci->match_mask = (7 - dirmask);
        side = dirmask / 2;
    }
    if (renames->dir_rename_mask != 0x07 && side != MERGE_BASE && renames->deferred[side].trivial_merges_okay && !strset_contains(&renames->deferred[side].target_dirs, pi.string)){
        strintmap_set(&renames->deferred[side].possible_trivial_merges, pi.string, renames->dir_rename_mask);
        renames->dir_rename_mask = prev_dir_rename_mask;
        return mask;
    }
    ci->match_mask &= filemask;
    newinfo = *info;
    newinfo.prev = info;
    newinfo.name = p->path;
    newinfo.namelen = p->pathlen;
    newinfo.pathlen = st_add3(newinfo.pathlen, p->pathlen, 1);
    for (i = MERGE_BASE;i <= MERGE_SIDE2;i++){
        if (i == 1 && side1_matches_mbase)
            t[1] = t[0];
        else
            if (i == 2 && side2_matches_mbase)
                t[2] = t[0];
            else
                if (i == 2 && sides_match)
                    t[2] = t[1];
                else{
                    const struct object_id* oid = NULL;
                    if (dirmask & 1)
                        oid = &names[i].oid;

                    buf[i] = fill_tree_descriptor(opt->repo, t + i, oid);
                }

        dirmask >>= 1;
    }
    original_dir_name = opti->current_dir_name;
    opti->current_dir_name = pi.string;
    if (renames->dir_rename_mask == 0 || renames->dir_rename_mask == 0x07)
        ret = traverse_trees(NULL, 3, t, &newinfo);
    else
        ret = traverse_trees_wrapper(NULL, 3, t, &newinfo);

    opti->current_dir_name = original_dir_name;
    renames->dir_rename_mask = prev_dir_rename_mask;
    for (i = MERGE_BASE;i <= MERGE_SIDE2;i++)
        free(buf[i]);
    if (ret < 0)
        return -1;
}
",,
implicit_predicate,merge-ort.c,1387,+,+,side1_matches_mbase ? MERGE_SIDE2 : side2_matches_mbase ? MERGE_SIDE1 : MERGE_BASE,10,"		side = side1_matches_mbase ? MERGE_SIDE2 :
			side2_matches_mbase ? MERGE_SIDE1 : MERGE_BASE;"
implicit_predicate,merge-ort.c,1388,+,+,side2_matches_mbase ? MERGE_SIDE1 : MERGE_BASE,4,			side2_matches_mbase ? MERGE_SIDE1 : MERGE_BASE;
implicit_predicate,merge-ort.c,1434,+,-,"if (dirmask & 1)
    oid = &names[i].oid;
",,
implicit_predicate,merge-ort.c,1583,+,-,"if (dirmask & 1)
    oid = &ci->stages[i].oid;
",,
implicit_predicate,merge-ort.c,1622,+,-,"if (path_count_after){
    const int wanted_factor = 3;
    assert(renames->redo_after_renames == 0);
    if (path_count_after / path_count_before >= wanted_factor){
        renames->redo_after_renames = 1;
        renames->cached_pairs_valid_side = -1;
    }
}else
    if (renames->redo_after_renames == 2)
        renames->redo_after_renames = 0;
",,
implicit_predicate,merge-ort.c,1782,-,+,,17,"	oidcpy(result, opt->priv->call_depth ? o : a);"
implicit_predicate,merge-ort.c,1982,+,-,"if (mi->clean){
    int len = strlen(GITATTRIBUTES_FILE);
    ce = make_empty_cache_entry(attr_index, len);
    ce->ce_mode = create_ce_mode(mi->result.mode);
    ce->ce_flags = create_ce_flags(0);
    ce->ce_namelen = len;
    oidcpy(&ce->oid, &mi->result.oid);
    memcpy(ce->name, GITATTRIBUTES_FILE, len);
    add_index_entry(attr_index, ce, ADD_CACHE_OK_TO_ADD | ADD_CACHE_OK_TO_REPLACE);
    get_stream_filter(attr_index, GITATTRIBUTES_FILE, &ce->oid);
}else{
    int stage, len;
    struct conflict_info* ci;
    ASSIGN_AND_VERIFY_CI(ci, mi);
    for (stage = 0;stage < 3;stage++){
        unsigned stage_mask = (1 << stage);
        if (!(ci->filemask & stage_mask))
            continue;

        len = strlen(GITATTRIBUTES_FILE);
        ce = make_empty_cache_entry(attr_index, len);
        ce->ce_mode = create_ce_mode(ci->stages[stage].mode);
        ce->ce_flags = create_ce_flags(stage);
        ce->ce_namelen = len;
        oidcpy(&ce->oid, &ci->stages[stage].oid);
        memcpy(ce->name, GITATTRIBUTES_FILE, len);
        add_index_entry(attr_index, ce, ADD_CACHE_OK_TO_ADD | ADD_CACHE_OK_TO_REPLACE);
        get_stream_filter(attr_index, GITATTRIBUTES_FILE, &ce->oid);
    }
}
",,
implicit_predicate,merge-ort.c,1997,+,-,"ASSIGN_AND_VERIFY_CI(ci, mi);
",,
implicit_predicate,merge-ort.c,2171,+,+,two_way ? null_oid() : &o->oid,8,"					  two_way ? null_oid() : &o->oid,"
implicit_predicate,merge-ort.c,2185,+,-,"if (ret)
    return -1;
",,
implicit_predicate,merge-ort.c,2193,+,+,two_way ? null_oid() : &o->oid,6,"					two_way ? null_oid() : &o->oid,"
implicit_predicate,merge-ort.c,2276,+,-,"INITIALIZE_CI(ci, mi);
",,
implicit_predicate,merge-ort.c,2321,+,-,"if (c_info->reported_already){
    clean = 0;
}else
    if (path_in_way(&opt->priv->paths, new_path, 1 << side_index)){
        c_info->reported_already = 1;
        strbuf_add_separated_string_list(&collision_paths, "", "", &c_info->source_files);
        path_msg(opt, CONFLICT_DIR_RENAME_FILE_IN_WAY, 0, new_path, NULL, NULL, &c_info->source_files, _(""CONFLICT (implicit dir rename): Existing file/dir at %s in the way of implicit directory rename(s) putting the following path(s) there: %s.""), new_path, collision_paths.buf);
        clean = 0;
    }else
        if (c_info->source_files.nr > 1){
            c_info->reported_already = 1;
            strbuf_add_separated_string_list(&collision_paths, "", "", &c_info->source_files);
            path_msg(opt, CONFLICT_DIR_RENAME_COLLISION, 0, new_path, NULL, NULL, &c_info->source_files, _(""CONFLICT (implicit dir rename): Cannot map more than one path to %s; implicit directory renames tried to put these paths there: %s""), new_path, collision_paths.buf);
            clean = 0;
        }
",,
implicit_predicate,merge-ort.c,2642,+,-,"while (1){
    char* last_slash = strrchr(cur_path, '/');
    if (last_slash){
        parent_name = mem_pool_strndup(&opt->priv->pool, cur_path, last_slash - cur_path);
    }else{
        parent_name = opt->priv->toplevel_dir;
        break;
    }
    entry = strmap_get_entry(&opt->priv->paths, parent_name);
    if (entry){
        parent_name = entry->key;
        break;
    }
    string_list_append(&dirs_to_insert, parent_name);
    cur_path = parent_name;
}
",,
implicit_predicate,merge-ort.c,2708,+,-,"if (ci->dirmask & (1 << i))
    continue;
",,
implicit_predicate,merge-ort.c,2741,+,-,"if (new_ci->dirmask)
    new_ci->df_conflict = 1;
",,
implicit_predicate,merge-ort.c,2911,+,-,"if (was_binary_blob){
    oidcpy(&merged.oid, &side2->stages[2].oid);
    merged.mode = side2->stages[2].mode;
}
",,
implicit_predicate,merge-ort.c,2996,+,-,"if (source_deleted){
    if (target_index == 1){
        rename_branch = opt->branch1;
        delete_branch = opt->branch2;
    }else{
        rename_branch = opt->branch2;
        delete_branch = opt->branch1;
    }
}
",,
implicit_predicate,merge-ort.c,3077,+,-,"if (type_changed){
    memcpy(&oldinfo->stages[0].oid, null_oid(), sizeof (oldinfo->stages[0].oid));
    oldinfo->stages[0].mode = 0;
    oldinfo->filemask &= 0x06;
}else
    if (source_deleted){
        newinfo->path_conflict = 1;
        path_msg(opt, CONFLICT_RENAME_DELETE, 0, newpath, oldpath, NULL, NULL, _(""CONFLICT (rename/delete): %s renamed to %s in %s, but deleted in %s.""), oldpath, newpath, rename_branch, delete_branch);
    }else{
        memcpy(&newinfo->stages[other_source_index], &oldinfo->stages[other_source_index], sizeof (newinfo->stages[0]));
        newinfo->filemask |= (1 << other_source_index);
        newinfo->pathnames[other_source_index] = oldpath;
    }
",,
implicit_predicate,merge-ort.c,3084,+,-,"if (source_deleted){
    newinfo->path_conflict = 1;
    path_msg(opt, CONFLICT_RENAME_DELETE, 0, newpath, oldpath, NULL, NULL, _(""CONFLICT (rename/delete): %s renamed to %s in %s, but deleted in %s.""), oldpath, newpath, rename_branch, delete_branch);
}else{
    memcpy(&newinfo->stages[other_source_index], &oldinfo->stages[other_source_index], sizeof (newinfo->stages[0]));
    newinfo->filemask |= (1 << other_source_index);
    newinfo->pathnames[other_source_index] = oldpath;
}
",,
implicit_predicate,merge-ort.c,3204,-,+,,39,		pairs->queue[pairs->nr-1]->status = entry->value ? 'R' : 'D';
implicit_predicate,merge-ort.c,3219,+,-,"if (free_old_value)
    free(old_value);
else
    assert(!old_value);
",,
implicit_predicate,merge-ort.c,3410,+,-,"if (renames->needed_limit){
    renames->cached_pairs_valid_side = 0;
    renames->redo_after_renames = 0;
}
",,
implicit_predicate,merge-ort.c,3441,+,-,"if (need_dir_renames){
    get_provisional_directory_renames(opt, MERGE_SIDE1, &clean);
    get_provisional_directory_renames(opt, MERGE_SIDE2, &clean);
    handle_directory_level_conflicts(opt);
}
",,
implicit_predicate,merge-ort.c,3550,-,+,,7,	c1 = *one ? *one : '/';
implicit_predicate,merge-ort.c,3551,-,+,,7,	c2 = *two ? *two : '/';
implicit_predicate,merge-ort.c,3555,-,+,,10,		return (*one) ? 1 : -1;
implicit_predicate,merge-ort.c,3714,+,-,"if (mi->is_null)
    return;
",,
implicit_predicate,merge-ort.c,3916,+,-,"if (ci->dirmask){
    record_entry_for_tree(dir_metadata, path, &ci->merged);
    if (ci->filemask == 0)
        return 0;

    assert(ci->df_conflict);
}
",,
implicit_predicate,merge-ort.c,3940,+,-,"if (ci->filemask & (1 << i))
    continue;
",,
implicit_predicate,merge-ort.c,3986,+,-,"if (new_ci->filemask & (1 << i))
    continue;
",,
implicit_predicate,merge-ort.c,3999,+,+,(ci->dirmask & (1 << 1)) ? 2 : 1,19,		df_file_index = (ci->dirmask & (1 << 1)) ? 2 : 1;
implicit_predicate,merge-ort.c,4029,+,-,"if (ci->match_mask){
    ci->merged.clean = !ci->df_conflict && !ci->path_conflict;
    if (ci->match_mask == 6){
        ci->merged.result.mode = ci->stages[1].mode;
        oidcpy(&ci->merged.result.oid, &ci->stages[1].oid);
    }else{
        unsigned int othermask = 7 & ~ci->match_mask;
        int side = (othermask == 4) ? 2 : 1;
        ci->merged.result.mode = ci->stages[side].mode;
        ci->merged.is_null = !ci->merged.result.mode;
        if (ci->merged.is_null)
            ci->merged.clean = 1;

        oidcpy(&ci->merged.result.oid, &ci->stages[side].oid);
        assert(othermask == 2 || othermask == 4);
        assert(ci->merged.is_null == (ci->filemask == ci->match_mask));
    }
}else
    if (ci->filemask >= 6 && (S_IFMT & ci->stages[1].mode) != (S_IFMT & ci->stages[2].mode)){
        if (opt->priv->call_depth){
            ci->merged.clean = 0;
            oidcpy(&ci->merged.result.oid, &ci->stages[0].oid);
            ci->merged.result.mode = ci->stages[0].mode;
            ci->merged.is_null = (ci->merged.result.mode == 0);
        }else{
            unsigned o_mode = ci->stages[0].mode;
            unsigned a_mode = ci->stages[1].mode;
            unsigned b_mode = ci->stages[2].mode;
            struct conflict_info* new_ci;
            const char *a_path = NULL, *b_path = NULL;
            int rename_a = 0, rename_b = 0;
            new_ci = mem_pool_alloc(&opt->priv->pool, sizeof (*new_ci));
            if (S_ISREG(a_mode))
                rename_a = 1;
            else
                if (S_ISREG(b_mode))
                    rename_b = 1;
                else{
                    rename_a = 1;
                    rename_b = 1;
                }

            if (rename_a)
                a_path = unique_path(opt, path, opt->branch1);

            if (rename_b)
                b_path = unique_path(opt, path, opt->branch2);

            if (rename_a && rename_b){
                path_msg(opt, CONFLICT_DISTINCT_MODES, 0, path, a_path, b_path, NULL, _(""CONFLICT (distinct types): %s had different types on each side; renamed both of them so each can be recorded somewhere.""), path);
            }else{
                path_msg(opt, CONFLICT_DISTINCT_MODES, 0, path, rename_a ? a_path : b_path, NULL, NULL, _(""CONFLICT (distinct types): %s had different types on each side; renamed one of them so each can be recorded somewhere.""), path);
            }
            ci->merged.clean = 0;
            memcpy(new_ci, ci, sizeof (*new_ci));
            new_ci->merged.result.mode = ci->stages[2].mode;
            oidcpy(&new_ci->merged.result.oid, &ci->stages[2].oid);
            new_ci->stages[1].mode = 0;
            oidcpy(&new_ci->stages[1].oid, null_oid());
            new_ci->filemask = 5;
            if ((S_IFMT & b_mode) != (S_IFMT & o_mode)){
                new_ci->stages[0].mode = 0;
                oidcpy(&new_ci->stages[0].oid, null_oid());
                new_ci->filemask = 4;
            }
            ci->merged.result.mode = ci->stages[1].mode;
            oidcpy(&ci->merged.result.oid, &ci->stages[1].oid);
            ci->stages[2].mode = 0;
            oidcpy(&ci->stages[2].oid, null_oid());
            ci->filemask = 3;
            if ((S_IFMT & a_mode) != (S_IFMT & o_mode)){
                ci->stages[0].mode = 0;
                oidcpy(&ci->stages[0].oid, null_oid());
                ci->filemask = 2;
            }
            assert(rename_a || rename_b);
            if (rename_a)
                strmap_put(&opt->priv->paths, a_path, ci);

            if (!rename_b)
                b_path = path;

            strmap_put(&opt->priv->paths, b_path, new_ci);
            if (rename_a && rename_b)
                strmap_remove(&opt->priv->paths, path, 0);

            strmap_put(&opt->priv->conflicted, b_path, new_ci);
            record_entry_for_tree(dir_metadata, b_path, &new_ci->merged);
            if (a_path)
                path = a_path;
        }
    }else
        if (ci->filemask >= 6){
            struct version_info merged_file;
            int clean_merge;
            struct version_info* o = &ci->stages[0];
            struct version_info* a = &ci->stages[1];
            struct version_info* b = &ci->stages[2];
            clean_merge = handle_content_merge(opt, path, o, a, b, ci->pathnames, opt->priv->call_depth * 2, &merged_file);
            if (clean_merge < 0)
                return -1;

            ci->merged.clean = clean_merge && !ci->df_conflict && !ci->path_conflict;
            ci->merged.result.mode = merged_file.mode;
            ci->merged.is_null = (merged_file.mode == 0);
            oidcpy(&ci->merged.result.oid, &merged_file.oid);
            if (clean_merge && ci->df_conflict){
                assert(df_file_index == 1 || df_file_index == 2);
                ci->filemask = 1 << df_file_index;
                ci->stages[df_file_index].mode = merged_file.mode;
                oidcpy(&ci->stages[df_file_index].oid, &merged_file.oid);
            }
            if (!clean_merge){
                const char* reason = _(""content"");
                if (ci->filemask == 6)
                    reason = _(""add/add"");

                if (S_ISGITLINK(merged_file.mode))
                    reason = _(""submodule"");

                path_msg(opt, CONFLICT_CONTENTS, 0, path, NULL, NULL, NULL, _(""CONFLICT (%s): Merge conflict in %s""), reason, path);
            }
        }else
            if (ci->filemask == 3 || ci->filemask == 5){
                const char *modify_branch, *delete_branch;
                int side = (ci->filemask == 5) ? 2 : 1;
                int index = opt->priv->call_depth ? 0 : side;
                ci->merged.result.mode = ci->stages[index].mode;
                oidcpy(&ci->merged.result.oid, &ci->stages[index].oid);
                ci->merged.clean = 0;
                modify_branch = (side == 1) ? opt->branch1 : opt->branch2;
                delete_branch = (side == 1) ? opt->branch2 : opt->branch1;
                if (opt->renormalize && blob_unchanged(opt, &ci->stages[0], &ci->stages[side], path)){
                    if (!ci->path_conflict){
                        ci->merged.is_null = 1;
                        ci->merged.clean = 1;
                        ci->df_conflict = 0;
                    }else{
                    }
                }else
                    if (ci->path_conflict && oideq(&ci->stages[0].oid, &ci->stages[side].oid)){
                    }else{
                        path_msg(opt, CONFLICT_MODIFY_DELETE, 0, path, NULL, NULL, NULL, _(""CONFLICT (modify/delete): %s deleted in %s and modified in %s.  Version %s of %s left in tree.""), path, delete_branch, modify_branch, modify_branch, path);
                    }
            }else
                if (ci->filemask == 2 || ci->filemask == 4){
                    int side = (ci->filemask == 4) ? 2 : 1;
                    ci->merged.result.mode = ci->stages[side].mode;
                    oidcpy(&ci->merged.result.oid, &ci->stages[side].oid);
                    ci->merged.clean = !ci->df_conflict && !ci->path_conflict;
                }else
                    if (ci->filemask == 1){
                        ci->merged.is_null = 1;
                        ci->merged.result.mode = 0;
                        oidcpy(&ci->merged.result.oid, null_oid());
                        assert(!ci->df_conflict);
                        ci->merged.clean = !ci->path_conflict;
                    }
",,
implicit_predicate,merge-ort.c,4042,+,-,"if (ci->merged.is_null)
    ci->merged.clean = 1;
",,
implicit_predicate,merge-ort.c,4081,+,-,"if (rename_a)
    a_path = unique_path(opt, path, opt->branch1);
",,
implicit_predicate,merge-ort.c,4083,+,-,"if (rename_b)
    b_path = unique_path(opt, path, opt->branch2);
",,
implicit_predicate,merge-ort.c,4096,+,+,rename_a ? a_path : b_path,13,"					 path, rename_a ? a_path : b_path,"
implicit_predicate,merge-ort.c,4134,+,-,"if (rename_a)
    strmap_put(&opt->priv->paths, a_path, ci);
",,
implicit_predicate,merge-ort.c,4199,-,+,,15,		int index = opt->priv->call_depth ? 0 : side;
implicit_predicate,merge-ort.c,4286,+,-,"if (ci->merged.clean)
    continue;
",,
implicit_predicate,merge-ort.c,4381,+,-,"if (mi->clean)
    record_entry_for_tree(&dir_metadata, path, mi);
else{
    struct conflict_info* ci = (struct conflict_info*)mi;
    if (process_entry(opt, path, ci, &dir_metadata) < 0){
        ret = -1;
        goto cleanup;
    }
    ;
}
",,
implicit_predicate,merge-ort.c,4669,+,-,"if (detailed){
    printf(""%lu"", (unsigned long )info->paths.nr);
    putchar('\0');
    for (int n = 0;n < info->paths.nr;n++){
        fputs(info->paths.v[n], stdout);
        putchar('\0');
    }
    fputs(type_short_descriptions[info->type], stdout);
    putchar('\0');
}
",,
implicit_predicate,merge-ort.c,4681,+,-,"if (detailed)
    putchar('\0');
",,
implicit_predicate,merge-ort.c,4747,+,-,"if (record_conflicted_index_entries(opt)){
    opt->priv = NULL;
    result->clean = -1;
    merge_finalize(opt, result);
    trace2_region_leave(""merge"", ""record_conflicted"", opt->repo);
    return;
}
",,
implicit_predicate,merge-ort.c,4773,+,-,"if (display_update_msgs)
    merge_display_update_messages(opt, 0, result);
",,
implicit_predicate,merge-recursive.c,21,-,+,,17,	return xstrdup(name ? name : branch);
implicit_predicate,merge-recursive.c,63,-,+,,28,"	return fspathcmp(a->path, key ? key : b->path);"
implicit_predicate,merge-recursive.c,362,+,-,"if (len)
    strbuf_addf(&opt->obuf, ""%.*s\n"", len, title);
",,
implicit_predicate,merge-recursive.c,388,+,-,"if (refresh){
    struct cache_entry* nce;
    nce = refresh_cache_entry(istate, ce, CE_MATCH_REFRESH | CE_MATCH_IGNORE_MISSING);
    if (!nce)
        return err(opt, _(""add_cacheinfo failed to refresh for path '%s'; merge aborting.""), path);

    if (nce != ce)
        ret = add_index_entry(istate, nce, options);
}
",,
implicit_predicate,merge-recursive.c,579,+,-,"if (cmp)
    return cmp;
",,
implicit_predicate,merge-recursive.c,672,+,-,"if (clear)
    if (remove_file_from_index(opt->repo->index, path))
        return -1;
",,
implicit_predicate,merge-recursive.c,676,+,-,"if (add_cacheinfo(opt, o, path, 1, 0, options))
    return -1;
",,
implicit_predicate,merge-recursive.c,679,+,-,"if (add_cacheinfo(opt, a, path, 2, 0, options))
    return -1;
",,
implicit_predicate,merge-recursive.c,682,+,-,"if (add_cacheinfo(opt, b, path, 3, 0, options))
    return -1;
",,
implicit_predicate,merge-recursive.c,707,+,-,"if (update_cache){
    if (remove_file_from_index(opt->repo->index, path))
        return -1;
}
",,
implicit_predicate,merge-recursive.c,711,+,-,"if (update_working_directory){
    if (ignore_case){
        struct cache_entry* ce;
        ce = index_file_exists(opt->repo->index, path, strlen(path), ignore_case);
        if (ce && ce_stage(ce) == 0 && strcmp(path, ce->name))
            return 0;
    }
    if (remove_path(path))
        return -1;
}
",,
implicit_predicate,merge-recursive.c,908,+,-,"if (status){
    if (status == SCLD_EXISTS)
        return err(opt, msg, path, _("": perhaps a D/F conflict?""));

    return err(opt, msg, path, """");
}
",,
implicit_predicate,merge-recursive.c,919,+,-,"if (would_lose_untracked(opt, path))
    return err(opt, _(""refusing to lose untracked file at '%s'""), path);
",,
implicit_predicate,merge-recursive.c,944,+,-,"if (update_wd){
    enum object_type type;
    void* buf;
    unsigned long size;
    if (S_ISGITLINK(contents->mode)){
        update_wd = 0;
        goto update_index;
    }
    buf = repo_read_object_file(the_repository, &contents->oid, &type, &size);
    if (!buf){
        ret = err(opt, _(""cannot read object %s '%s'""), oid_to_hex(&contents->oid), path);
        goto free_buf;
    }
    if (type != OBJ_BLOB){
        ret = err(opt, _(""blob expected for %s '%s'""), oid_to_hex(&contents->oid), path);
        goto free_buf;
    }
    if (S_ISREG(contents->mode)){
        struct strbuf strbuf = STRBUF_INIT;
        if (convert_to_working_tree(opt->repo->index, path, buf, size, &strbuf, NULL)){
            free(buf);
            size = strbuf.len;
            buf = strbuf_detach(&strbuf, NULL);
        }
    }
    if (make_room_for_path(opt, path) < 0){
        update_wd = 0;
        goto free_buf;
    }
    if (S_ISREG(contents->mode) || (!has_symlinks && S_ISLNK(contents->mode))){
        int fd;
        int mode = (contents->mode & 0100 ? 0777 : 0666);
        fd = open(path, O_WRONLY | O_TRUNC | O_CREAT, mode);
        if (fd < 0){
            ret = err(opt, _(""failed to open '%s': %s""), path, strerror(errno));
            goto free_buf;
        }
        write_in_full(fd, buf, size);
        close(fd);
    }else
        if (S_ISLNK(contents->mode)){
            char* lnk = xmemdupz(buf, size);
            safe_create_leading_directories_const(path);
            unlink(path);
            if (symlink(lnk, path))
                ret = err(opt, _(""failed to symlink '%s': %s""), path, strerror(errno));

            free(lnk);
        }else
            ret = err(opt, _(""do not know what to do with %06o %s '%s'""), contents->mode, oid_to_hex(&contents->oid), path);

    free_buf:
    free(buf);
}
",,
implicit_predicate,merge-recursive.c,988,-,+,,16,			int mode = (contents->mode & 0100 ? 0777 : 0666);
implicit_predicate,merge-recursive.c,1150,+,-,"if (ret)
    add_object_array(o, NULL, &merges);
",,
implicit_predicate,merge-recursive.c,1273,+,-,"if (ret2){
    oidcpy(result, b);
    if (show(opt, 3)){
        output(opt, 3, _(""Fast-forwarding submodule %s to the following commit:""), path);
        repo_output_commit_title(opt, &subrepo, commit_b);
    }else
        if (show(opt, 2))
            output(opt, 2, _(""Fast-forwarding submodule %s""), path);
        else;


    ret = 1;
    goto cleanup;
}
",,
implicit_predicate,merge-recursive.c,1275,+,-,"if (show(opt, 3)){
    output(opt, 3, _(""Fast-forwarding submodule %s to the following commit:""), path);
    repo_output_commit_title(opt, &subrepo, commit_b);
}else
    if (show(opt, 2))
        output(opt, 2, _(""Fast-forwarding submodule %s""), path);
    else;

",,
implicit_predicate,merge-recursive.c,1278,+,-,"if (show(opt, 2))
    output(opt, 2, _(""Fast-forwarding submodule %s""), path);
else;

",,
implicit_predicate,merge-recursive.c,1292,+,-,"if (ret2){
    oidcpy(result, a);
    if (show(opt, 3)){
        output(opt, 3, _(""Fast-forwarding submodule %s to the following commit:""), path);
        repo_output_commit_title(opt, &subrepo, commit_a);
    }else
        if (show(opt, 2))
            output(opt, 2, _(""Fast-forwarding submodule %s""), path);
        else;


    ret = 1;
    goto cleanup;
}
",,
implicit_predicate,merge-recursive.c,1294,+,-,"if (show(opt, 3)){
    output(opt, 3, _(""Fast-forwarding submodule %s to the following commit:""), path);
    repo_output_commit_title(opt, &subrepo, commit_a);
}else
    if (show(opt, 2))
        output(opt, 2, _(""Fast-forwarding submodule %s""), path);
    else;

",,
implicit_predicate,merge-recursive.c,1297,+,-,"if (show(opt, 2))
    output(opt, 2, _(""Fast-forwarding submodule %s""), path);
else;

",,
implicit_predicate,merge-recursive.c,1434,+,-,"if (ret)
    return ret;
",,
implicit_predicate,merge-recursive.c,1465,+,-,"if (result->merge)
    output(opt, 2, _(""Auto-merging %s""), filename);
",,
implicit_predicate,merge-recursive.c,1495,+,-,"if (mark_conflicted){
    if (update_file(opt, 0, dest, file_path))
        return -1;

    if (file_path != dest->path)
        free(file_path);

    if (update_stages(opt, dest->path, NULL, ren->branch == opt->branch1 ? dest : NULL, ren->branch == opt->branch1 ? NULL : dest))
        return -1;

    return 0;
}else{
    if (update_file(opt, 1, dest, dest->path))
        return -1;

    return 1;
}
",,
implicit_predicate,merge-recursive.c,1501,+,-,"if (update_file(opt, 0, dest, file_path))
    return -1;
",,
implicit_predicate,merge-recursive.c,1610,-,+,,6,"				 opt->priv->call_depth ? orig->path : dest->path,"
implicit_predicate,merge-recursive.c,1611,-,+,,6,"				 opt->priv->call_depth ? NULL : orig->path,"
implicit_predicate,merge-recursive.c,1664,+,-,"if (was_dirty(opt, collide_path)){
    output(opt, 1, _(""Refusing to lose dirty file at %s""), collide_path);
    update_path = alt_path = unique_path(opt, collide_path, ""merged"");
}else
    if (would_lose_untracked(opt, collide_path)){
        output(opt, 1, _(""Refusing to lose untracked file at %s, even though it's in the way.""), collide_path);
        update_path = alt_path = unique_path(opt, collide_path, ""merged"");
    }else{
        remove_file(opt, 0, collide_path, 0);
    }
",,
implicit_predicate,merge-recursive.c,1668,+,-,"if (would_lose_untracked(opt, collide_path)){
    output(opt, 1, _(""Refusing to lose untracked file at %s, even though it's in the way.""), collide_path);
    update_path = alt_path = unique_path(opt, collide_path, ""merged"");
}else{
    remove_file(opt, 0, collide_path, 0);
}
",,
implicit_predicate,merge-recursive.c,1702,+,-,"if (update_file(opt, mfi.clean, &mfi.blob, update_path))
    return -1;
",,
implicit_predicate,merge-recursive.c,1767,+,-,"if (would_lose_untracked(opt, path)){
    new_path = unique_path(opt, path, branch1);
    output(opt, 1, _(""Refusing to lose untracked file at %s; adding as %s instead""), path, new_path);
}
",,
implicit_predicate,merge-recursive.c,1801,-,+,,9,"	       opt->priv->call_depth ? _("" (left unresolved)"") : """");"
implicit_predicate,merge-recursive.c,1820,+,-,"if (is_valid(add)){
    add->path = mfi.blob.path = a->path;
    if (handle_file_collision(opt, a->path, NULL, NULL, ci->ren1->branch, ci->ren2->branch, &mfi.blob, add) < 0)
        return -1;
}else{
    char* new_path = find_path_for_conflict(opt, a->path, ci->ren1->branch, ci->ren2->branch);
    if (update_file(opt, 0, &mfi.blob, new_path ? new_path : a->path))
        return -1;

    free(new_path);
    if (!opt->priv->call_depth && update_stages(opt, a->path, NULL, a, NULL))
        return -1;
}
",,
implicit_predicate,merge-recursive.c,1833,-,+,,5,				new_path ? new_path : a->path))
implicit_predicate,merge-recursive.c,1854,+,-,"if (is_valid(add)){
    add->path = mfi.blob.path = b->path;
    if (handle_file_collision(opt, b->path, NULL, NULL, ci->ren1->branch, ci->ren2->branch, add, &mfi.blob) < 0)
        return -1;
}else{
    char* new_path = find_path_for_conflict(opt, b->path, ci->ren2->branch, ci->ren1->branch);
    if (update_file(opt, 0, &mfi.blob, new_path ? new_path : b->path))
        return -1;

    free(new_path);
    if (!opt->priv->call_depth && update_stages(opt, b->path, NULL, NULL, b))
        return -1;
}
",,
implicit_predicate,merge-recursive.c,1867,-,+,,5,				new_path ? new_path : b->path))
implicit_predicate,merge-recursive.c,1992,+,-,"if (entry->non_unique_new_dir)
    return NULL;
",,
implicit_predicate,merge-recursive.c,2182,+,-,"if (collision_ent->reported_already){
    clean = 0;
}else
    if (tree_has_path(opt->repo, tree, new_path)){
        collision_ent->reported_already = 1;
        strbuf_add_separated_string_list(&collision_paths, "", "", &collision_ent->source_files);
        output(opt, 1, _(""CONFLICT (implicit dir rename): Existing file/dir at %s in the way of implicit directory rename(s) putting the following path(s) there: %s.""), new_path, collision_paths.buf);
        clean = 0;
    }else
        if (collision_ent->source_files.nr > 1){
            collision_ent->reported_already = 1;
            strbuf_add_separated_string_list(&collision_paths, "", "", &collision_ent->source_files);
            output(opt, 1, _(""CONFLICT (implicit dir rename): Cannot map more than one path to %s; implicit directory renames tried to put these paths there: %s""), new_path, collision_paths.buf);
            clean = 0;
        }
",,
implicit_predicate,merge-recursive.c,2802,+,-,"if (ren1->processed)
    continue;
",,
implicit_predicate,merge-recursive.c,2899,+,-,"if (renamed_to_self){
    setup_rename_conflict_info(RENAME_NORMAL, opt, ren1, NULL);
}else
    if (oideq(&src_other.oid, null_oid())){
        setup_rename_conflict_info(RENAME_DELETE, opt, ren1, NULL);
    }else
        if ((dst_other.mode == ren1->pair->two->mode) && oideq(&dst_other.oid, &ren1->pair->two->oid)){
            if (update_file_flags(opt, ren1->pair->two, ren1_dst, 1, 0))
                clean_merge = -1;
        }else
            if (!oideq(&dst_other.oid, null_oid())){
                setup_rename_conflict_info(RENAME_ADD, opt, ren1, NULL);
            }else
                try_merge = 1;
",,
implicit_predicate,merge-recursive.c,2936,+,-,"if (try_merge){
    struct diff_filespec *o, *a, *b;
    src_other.path = (char*)ren1_src;
    o = ren1->pair->one;
    if (a_renames == renames1){
        a = ren1->pair->two;
        b = &src_other;
    }else{
        b = ren1->pair->two;
        a = &src_other;
    }
    update_entry(ren1->dst_entry, o, a, b);
    setup_rename_conflict_info(RENAME_NORMAL, opt, ren1, NULL);
}
",,
implicit_predicate,merge-recursive.c,3131,+,-,"if (is_valid(a)){
    modify_branch = opt->branch1;
    delete_branch = opt->branch2;
    changed = a;
}else{
    modify_branch = opt->branch2;
    delete_branch = opt->branch1;
    changed = b;
}
",,
implicit_predicate,merge-recursive.c,3185,+,-,"if (add_cacheinfo(opt, &mfi->blob, path, 0, (!opt->priv->call_depth && !is_dirty), 0))
    return -1;
",,
implicit_predicate,merge-recursive.c,3210,+,-,"if (update_stages(opt, path, o, a, b))
    return -1;
",,
implicit_predicate,merge-recursive.c,3220,+,-,"if (update_stages(opt, path, o, a, b))
    return -1;
",,
implicit_predicate,merge-recursive.c,3226,+,+,file_from_stage2 ? &mfi->blob : NULL,9,"						  file_from_stage2 ? &mfi->blob : NULL,"
implicit_predicate,merge-recursive.c,3227,+,+,file_from_stage2 ? NULL : &mfi->blob,9,						  file_from_stage2 ? NULL : &mfi->blob))
implicit_predicate,merge-recursive.c,3233,+,-,"if (is_dirty){
    output(opt, 1, _(""Refusing to lose dirty file at %s""), path);
}
",,
implicit_predicate,merge-recursive.c,3238,+,-,"if (update_file(opt, 0, &mfi->blob, new_path)){
    free(new_path);
    return -1;
}
",,
implicit_predicate,merge-recursive.c,3244,+,-,"if (update_file(opt, mfi->clean, &mfi->blob, path))
    return -1;
",,
implicit_predicate,merge-recursive.c,3267,+,-,"if (update_stages(opt, path, &mfi.blob, &mfi.blob, &mfi.blob))
    return -1;
",,
implicit_predicate,merge-recursive.c,3284,+,-,"if (is_add){
    output(opt, clean ? 2 : 1, msg, ren->pair->one->path, ren->branch, other_branch, ren->pair->two->path);
    return;
}
",,
implicit_predicate,merge-recursive.c,3285,+,+,clean ? 2 : 1,15,"		output(opt, clean ? 2 : 1, msg,"
implicit_predicate,merge-recursive.c,3290,+,+,clean ? 2 : 1,14,"	output(opt, clean ? 2 : 1, msg,"
implicit_predicate,merge-recursive.c,3394,+,-,"if (handle_rename_delete(opt, ci))
    clean_merge = -1;
",,
implicit_predicate,merge-recursive.c,3407,+,-,"if (handle_rename_rename_1to2(opt, ci))
    clean_merge = -1;
",,
implicit_predicate,merge-recursive.c,3440,+,-,"if (a_valid)
    output(opt, 2, _(""Removing %s""), path);
",,
implicit_predicate,merge-recursive.c,3447,+,-,"if (handle_modify_delete(opt, path, o, a, b))
    clean_merge = -1;
",,
implicit_predicate,merge-recursive.c,3460,+,-,"if (a_valid){
    add_branch = opt->branch1;
    other_branch = opt->branch2;
    contents = a;
    conf = _(""file/directory"");
}else{
    add_branch = opt->branch2;
    other_branch = opt->branch1;
    contents = b;
    conf = _(""directory/file"");
}
",,
implicit_predicate,merge-recursive.c,3479,+,-,"if (update_file(opt, 0, contents, new_path))
    clean_merge = -1;
else
    if (opt->priv->call_depth)
        remove_file_from_index(opt->repo->index, path);
",,
implicit_predicate,merge-recursive.c,3487,+,-,"if (update_file_flags(opt, contents, path, 1, !a_valid))
    clean_merge = -1;
",,
implicit_predicate,merge-recursive.c,3640,+,-,"if (show(opt, 4)){
    output(opt, 4, _(""Merging:""));
    output_commit_title(opt, h1);
    output_commit_title(opt, h2);
}
",,
implicit_predicate,merge-recursive.c,3653,+,-,"if (show(opt, 5)){
    unsigned cnt = commit_list_count(merge_bases);
    output(opt, 5, Q_(""found %u common ancestor:"", ""found %u common ancestors:"", cnt), cnt);
    for (iter = merge_bases;iter;iter = iter->next)
        output_commit_title(opt, iter->item);
}
",,
implicit_predicate,merge-recursive.c,3794,+,-,"if (show(opt, 2))
    diff_warn_rename_limit(""merge.renamelimit"", opt->priv->needed_rename_limit, 0);
",,
implicit_predicate,merge-recursive.c,3810,+,-,"if (merge_start(opt, head))
    return -1;
",,
implicit_predicate,merge-recursive.c,3898,+,+,clean ? 0 : 1,9,	return clean ? 0 : 1;
implicit_predicate,merge-recursive.c,3921,+,+,boolval ? MERGE_DIRECTORY_RENAMES_TRUE : MERGE_DIRECTORY_RENAMES_NONE,36,"			opt->detect_directory_renames = boolval ?
				MERGE_DIRECTORY_RENAMES_TRUE :
				MERGE_DIRECTORY_RENAMES_NONE;"
implicit_predicate,merge-tree.c,493,+,-,"if (o->use_stdin)
    printf(""%d%c"", result.clean, line_termination);
",,
implicit_predicate,merge-tree.c,516,+,-,"if (show_messages){
    putchar(line_termination);
    merge_display_update_messages(&opt, line_termination == '\0', &result);
}
",,
implicit_predicate,merge-tree.c,521,+,-,"if (o->use_stdin)
    putchar(line_termination);
",,
implicit_predicate,merge-tree.c,587,+,-,"if (o.use_stdin){
    struct strbuf buf = STRBUF_INIT;
    if (o.mode == MODE_TRIVIAL)
        die(_(""--trivial-merge is incompatible with all other options""));

    if (merge_base)
        die(_(""options '%s' and '%s' cannot be used together""), ""--merge-base"", ""--stdin"");

    line_termination = '\0';
    while (strbuf_getline_lf(&buf, stdin) != EOF){
        struct strbuf** split;
        int result;
        const char* input_merge_base = NULL;
        split = strbuf_split(&buf, ' ');
        if (!split[0] || !split[1])
            die(_(""malformed input line: '%s'.""), buf.buf);

        strbuf_rtrim(split[0]);
        strbuf_rtrim(split[1]);
        if (!strcmp(split[1]->buf, ""--"")){
            input_merge_base = split[0]->buf;
        }
        if (input_merge_base && split[2] && split[3] && !split[4]){
            strbuf_rtrim(split[2]);
            strbuf_rtrim(split[3]);
            result = real_merge(&o, input_merge_base, split[2]->buf, split[3]->buf, prefix);
        }else
            if (!input_merge_base && !split[2]){
                result = real_merge(&o, NULL, split[0]->buf, split[1]->buf, prefix);
            }else{
                die(_(""malformed input line: '%s'.""), buf.buf);
            }

        if (result < 0)
            die(_(""merging cannot continue; got unclean result of %d""), result);

        strbuf_list_free(split);
    }
    strbuf_release(&buf);
    return 0;
}
",,
implicit_predicate,merge.c,17,-,+,,20,	return oid_to_hex(commit ? &commit->object.oid : the_hash_algo->empty_tree);
implicit_predicate,merge.c,121,+,-,"if (unset)
    strbuf_setlen(buf, 0);
else
    if (arg){
        strbuf_addf(buf, ""%s%s"", buf->len ? ""\n\n"" : """", arg);
        have_message = 1;
    }else
        return error(_(""switch `m' requires a value""));
",,
implicit_predicate,merge.c,124,-,+,,28,"		strbuf_addf(buf, ""%s%s"", buf->len ? ""\n\n"" : """", arg);"
implicit_predicate,merge.c,140,+,-,"if (unset)
    BUG(""-F cannot be negated"");
",,
implicit_predicate,merge.c,383,+,-,"if (squash)
    puts(_(""Already up to date. (nothing to squash)""));
else
    puts(_(""Already up to date.""));
",,
implicit_predicate,merge.c,445,+,-,"if (squash){
    squash_message(head_commit, remoteheads);
}else{
    if (verbosity >= 0 && !merge_msg.len)
        printf(_(""No merge message -- not updating HEAD\n""));
    else{
        refs_update_ref(get_main_ref_store(the_repository), reflog_message.buf, ""HEAD"", new_head, head, 0, UPDATE_REFS_DIE_ON_ERR);
        run_auto_maintenance(verbosity < 0);
    }
}
",,
implicit_predicate,merge.c,476,+,+,"squash ? ""1"" : ""0""",28,"	run_hooks_l(""post-merge"", squash ? ""1"" : ""0"", NULL);"
implicit_predicate,merge.c,526,+,-,"if (len)
    early = 1;
else{
    early = 0;
    ptr = strrchr(remote, '~');
    if (ptr){
        int seen_nonzero = 0;
        len++;
        while (*++ptr && isdigit(*ptr)){
            seen_nonzero |= (*ptr != '0');
            len++;
        }
        if (*ptr)
            len = 0;
        else
            if (seen_nonzero)
                early = 1;
            else
                if (len == 1)
                    early = 1;
    }
}
",,
implicit_predicate,merge.c,541,+,-,"if (seen_nonzero)
    early = 1;
else
    if (len == 1)
        early = 1;
",,
implicit_predicate,merge.c,547,+,-,"if (len){
    struct strbuf truname = STRBUF_INIT;
    strbuf_addf(&truname, ""refs/heads/%s"", remote);
    strbuf_setlen(&truname, truname.len - len);
    if (refs_ref_exists(get_main_ref_store(the_repository), truname.buf)){
        strbuf_addf(msg, ""%s\t\tbranch '%s'%s of .\n"", oid_to_hex(&remote_head->object.oid), truname.buf + 11, (early ? "" (early part)"" : """"));
        strbuf_release(&truname);
        goto cleanup;
    }
    strbuf_release(&truname);
}
",,
implicit_predicate,merge.c,556,+,+,"early ? "" (early part)"" : """"",10,"				    (early ? "" (early part)"" : """"));"
implicit_predicate,merge.c,627,+,+,boolval ? FF_ALLOW : FF_NO,19,			fast_forward = boolval ? FF_ALLOW : FF_NO;
implicit_predicate,merge.c,636,-,+,,17,"		sign_commit = git_config_bool(k, v) ? """" : NULL;"
implicit_predicate,merge.c,646,+,-,"if (status)
    return status;
",,
implicit_predicate,merge.c,752,+,+,clean ? 0 : 1,10,		return clean ? 0 : 1;
implicit_predicate,merge.c,793,+,-,"if (all_strategy[i].attr & attr)
    append_strategy(&all_strategy[i]);
",,
implicit_predicate,merge.c,846,+,-,"if (invoked_hook)
    discard_index(the_repository->index);
",,
implicit_predicate,merge.c,851,+,-,"if (squash)
    BUG(""the control must not reach here under --squash"");
",,
implicit_predicate,merge.c,868,+,-,"if (signoff)
    append_signoff(&msg, ignored_log_message_bytes(msg.buf, msg.len), 0);
",,
implicit_predicate,merge.c,1066,+,-,"if (have_message)
    return 0;
",,
implicit_predicate,merge.c,1318,+,-,"if (abort_current_merge){
    int nargc = 2;
    const char* nargv[] = {""reset"", ""--merge"", NULL};
    char stash_oid_hex[GIT_MAX_HEXSZ + 1];
    struct object_id stash_oid = {0};
    if (orig_argc != 2)
        usage_msg_opt(_(""--abort expects no arguments""), builtin_merge_usage, builtin_merge_options);

    if (!file_exists(git_path_merge_head(the_repository)))
        die(_(""There is no merge to abort (MERGE_HEAD missing).""));

    if (!refs_read_ref(get_main_ref_store(the_repository), ""MERGE_AUTOSTASH"", &stash_oid))
        refs_delete_ref(get_main_ref_store(the_repository), """", ""MERGE_AUTOSTASH"", &stash_oid, REF_NO_DEREF);

    ret = cmd_reset(nargc, nargv, prefix);
    if (!is_null_oid(&stash_oid)){
        oid_to_hex_r(stash_oid_hex, &stash_oid);
        apply_autostash_oid(stash_oid_hex);
    }
    goto done;
}
",,
implicit_predicate,merge.c,1347,+,-,"if (quit_current_merge){
    if (orig_argc != 2)
        usage_msg_opt(_(""--quit expects no arguments""), builtin_merge_usage, builtin_merge_options);

    remove_merge_branch_state(the_repository);
    goto done;
}
",,
implicit_predicate,merge.c,1357,+,-,"if (continue_current_merge){
    int nargc = 1;
    const char* nargv[] = {""commit"", NULL};
    if (orig_argc != 2)
        usage_msg_opt(_(""--continue expects no arguments""), builtin_merge_usage, builtin_merge_options);

    if (!file_exists(git_path_merge_head(the_repository)))
        die(_(""There is no merge in progress (MERGE_HEAD missing).""));

    ret = cmd_commit(nargc, nargv, prefix);
    goto done;
}
",,
implicit_predicate,merge.c,1404,+,-,"if (squash){
    if (fast_forward == FF_NO)
        die(_(""options '%s' and '%s' cannot be used together""), ""--squash"", ""--no-ff."");

    if (option_commit > 0)
        die(_(""options '%s' and '%s' cannot be used together""), ""--squash"", ""--commit."");

    option_commit = 0;
}
",,
implicit_predicate,merge.c,1421,+,-,"if (default_to_upstream)
    argc = setup_with_upstream(&argv);
else
    die(_(""No commit specified and merge.defaultToUpstream not set.""));
",,
implicit_predicate,merge.c,1440,+,-,"if (squash)
    die(_(""Squash commit into empty head not supported yet""));
",,
implicit_predicate,merge.c,1452,+,-,"if (verify_signatures)
    verify_merge_signature(remoteheads->item, verbosity, check_trust_level);
",,
implicit_predicate,merge.c,1477,+,-,"if (verify_signatures){
    for (p = remoteheads;p;p = p->next){
        verify_merge_signature(p->item, verbosity, check_trust_level);
    }
}
",,
implicit_predicate,merge.c,1516,+,-,"if (use_strategies[i]->attr & NO_FAST_FORWARD)
    fast_forward = FF_NO;
",,
implicit_predicate,merge.c,1518,+,-,"if (use_strategies[i]->attr & NO_TRIVIAL)
    allow_trivial = 0;
",,
implicit_predicate,merge.c,1564,+,+,"have_message ? ""Fast-forward (no commit created; -m option ignored)"" : ""Fast-forward""",21,"		const char *msg = have_message ?
			""Fast-forward (no commit created; -m option ignored)"" :
			""Fast-forward"";"
implicit_predicate,merge.c,1582,+,-,"if (autostash)
    create_autostash_ref(the_repository, ""MERGE_AUTOSTASH"");
",,
implicit_predicate,merge.c,1665,+,-,"if (up_to_date){
    finish_up_to_date();
    goto done;
}
",,
implicit_predicate,merge.c,1674,+,-,"if (autostash)
    create_autostash_ref(the_repository, ""MERGE_AUTOSTASH"");
",,
implicit_predicate,merge.c,1692,+,-,"if (save_state(&stash))
    oidclr(&stash);
",,
implicit_predicate,merge.c,1697,+,-,"if (i){
    printf(_(""Rewinding the tree to pristine...\n""));
    restore_state(&head_commit->object.oid, &stash);
}
",,
implicit_predicate,merge.c,1774,+,-,"if (squash){
    finish(head_commit, remoteheads, NULL, NULL);
    git_test_write_commit_graph_or_die();
}else
    write_merge_state(remoteheads);
",,
implicit_predicate,merge.c,1781,+,-,"if (merge_was_ok)
    fprintf(stderr, _(""Automatic merge went well; stopped before committing as requested\n""));
else
    ret = suggest_conflicts();
",,
implicit_predicate,merge.c,1786,+,-,"if (autostash)
    printf(_(""When finished, apply stashed changes with `git stash pop`\n""));
",,
implicit_predicate,merged.c,70,+,-,"if (err)
    return err;
",,
implicit_predicate,merged.c,79,+,-,"if (err)
    return err;
",,
implicit_predicate,merged.c,107,+,-,"if (empty)
    return iterator_next(&mi->subiters[mi->advance_index].iter, rec);
",,
implicit_predicate,merged.c,119,+,-,"if (empty)
    return iterator_next(&mi->subiters[mi->advance_index].iter, rec);
",,
implicit_predicate,merged.c,131,+,-,"if (empty)
    return 1;
",,
implicit_predicate,merged.c,154,+,-,"while (1){
    int err = merged_iter_next_entry(mi, rec);
    if (err)
        return err;

    if (mi->suppress_deletions && reftable_record_is_deletion(rec))
        continue;

    return 0;
}
",,
implicit_predicate,merged.c,156,+,-,"if (err)
    return err;
",,
implicit_predicate,merged.c,171,+,-,"while (1){
    int err = merged_iter_next_entry(mi, rec);
    if (err)
        return err;

    if (mi->suppress_deletions && reftable_record_is_deletion(rec))
        continue;

    return 0;
}
",,
implicit_predicate,merged.c,173,+,-,"if (err)
    return err;
",,
implicit_predicate,midx-write.c,168,+,-,"if (cmp)
    return cmp;
",,
implicit_predicate,midx-write.c,312,-,+,,24,	uint32_t start_pack = m ? m->num_packs : 0;
implicit_predicate,midx-write.c,412,+,-,"if (pack->expired)
    continue;
",,
implicit_predicate,midx-write.c,731,+,-,"if (preferred)
    object->flags |= NEEDS_BITMAP;
",,
implicit_predicate,midx-write.c,930,-,+,,14,	ctx.alloc = ctx.m ? ctx.m->num_packs : 16;
implicit_predicate,midx-write.c,1092,+,-,"if (missing_drops){
    result = 1;
    goto cleanup;
}
",,
implicit_predicate,midx-write.c,1167,+,-,"if (ctx.large_offsets_needed)
    add_chunk(cf, MIDX_CHUNKID_LARGEOFFSETS, st_mult(ctx.num_large_offsets, MIDX_CHUNK_LARGE_OFFSET_WIDTH), write_midx_large_offsets);
",,
implicit_predicate,midx-write.c,1488,+,-,"if (delta_base_offset)
    strvec_push(&cmd.args, ""--delta-base-offset"");
",,
implicit_predicate,midx-write.c,1490,+,-,"if (use_delta_islands)
    strvec_push(&cmd.args, ""--delta-islands"");
",,
implicit_predicate,midx.c,647,+,-,"midx_display_sparse_progress(progress, i + 1);
",,
implicit_predicate,midx.c,705,+,-,"midx_display_sparse_progress(progress, i + 1);
",,
implicit_predicate,mingw.c,223,+,-,"while (1){
    int answer;
    fprintf(stderr, ""%s (y/n) "", question);
    if ((answer = read_yes_no_answer()) >= 0)
        return answer;

    fprintf(stderr, ""Sorry, I did not understand your answer. Please type 'y' or 'n'\n"");
}
",,
implicit_predicate,mingw.c,296,+,-,"for (i = 0;wbuf[i];i++)
    if (wbuf[i] == '\\')
        wbuf[i] = '/';
",,
implicit_predicate,mingw.c,447,+,-,"if (set)
    modified = original | FILE_ATTRIBUTE_HIDDEN;
else
    modified = original & ~FILE_ATTRIBUTE_HIDDEN;
",,
implicit_predicate,mingw.c,562,+,-,create ? EINVAL : ENOENT,,
implicit_predicate,mingw.c,614,+,-,"while (1){
    ch = fgetc(stream);
    if (ch != EOF || GetLastError() != ERROR_OPERATION_ABORTED)
        break;

    mingw_raise (SIGINT);
}
",,
implicit_predicate,mingw.c,636,+,-,create ? EINVAL : ENOENT,,
implicit_predicate,mingw.c,665,+,-,create ? EINVAL : ENOENT,,
implicit_predicate,mingw.c,843,+,-,"if (follow){
    char buffer[MAXIMUM_REPARSE_DATA_BUFFER_SIZE];
    buf->st_size = readlink(file_name, buffer, MAXIMUM_REPARSE_DATA_BUFFER_SIZE);
}else{
    buf->st_mode = S_IFLNK;
}
",,
implicit_predicate,mingw.c,1353,+,-,"if (dirlen)
    prog = lookup_prog(path, dirlen, cmd, isexe, exe_only);
",,
implicit_predicate,mingw.c,1579,+,-,is_msys2_sh(cmd ? cmd : *argv) ? quote_arg_msys2 : quote_arg_msvc,,
implicit_predicate,mingw.c,1650,+,-,"if (prepend_cmd){
    char* quoted = (char*)quote_arg(cmd);
    strbuf_addstr(&args, quoted);
    if (quoted != cmd)
        free(quoted);
}
",,
implicit_predicate,mingw.c,1712,+,-,*wcmd ? wcmd : NULL,,
implicit_predicate,mingw.c,1765,+,-,*wcmd ? wcmd : NULL,,
implicit_predicate,mingw.c,2034,+,-,"if (initialized)
    return;
",,
implicit_predicate,mingw.c,2264,+,-,"if (initialized)
    return p;
",,
implicit_predicate,mingw.c,2308,+,-,"if (one_shot)
    break;
",,
implicit_predicate,mingw.c,3012,+,-,fd ? OPEN_ALWAYS : OPEN_EXISTING,,
implicit_predicate,mingw.h,453,+,-,"for (;*path;path++)
    if (*path == '\\')
        *path = '/';
",,
implicit_predicate,mktree.c,132,+,-,"if (allow_missing){
    ;
}else{
    die(""entry '%s' object %s is unavailable"", path, oid_to_hex(&oid));
}
",,
implicit_predicate,mktree.c,171,+,+,nul_term_line ? strbuf_getline_nul : strbuf_getline_lf,15,	getline_fn = nul_term_line ? strbuf_getline_nul : strbuf_getline_lf;
implicit_predicate,mktree.c,174,+,-,"while (1){
    if (getline_fn(&sb, stdin) == EOF){
        got_eof = 1;
        break;
    }
    if (sb.buf[0] == '\0'){
        if (is_batch_mode)
            break;

        die(""input format error: (blank line only valid in batch mode)"");
    }
    mktree_line(sb.buf, nul_term_line, allow_missing);
}
",,
implicit_predicate,mktree.c,181,+,-,"if (is_batch_mode)
    break;
",,
implicit_predicate,multi-pack-index.c,65,+,-,"if (unset)
    *value = xstrdup(get_object_directory());
else
    *value = real_pathdup(arg, 1);
",,
implicit_predicate,multi-pack-index.c,152,+,-,"if (argc)
    usage_with_options(builtin_multi_pack_index_write_usage, options);
",,
implicit_predicate,multi-pack-index.c,158,+,-,"if (opts.stdin_packs){
    struct string_list packs = STRING_LIST_INIT_DUP;
    int ret;
    read_packs_from_stdin(&packs);
    ret = write_midx_file_only(opts.object_dir, &packs, opts.preferred_pack, opts.refs_snapshot, opts.flags);
    string_list_clear(&packs, 0);
    return ret;
}
",,
implicit_predicate,multi-pack-index.c,195,+,-,"if (argc)
    usage_with_options(builtin_multi_pack_index_verify_usage, options);
",,
implicit_predicate,multi-pack-index.c,222,+,-,"if (argc)
    usage_with_options(builtin_multi_pack_index_expire_usage, options);
",,
implicit_predicate,multi-pack-index.c,253,+,-,"if (argc)
    usage_with_options(builtin_multi_pack_index_repack_usage, options);
",,
implicit_predicate,mv.c,47,-,+,,18,	int prefixlen = prefix ? strlen(prefix) : 0;
implicit_predicate,mv.c,60,+,-,"if (flags & DUP_BASENAME){
    result[i] = xstrdup(basename(it));
    free(it);
}else{
    result[i] = it;
}
",,
implicit_predicate,mv.c,258,+,-,"if (show_only)
    printf(_(""Checking rename of '%s' to '%s'\n""), src, dst);
",,
implicit_predicate,mv.c,365,+,-,"if (force){
    if (S_ISREG(st.st_mode) || S_ISLNK(st.st_mode)){
        if (verbose)
            warning(_(""overwriting '%s'""), dst);

        bad = NULL;
    }else
        bad = _(""Cannot overwrite"");
}
",,
implicit_predicate,mv.c,371,+,-,"if (verbose)
    warning(_(""overwriting '%s'""), dst);
",,
implicit_predicate,mv.c,392,+,-,"if (force){
    if (verbose)
        warning(_(""overwriting '%s'""), dst);

    bad = NULL;
}else{
    goto act_on_entry;
}
",,
implicit_predicate,mv.c,393,+,-,"if (verbose)
    warning(_(""overwriting '%s'""), dst);
",,
implicit_predicate,mv.c,417,+,-,"if (skip_sparse)
    goto remove_entry;
",,
implicit_predicate,mv.c,454,+,-,"if (force)
    state.force = 1;
",,
implicit_predicate,mv.c,458,+,-,"if (show_only)
    continue;
",,
implicit_predicate,mv.c,463,+,-,"if (ignore_errors)
    continue;
",,
implicit_predicate,mv.c,476,+,-,"if (mode & (WORKING_DIRECTORY | SKIP_WORKTREE_DIR))
    continue;
",,
implicit_predicate,mv.c,561,+,-,"if (gitmodules_modified)
    stage_updated_gitmodules(the_repository->index);
",,
implicit_predicate,name-hash.c,39,-,+,,4,"			name ? name : e2->name, e1->namelen);"
implicit_predicate,name-hash.c,144,-,+,,9,	return remove ? !(ce1 == ce2) : 0;
implicit_predicate,name-hash.c,417,+,-,"if (processed){
    k += processed;
    strbuf_setlen(prefix, input_prefix_len);
    continue;
}
",,
implicit_predicate,name-hash.c,547,+,-,"if (err)
    die(_(""unable to create lazy_dir thread: %s""), strerror(err));
",,
implicit_predicate,name-hash.c,569,+,-,"if (err)
    die(_(""unable to create lazy_name thread: %s""), strerror(err));
",,
implicit_predicate,name-hash.c,575,+,-,"if (err)
    die(_(""unable to join lazy_name thread: %s""), strerror(err));
",,
implicit_predicate,name-hash.c,595,+,-,"if (lookup_lazy_params(istate)){
    hashmap_disable_item_counting(&istate->dir_hash);
    threaded_lazy_init_name_hash(istate);
    hashmap_enable_item_counting(&istate->dir_hash);
}else{
    int nr;
    for (nr = 0;nr < istate->cache_nr;nr++)
        hash_index_entry(istate, istate->cache[nr]);
}
",,
implicit_predicate,name-hash.c,657,+,-,"while (len1){
    unsigned char c1 = *name1++;
    unsigned char c2 = *name2++;
    len1--;
    if (c1 != c2){
        c1 = toupper(c1);
        c2 = toupper(c2);
        if (c1 != c2)
            return 0;
    }
}
",,
implicit_predicate,name-hash.c,740,+,-,"if (same_name(ce, name, namelen, icase))
    return ce;
",,
implicit_predicate,name-rev.c,100,+,+,is_valid_rev_name(name) ? name : NULL,9,	return is_valid_rev_name(name) ? name : NULL;
implicit_predicate,name-rev.c,186,+,-,"if (commit_is_before_cutoff(start_commit))
    return;
",,
implicit_predicate,name-rev.c,193,+,-,"if (deref)
    start_name->tip_name = mem_pool_strfmt(string_pool, ""%s^0"", tip_name);
else
    start_name->tip_name = mem_pool_strdup(string_pool, tip_name);
",,
implicit_predicate,name-rev.c,217,+,-,"if (commit_is_before_cutoff(parent))
    continue;
",,
implicit_predicate,name-rev.c,298,+,-,"if (shorten_unambiguous)
    short_refname = refs_shorten_unambiguous_ref(get_main_ref_store(the_repository), refname, 0);
else
    if (skip_prefix(refname, ""refs/heads/"", &refname));

    else
        skip_prefix(refname, ""refs/"", &refname);
",,
implicit_predicate,name-rev.c,308,-,+,,42,"	tip_table.table[tip_table.nr].refname = short_refname ?
		short_refname : xstrdup(refname);"
implicit_predicate,name-rev.c,331,+,-,"if (cmp)
    return cmp;
",,
implicit_predicate,name-rev.c,493,-,+,,17,"		printf(""%s "", caller_name ? caller_name : oid_to_hex(oid));"
implicit_predicate,name-rev.c,497,+,-,"if (allow_undefined)
    printf(""undefined\n"");
else
    if (always)
        printf(""%s\n"", repo_find_unique_abbrev(the_repository, oid, DEFAULT_ABBREV));
    else
        die(""cannot describe '%s'"", oid_to_hex(oid));
",,
implicit_predicate,name-rev.c,499,+,-,"if (always)
    printf(""%s\n"", repo_find_unique_abbrev(the_repository, oid, DEFAULT_ABBREV));
else
    die(""cannot describe '%s'"", oid_to_hex(oid));
",,
implicit_predicate,name-rev.c,521,+,-,"for (p_start = p;*p;p++){
    if (!ishex(*p))
        counter = 0;
    else
        if (++counter == hexsz && !ishex(*(p+1))){
            struct object_id oid;
            const char* name = NULL;
            char c = *(p + 1);
            int p_len = p - p_start + 1;
            counter = 0;
            *(p + 1) = 0;
            if (!repo_get_oid(the_repository, p - (hexsz - 1), &oid)){
                struct object* o = lookup_object(the_repository, &oid);
                if (o)
                    name = get_rev_name(o, &buf);
            }
            *(p + 1) = c;
            if (!name)
                continue;

            if (data->name_only)
                printf(""%.*s%s"", p_len - hexsz, p_start, name);
            else
                printf(""%.*s (%s)"", p_len, p_start, name);

            p_start = p + 1;
        }
}
",,
implicit_predicate,name-rev.c,546,+,-,"if (data->name_only)
    printf(""%.*s%s"", p_len - hexsz, p_start, name);
else
    printf(""%.*s (%s)"", p_len, p_start, name);
",,
implicit_predicate,name-rev.c,595,+,-,"if (transform_stdin){
    warning(""--stdin is deprecated. Please use --annotate-stdin instead, which is functionally equivalent.\nThis option will be removed in a future release."");
    annotate_stdin = 1;
}
",,
implicit_predicate,name-rev.c,609,+,-,"for (;argc;argc--, argv++){
    struct object_id oid;
    struct object* object;
    struct commit* commit;
    if (repo_get_oid(the_repository, *argv, &oid)){
        fprintf(stderr, ""Could not get sha1 for %s. Skipping.\n"", *argv);
        continue;
    }
    commit = NULL;
    object = parse_object(the_repository, &oid);
    if (object){
        struct object* peeled = deref_tag(the_repository, object, *argv, 0);
        if (peeled && peeled->type == OBJ_COMMIT)
            commit = (struct commit*)peeled;
    }
    if (!object){
        fprintf(stderr, ""Could not get object for %s. Skipping.\n"", *argv);
        continue;
    }
    if (commit)
        set_commit_cutoff(commit);

    if (peel_tag){
        if (!commit){
            fprintf(stderr, ""Could not get commit for %s. Skipping.\n"", *argv);
            continue;
        }
        object = (struct object*)commit;
    }
    add_object_array(object, *argv, &revs);
}
",,
implicit_predicate,name-rev.c,638,+,-,"if (peel_tag){
    if (!commit){
        fprintf(stderr, ""Could not get commit for %s. Skipping.\n"", *argv);
        continue;
    }
    object = (struct object*)commit;
}
",,
implicit_predicate,name-rev.c,654,+,-,"if (annotate_stdin){
    struct strbuf sb = STRBUF_INIT;
    while (strbuf_getline(&sb, stdin) != EOF){
        strbuf_addch(&sb, '\n');
        name_rev_line(sb.buf, &data);
    }
    strbuf_release(&sb);
}else
    if (all){
        int i, max;
        max = get_max_object_index();
        for (i = 0;i < max;i++){
            struct object* obj = get_indexed_object(i);
            if (!obj || obj->type != OBJ_COMMIT)
                continue;

            show_name(obj, NULL, always, allow_undefined, data.name_only);
        }
    }else{
        int i;
        for (i = 0;i < revs.nr;i++)
            show_name(revs.objects[i].item, revs.objects[i].name, always, allow_undefined, data.name_only);
    }
",,
implicit_predicate,name-rev.c,662,+,-,"if (all){
    int i, max;
    max = get_max_object_index();
    for (i = 0;i < max;i++){
        struct object* obj = get_indexed_object(i);
        if (!obj || obj->type != OBJ_COMMIT)
            continue;

        show_name(obj, NULL, always, allow_undefined, data.name_only);
    }
}else{
    int i;
    for (i = 0;i < revs.nr;i++)
        show_name(revs.objects[i].item, revs.objects[i].name, always, allow_undefined, data.name_only);
}
",,
implicit_predicate,notes-merge.c,155,+,-,"if (verify_notes_filepair(p, &obj)){
    trace_printf(""\t\tCannot merge entry '%s' (%c): %.7s -> %.7s. Skipping!\n"", p->one->path, p->status, oid_to_hex(&p->one->oid), oid_to_hex(&p->two->oid));
    continue;
}
",,
implicit_predicate,notes-merge.c,163,+,-,"if (occupied){
    assert(oideq(&mp->obj, &obj));
    if (is_null_oid(&p->one->oid)){
        assert(is_null_oid(&mp->remote));
        oidcpy(&mp->remote, &p->two->oid);
    }else
        if (is_null_oid(&p->two->oid)){
            assert(is_null_oid(&mp->base));
            oidcpy(&mp->base, &p->one->oid);
        }else
            assert(!""Invalid existing change recorded"");
}else{
    oidcpy(&mp->obj, &obj);
    oidcpy(&mp->base, &p->one->oid);
    oidcpy(&mp->local, &uninitialized);
    oidcpy(&mp->remote, &p->two->oid);
    len++;
}
",,
implicit_predicate,notes-merge.c,215,+,-,"if (verify_notes_filepair(p, &obj)){
    trace_printf(""\t\tCannot merge entry '%s' (%c): %.7s -> %.7s. Skipping!\n"", p->one->path, p->status, oid_to_hex(&p->one->oid), oid_to_hex(&p->two->oid));
    continue;
}
",,
implicit_predicate,notes-merge.c,383,-,+,,21,"	const char *lref = o->local_ref ? o->local_ref : ""local version"";"
implicit_predicate,notes-merge.c,384,-,+,,21,"	const char *rref = o->remote_ref ? o->remote_ref : ""remote version"";"
implicit_predicate,notes-merge.c,539,-,+,,10,"		printf(t->dirty ?
		       ""Merge result: %i unmerged notes and a dirty notes tree\n"" :
		       ""Merge result: %i unmerged notes and a clean notes tree\n"","
implicit_predicate,notes-merge.c,544,+,+,conflicts ? -1 : 1,9,	return conflicts ? -1 : 1;
implicit_predicate,notes.c,157,+,-,"if (size)
    write_or_die(fd, buf, size);
",,
implicit_predicate,notes.c,204,+,-,"if (d->given)
    write_or_die(fd, d->buf.buf, d->buf.len);
else
    if (old_note)
        copy_obj_to_fd(fd, old_note);
",,
implicit_predicate,notes.c,225,+,-,"if (d->stripspace)
    strbuf_stripspace(&d->buf, comment_line_str);
",,
implicit_predicate,notes.c,319,+,-,"if (ret)
    return ret;
",,
implicit_predicate,notes.c,352,+,-,"if (unset)
    *(const char**)opt->value = NULL;
else
    *(const char**)opt->value = arg ? arg : ""\n"";
",,
implicit_predicate,notes.c,355,-,+,,32,"		*(const char **)opt->value = arg ? arg : ""\n"";"
implicit_predicate,notes.c,397,+,-,"if (err){
    error(_(""failed to copy notes from '%s' to '%s'""), split[0]->buf, split[1]->buf);
    ret = 1;
}
",,
implicit_predicate,notes.c,424,-,+,,8,	ref = (flags & NOTES_INIT_WRITABLE) ? t->update_ref : t->ref;
implicit_predicate,notes.c,445,+,-,"if (argc)
    argc = parse_options(argc, argv, prefix, options, git_notes_list_usage, 0);
",,
implicit_predicate,notes.c,455,+,-,"if (argc){
    if (repo_get_oid(the_repository, argv[0], &object))
        die(_(""failed to resolve '%s' as a valid ref.""), argv[0]);

    note = get_note(t, &object);
    if (note){
        puts(oid_to_hex(note));
        retval = 0;
    }else
        retval = error(_(""no note found for object %s.""), oid_to_hex(&object));
}else
    retval = for_each_note(t, 0, list_each_note, NULL);
",,
implicit_predicate,notes.c,531,+,-,"if (d.given){
    free_note_data(&d);
    return error(_(""Cannot add notes. Found existing notes for object %s. Use '-f' to overwrite existing notes""), oid_to_hex(&object));
}
",,
implicit_predicate,notes.c,547,+,-,"while (fanout){
    path[i++] = hex_hash[j++];
    path[i++] = hex_hash[j++];
    path[i++] = '/';
    fanout--;
}
",,
implicit_predicate,notes.c,593,+,-,"if (argc){
    error(_(""too many arguments""));
    usage_with_options(git_notes_copy_usage, options);
}else{
    return notes_copy_from_stdin(force, rewrite_cmd);
}
",,
implicit_predicate,notes.c,626,+,-,"if (ret)
    return ret;
",,
implicit_predicate,notes.c,677,+,-,"if (ret)
    return ret;
",,
implicit_predicate,notes.c,680,+,-,"if (ret)
    return ret;
",,
implicit_predicate,notes.c,684,+,+,edit ? git_notes_edit_usage : git_notes_append_usage,10,	usage = edit ? git_notes_edit_usage : git_notes_append_usage;
implicit_predicate,notes.c,708,+,-,"if (ret)
    return ret;
",,
implicit_predicate,notes.c,721,+,-,"if (size)
    strbuf_add(&buf, prev_buf, size);
",,
implicit_predicate,notes.c,738,-,+,,23,	struct non_note *n = p ? p->next : *d->nn_list;
implicit_predicate,notes.c,746,+,-,"if (ret)
    return ret;
",,
implicit_predicate,notes.c,769,+,+,"argc ? argv[0] : ""HEAD""",15,"	object_ref = argc ? argv[0] : ""HEAD"";"
implicit_predicate,notes.c,853,-,+,,4,"			is_null_oid(&parent_oid) ? NULL : &parent_oid,"
implicit_predicate,notes.c,910,+,-,"if (string_list_add_note_lines(&sort_uniq_list, cur_oid))
    goto out;
",,
implicit_predicate,notes.c,912,+,-,"if (string_list_add_note_lines(&sort_uniq_list, new_oid))
    goto out;
",,
implicit_predicate,notes.c,925,+,-,"if (do_abort)
    return merge_abort(&o);
",,
implicit_predicate,notes.c,927,+,-,"if (do_commit)
    return merge_commit(&o);
",,
implicit_predicate,notes.c,1008,+,-,"if (status)
    fprintf(stderr, _(""Object %s has no note\n""), name);
else
    fprintf(stderr, _(""Removing note for object %s\n""), name);
",,
implicit_predicate,notes.c,1012,+,+,(flag & IGNORE_MISSING) ? 0 : status,9,	return (flag & IGNORE_MISSING) ? 0 : status;
implicit_predicate,notes.c,1025,-,+,,18,	t->update_ref = (flags & NOTES_INIT_WRITABLE) ? t->ref : NULL;
implicit_predicate,notes.c,1043,+,-,"if (from_stdin){
    struct strbuf sb = STRBUF_INIT;
    while (strbuf_getwholeline(&sb, stdin, '\n') != EOF){
        strbuf_rtrim(&sb);
        retval |= remove_one_note(t, sb.buf, flag);
    }
    strbuf_release(&sb);
}
",,
implicit_predicate,notes.c,1071,+,-,"if (argc){
    error(_(""too many arguments""));
    usage_with_options(git_notes_prune_usage, options);
}
",,
implicit_predicate,notes.c,1078,+,+,verbose ? NOTES_PRUNE_VERBOSE : 0,18,"	prune_notes(t, (verbose ? NOTES_PRUNE_VERBOSE : 0) |"
implicit_predicate,notes.c,1079,+,+,show_only ? NOTES_PRUNE_VERBOSE | NOTES_PRUNE_DRYRUN : 0,4,		(show_only ? NOTES_PRUNE_VERBOSE|NOTES_PRUNE_DRYRUN : 0) );
implicit_predicate,notes.c,1093,+,-,"if (argc){
    error(_(""too many arguments""));
    usage_with_options(git_notes_get_ref_usage, options);
}
",,
implicit_predicate,notes.c,1126,+,-,"if (argc){
    error(_(""unknown subcommand: `%s'""), argv[0]);
    usage_with_options(git_notes_usage, options);
}
",,
implicit_predicate,notes.c,1167,-,+,,9,	return found ? &found->val_oid : NULL;
implicit_predicate,object-file-convert.c,22,-,+,,3,		src->algo ? &hash_algos[src->algo] : repo->hash_algo;
implicit_predicate,object-file-convert.c,271,+,-,"if (gentle){
    strbuf_release(outbuf);
    return ret;
}
",,
implicit_predicate,object-file.c,668,+,-,"if (found){
    rollback_lock_file(&lock);
}else{
    fprintf_or_die(out, ""%s\n"", reference);
    if (commit_lock_file(&lock))
        die_errno(_(""unable to move new alternates file into place""));

    if (the_repository->objects->loaded_alternates)
        link_alt_odb_entries(the_repository, reference, '\n', NULL, 0);
}
",,
implicit_predicate,object-file.c,799,+,-,"if (seen_error){
    FREE_AND_NULL(ref_git);
}
",,
implicit_predicate,object-file.c,933,+,-,"if (r)
    break;
",,
implicit_predicate,object-file.c,998,+,-,"if (check_and_freshen_odb(odb, oid, freshen))
    return 1;
",,
implicit_predicate,object-file.c,1090,-,+,,3,		oid->algo ? &hash_algos[oid->algo] : r->hash_algo;
implicit_predicate,object-file.c,1462,+,+,"quick_has_loose(r, oid) ? 0 : -1",11,"			return quick_has_loose(r, oid) ? 0 : -1;"
implicit_predicate,object-file.c,1489,+,+,allow_unknown ? &hdrbuf : NULL,9,				    allow_unknown ? &hdrbuf : NULL)) {
implicit_predicate,object-file.c,1491,-,+,,26,"		if (parse_loose_header(hdrbuf.len ? hdrbuf.buf : hdr, oi) < 0)"
implicit_predicate,object-file.c,1535,+,-,"if (obj_read_use_lock)
    return;
",,
implicit_predicate,object-file.c,1592,+,-,"while (1){
    if (find_pack_entry(r, real, &e))
        break;

    if (!loose_object_info(r, real, oi, flags))
        return 0;

    if (!(flags & OBJECT_INFO_QUICK)){
        reprepare_packed_git(r);
        if (find_pack_entry(r, real, &e))
            break;
    }
    if (r == the_repository && register_all_submodule_odb_as_alternates())
        continue;

    if (fetch_if_missing && repo_has_promisor_remote(r) && !already_retried && !(flags & OBJECT_INFO_SKIP_FETCH_OBJECT)){
        promisor_remote_get_direct(r, real, 1);
        already_retried = 1;
        continue;
    }
    if (flags & OBJECT_INFO_DIE_IF_CORRUPT){
        const struct packed_git* p;
        if ((flags & OBJECT_INFO_LOOKUP_REPLACE) && !oideq(real, oid))
            die(_(""replacement %s not found for %s""), oid_to_hex(real), oid_to_hex(oid));

        if ((p = has_packed_and_bad(r, real)))
            die(_(""packed object %s (stored in %s) is corrupt""), oid_to_hex(real), p->pack_name);
    }
    return -1;
}
",,
implicit_predicate,object-file.c,1673,+,-,"if (do_die)
    die(_(""missing mapping of %s to %s""), oid_to_hex(input_oid), the_hash_algo->name);
",,
implicit_predicate,object-file.c,1697,+,-,"if (ret)
    return -1;
",,
implicit_predicate,object-file.c,1734,+,-,"if (do_die)
    die(_(""missing mapping of %s to %s""), oid_to_hex(&delta_base_oid), input_algo->name);
",,
implicit_predicate,object-file.c,1813,+,-,"if (oid_object_info_extended(r, oid, &oi, flags))
    return NULL;
",,
implicit_predicate,object-file.c,1831,+,-,"while (1){
    int ref_length = -1;
    const char* ref_type = NULL;
    buffer = repo_read_object_file(r, &actual_oid, &type, &isize);
    if (!buffer)
        return NULL;

    if (type == required_type){
        *size = isize;
        if (actual_oid_return)
            oidcpy(actual_oid_return, &actual_oid);

        return buffer;
    }else
        if (type == OBJ_COMMIT)
            ref_type = ""tree "";
        else
            if (type == OBJ_TAG)
                ref_type = ""object "";
            else{
                free(buffer);
                return NULL;
            }

    ref_length = strlen(ref_type);
    if (ref_length + the_hash_algo->hexsz > isize || memcmp(buffer, ref_type, ref_length) || get_oid_hex((char*)buffer + ref_length, &actual_oid)){
        free(buffer);
        return NULL;
    }
    free(buffer);
}
",,
implicit_predicate,object-file.c,1933,+,-,"if (ret){
    if (ret != EEXIST){
        return error_errno(_(""unable to write file %s""), filename);
    }
}
",,
implicit_predicate,object-file.c,2098,-,+,,28,"	ret = git_deflate(stream, flush ? Z_FINISH : 0);"
implicit_predicate,object-file.c,2300,+,-,"if (dirlen){
    struct strbuf dir = STRBUF_INIT;
    strbuf_add(&dir, filename.buf, dirlen);
    if (mkdir_in_gitdir(dir.buf) && errno != EEXIST){
        err = error_errno(_(""unable to create directory %s""), dir.buf);
        strbuf_release(&dir);
        goto cleanup;
    }
    strbuf_release(&dir);
}
",,
implicit_predicate,object-file.c,2420,+,-,"if (has_loose_object(oid))
    return 0;
",,
implicit_predicate,object-file.c,2446,+,+,quick ? OBJECT_INFO_QUICK : 0,4,		(quick ? OBJECT_INFO_QUICK : 0);
implicit_predicate,object-file.c,2517,+,-,"if (write_object)
    ret = write_object_file(buf, size, type, oid);
else
    hash_object_file(the_hash_algo, buf, size, type, oid);
",,
implicit_predicate,object-file.c,2521,+,-,"if (re_allocated)
    free(buf);
",,
implicit_predicate,object-file.c,2748,+,-,"if (r)
    break;
",,
implicit_predicate,object-file.c,2756,+,-,"if (r)
    break;
",,
implicit_predicate,object-file.c,2783,+,-,"if (r)
    break;
",,
implicit_predicate,object-file.c,2816,+,-,"if (r)
    return r;
",,
implicit_predicate,object-name.c,52,+,-,"if (ds->always_call_fn){
    ds->ambiguous = ds->fn(ds->repo, current, ds->cb_data) ? 1 : 0;
    return;
}
",,
implicit_predicate,object-name.c,53,+,+,"ds->fn(ds->repo, current, ds->cb_data) ? 1 : 0",19,"		ds->ambiguous = ds->fn(ds->repo, current, ds->cb_data) ? 1 : 0;"
implicit_predicate,object-name.c,86,+,-,"if (ds->fn(ds->repo, current, ds->cb_data)){
    ds->candidate_ok = 0;
    ds->ambiguous = 1;
}
",,
implicit_predicate,object-name.c,105,+,+,ds->ambiguous ? CB_BREAK : CB_CONTINUE,9,	return ds->ambiguous ? CB_BREAK : CB_CONTINUE;
implicit_predicate,object-name.c,126,+,-,"if (len)
    if ((*a ^ *b) & 0xf0)
        return 0;
",,
implicit_predicate,object-name.c,127,+,-,"if ((*a ^ *b) & 0xf0)
    return 0;
",,
implicit_predicate,object-name.c,210,+,-,"if (ds->ambiguous)
    return SHORT_NAME_AMBIGUOUS;
",,
implicit_predicate,object-name.c,369,-,+,,21,	ds->bin_pfx.algo = algo ? hash_algo_by_ptr(algo) : GIT_HASH_UNKNOWN;
implicit_predicate,object-name.c,661,+,-,"while (val >>= 1)
    r++;
",,
implicit_predicate,object-name.c,811,-,+,,3,		oid->algo ? &hash_algos[oid->algo] : r->hash_algo;
implicit_predicate,object-name.c,887,+,-,"if (slash)
    break;
",,
implicit_predicate,object-name.c,990,+,-,"if (nth_prior){
    struct strbuf buf = STRBUF_INIT;
    int detached;
    if (interpret_nth_prior_checkout(r, str, len, &buf) > 0){
        detached = (buf.len == r->hash_algo->hexsz && !get_oid_hex(buf.buf, oid));
        strbuf_release(&buf);
        if (detached)
            return 0;
    }
}
",,
implicit_predicate,object-name.c,997,+,-,"if (detached)
    return 0;
",,
implicit_predicate,object-name.c,1005,+,-,"if (reflog_len)
    refs_found = repo_dwim_log(r, str, len, oid, &real_ref);
else
    refs_found = repo_dwim_ref(r, str, len, oid, &real_ref, !fatal);
",,
implicit_predicate,object-name.c,1018,+,-,"if (reflog_len){
    int nth, i;
    timestamp_t at_time;
    timestamp_t co_time;
    int co_tz, co_cnt;
    for (i = nth = 0;0 <= nth && i < reflog_len;i++){
        char ch = str[at + 2 + i];
        if ('0' <= ch && ch <= '9')
            nth = nth * 10 + ch - '0';
        else
            nth = -1;
    }
    if (100000000 <= nth){
        at_time = nth;
        nth = -1;
    }else
        if (0 <= nth)
            at_time = 0;
        else{
            int errors = 0;
            char* tmp = xstrndup(str + at + 2, reflog_len);
            at_time = approxidate_careful(tmp, &errors);
            free(tmp);
            if (errors){
                free(real_ref);
                return -1;
            }
        }

    if (read_ref_at(get_main_ref_store(r), real_ref, flags, at_time, nth, oid, NULL, &co_time, &co_tz, &co_cnt)){
        if (!len){
            if (!skip_prefix(real_ref, ""refs/heads/"", &str))
                str = ""HEAD"";

            len = strlen(str);
        }
        if (at_time){
            if (!(flags & GET_OID_QUIETLY)){
                warning(_(""log for '%.*s' only goes back to %s""), len, str, show_date(co_time, co_tz, DATE_MODE(RFC2822)));
            }
        }else
            if (nth == co_cnt && !is_null_oid(oid)){
            }else{
                if (flags & GET_OID_QUIETLY){
                    exit(128);
                }
                die(_(""log for '%.*s' only has %d entries""), len, str, co_cnt);
            }
    }
}
",,
implicit_predicate,object-name.c,1042,+,-,"if (errors){
    free(real_ref);
    return -1;
}
",,
implicit_predicate,object-name.c,1124,+,-,"if (ret)
    return ret;
",,
implicit_predicate,object-name.c,1130,+,-,"while (generation--){
    if (repo_parse_commit(r, commit) || !commit->parents)
        return MISSING_OBJECT;

    commit = commit->parents->item;
}
",,
implicit_predicate,object-name.c,1144,+,-,"while (1){
    if (!o || (!o->parsed && !parse_object(r, &o->oid)))
        return NULL;

    if (expected_type == OBJ_ANY || o->type == expected_type)
        return o;

    if (o->type == OBJ_TAG)
        o = ((struct tag*)o)->tagged;
    else
        if (o->type == OBJ_COMMIT)
            o = &(repo_get_commit_tree(r, ((struct commit*)o))->object);
        else{
            if (name)
                error(""%.*s: expected %s type, but the object dereferences to %s type"", namelen, name, type_name(expected_type), type_name(o->type));

            return NULL;
        }
}
",,
implicit_predicate,object-name.c,1306,+,-,"if (has_suffix){
    unsigned int num = 0;
    int len1 = cp - name;
    cp++;
    while (cp < name + len){
        unsigned int digit = *cp++ - '0';
        if (unsigned_mult_overflows(num, 10))
            return MISSING_OBJECT;

        num *= 10;
        if (unsigned_add_overflows(num, digit))
            return MISSING_OBJECT;

        num += digit;
    }
    if (!num && len1 == len - 1)
        num = 1;
    else
        if (num > INT_MAX)
            return MISSING_OBJECT;

    if (has_suffix == '^')
        return get_parent(r, name, len1, oid, num);

    return get_nth_ancestor(r, name, len1, oid, num);
}
",,
implicit_predicate,object-name.c,1427,+,-,"if (matches){
    oidcpy(oid, &commit->object.oid);
    found = 1;
    break;
}
",,
implicit_predicate,object-name.c,1438,+,+,found ? 0 : -1,9,	return found ? 0 : -1;
implicit_predicate,object-name.c,1532,+,-,"if (st)
    return st;
",,
implicit_predicate,object-name.c,1538,-,+,,33,"	if (repo_get_oid_committish(r, dots[3] ? (dots + 3) : ""HEAD"", &oid_tmp))"
implicit_predicate,object-name.c,1648,+,-,"if (at){
    char* name_str = xmemdupz(name, at);
    branch = branch_get(name_str);
    free(name_str);
}else
    branch = branch_get(NULL);
",,
implicit_predicate,object-name.c,1948,-,+,,7,"			   startup_info->prefix ? strlen(startup_info->prefix) : 0,"
implicit_predicate,object-name.c,1961,+,-,"if (only_to_die)
    diagnose_invalid_index_path(repo, stage, prefix, cp);
",,
implicit_predicate,object-name.c,2041,+,-,"if (reject_tree_in_index(repo, only_to_die, ce, stage, prefix, cp))
    return -1;
",,
implicit_predicate,object-name.c,2098,+,-,"if (only_to_die)
    die(_(""invalid object name '%.*s'.""), len, name);
",,
implicit_predicate,object-store-ll.h,155,-,+,,32,"	return strcmp(pg1->pack_name, key ? key : pg2->pack_name);"
implicit_predicate,object-store-ll.h,430,+,-,"if (obj_read_use_lock)
    pthread_mutex_lock(&obj_read_mutex);
",,
implicit_predicate,object-store-ll.h,436,+,-,"if (obj_read_use_lock)
    pthread_mutex_unlock(&obj_read_mutex);
",,
implicit_predicate,object.c,54,+,-,"if (gentle)
    return -1;
",,
implicit_predicate,object.c,267,-,+,,39,"	die(_(""unable to parse object: %s""), name ? name : oid_to_hex(oid));"
implicit_predicate,object.c,287,+,-,"if (skip_hash){
    struct commit* commit = lookup_commit_in_graph(r, repl);
    if (commit)
        return &commit->object;
}
",,
implicit_predicate,object.c,310,+,-,"if (skip_hash){
    struct commit* commit = lookup_commit_in_graph(r, repl);
    if (commit)
        return &commit->object;
}
",,
implicit_predicate,obstack.c,294,+,-,"CALL_FREEFUN (h, old_chunk);
",,
implicit_predicate,obstack.c,350,+,-,"CALL_FREEFUN (h, lp);
",,
implicit_predicate,oid-array.c,64,+,-,"if (ret)
    return ret;
",,
implicit_predicate,oid-array.c,80,+,-,"if (ret)
    return ret;
",,
implicit_predicate,oidmap.c,31,+,+,free_entries ? 0 : -1,28,"	hashmap_clear_(&map->map, free_entries ? 0 : -1);"
implicit_predicate,oidtree.c,72,-,+,,9,"	return cb_lookup(&ot->tree, (const uint8_t *)&k, klen) ? 1 : 0;"
implicit_predicate,pack-bitmap-write.c,294,+,-,"if (c_ent->maximal){
    num_maximal++;
    ALLOC_GROW(bb->commits, bb->commits_nr + 1, bb->commits_alloc);
    bb->commits[bb->commits_nr++] = commit;
}
",,
implicit_predicate,pack-bitmap-write.c,318,+,-,"if (p_not_c)
    p_ent->maximal = 1;
else{
    p_ent->maximal = 0;
    free_commit_list(p_ent->reverse_edges);
    p_ent->reverse_edges = NULL;
}
",,
implicit_predicate,pack-bitmap-write.c,326,+,-,"if (c_ent->maximal){
    commit_list_insert(commit, &p_ent->reverse_edges);
}else{
    struct commit_list* cc = c_ent->reverse_edges;
    for (;cc;cc = cc->next){
        if (!commit_list_contains(cc->item, p_ent->reverse_edges))
            commit_list_insert(cc->item, &p_ent->reverse_edges);
    }
}
",,
implicit_predicate,pack-bitmap-write.c,537,+,-,"if (ent->selected){
    store_selected(writer, ent, commit);
    nr_stored++;
    display_progress(writer->progress, nr_stored);
}
",,
implicit_predicate,pack-bitmap-write.c,549,+,-,"if (reused)
    child_ent->bitmap = bitmap_dup(ent->bitmap);
else{
    child_ent->bitmap = ent->bitmap;
    reused = 1;
}
",,
implicit_predicate,pack-bitmap-write.c,573,+,-,"if (closed)
    compute_xor_offsets(writer);
",,
implicit_predicate,pack-bitmap-write.c,575,+,+,closed ? 0 : -1,9,	return closed ? 0 : -1;
implicit_predicate,pack-bitmap.c,261,-,+,,10,"		return nth_midxed_object_oid(oid, index->midx, n) ? 0 : -1;"
implicit_predicate,pack-bitmap.c,482,+,-,"if (ret)
    return ret;
",,
implicit_predicate,pack-bitmap.c,497,+,-,"if (load_reverse_index(r, bitmap_git))
    goto failed;
",,
implicit_predicate,pack-bitmap.c,577,+,+,found ? 0 : -1,9,	return found ? 0 : -1;
implicit_predicate,pack-bitmap.c,727,+,-,"if (is_corrupt)
    return NULL;
",,
implicit_predicate,pack-bitmap.c,1135,+,-,"if (add_commit_to_bitmap(bitmap_git, &cb.base, (struct commit*)object))
    continue;
",,
implicit_predicate,pack-bitmap.c,1265,+,-,"if (needs_walk){
    base = fill_in_bitmap(bitmap_git, revs, base, seen);
}
",,
implicit_predicate,pack-bitmap.c,1583,+,-,"if (limit)
    BUG(""filter_bitmap_tree_depth given non-zero limit"");
",,
implicit_predicate,pack-bitmap.c,1780,+,-,"if (use_boundary_traversal){
    trace2_region_enter(""pack-bitmap"", ""haves/boundary"", the_repository);
    haves_bitmap = find_boundary_objects(bitmap_git, revs, haves);
    trace2_region_leave(""pack-bitmap"", ""haves/boundary"", the_repository);
}else{
    trace2_region_enter(""pack-bitmap"", ""haves/classic"", the_repository);
    revs->ignore_missing_links = 1;
    haves_bitmap = find_objects(bitmap_git, revs, haves, NULL);
    reset_revision_walk();
    revs->ignore_missing_links = 0;
    trace2_region_leave(""pack-bitmap"", ""haves/classic"", the_repository);
}
",,
implicit_predicate,pack-bitmap.c,1797,+,-,"if (use_boundary_traversal){
    object_array_clear(&revs->pending);
    reset_revision_walk();
}
",,
implicit_predicate,pack-bitmap.c,2055,+,-,"if (multi_pack_reuse){
    for (i = 0;i < bitmap_git->midx->num_packs;i++){
        struct bitmapped_pack pack;
        if (nth_bitmapped_pack(r, bitmap_git->midx, &pack, i) < 0){
            warning(_(""unable to load pack: '%s', disabling pack-reuse""), bitmap_git->midx->pack_names[i]);
            free(packs);
            return;
        }
        if (!pack.bitmap_nr)
            continue;

        ALLOC_GROW(packs, packs_nr + 1, packs_alloc);
        memcpy(&packs[packs_nr++], &pack, sizeof (pack));
        objects_nr += pack.p->num_objects;
    }
    QSORT(packs, packs_nr, bitmapped_pack_cmp);
}else{
    struct packed_git* pack;
    if (bitmap_is_midx(bitmap_git)){
        uint32_t preferred_pack_pos;
        if (midx_preferred_pack(bitmap_git->midx, &preferred_pack_pos) < 0){
            warning(_(""unable to compute preferred pack, disabling pack-reuse""));
            return;
        }
        pack = bitmap_git->midx->packs[preferred_pack_pos];
    }else{
        pack = bitmap_git->pack;
    }
    ALLOC_GROW(packs, packs_nr + 1, packs_alloc);
    packs[packs_nr].p = pack;
    packs[packs_nr].bitmap_nr = pack->num_objects;
    packs[packs_nr].bitmap_pos = 0;
    objects_nr = packs[packs_nr++].bitmap_nr;
}
",,
implicit_predicate,pack-bitmap.c,2296,-,+,,3,"		bitmap_git->table_lookup ? """" : "" loaded"");"
implicit_predicate,pack-mtimes.c,87,+,-,"if (ret){
    if (data)
        munmap(data, mtimes_size);
}else{
    *len_p = mtimes_size;
    *data_p = data;
}
",,
implicit_predicate,pack-objects.c,62,+,-,"if (found)
    BUG(""Duplicate object in hash"");
",,
implicit_predicate,pack-objects.c,205,+,-,"if (found)
    BUG(""duplicate object inserted into hash"");
",,
implicit_predicate,pack-objects.c,371,-,+,,32,"			zret = git_deflate(&stream, readlen ? 0 : Z_FINISH);"
implicit_predicate,pack-objects.c,706,+,-,"if (usable_delta)
    written_delta++;
",,
implicit_predicate,pack-objects.c,734,+,-,"if (recursing){
    warning(_(""recursive delta detected for object %s""), oid_to_hex(&e->idx.oid));
    return WRITE_ONE_RECURSIVE;
}else
    if (e->idx.offset || e->preferred_base){
        return WRITE_ONE_SKIP;
    }
",,
implicit_predicate,pack-objects.c,814,+,-,"if (add_to_order){
    struct object_entry* s;
    add_to_write_order(wo, endp, e);
    for (s = DELTA_SIBLING(e);s;s = DELTA_SIBLING(s)){
        add_to_write_order(wo, endp, s);
    }
}
",,
implicit_predicate,pack-objects.c,945,+,-,"if (use_delta_islands){
    max_layers = compute_pack_layers(&to_pack);
    free_island_marks();
}
",,
implicit_predicate,pack-objects.c,1185,+,-,"if (allow_ofs_delta)
    i = write_reused_pack_verbatim(reuse_packfile, f, pack_start, &w_curs);
",,
implicit_predicate,pack-objects.c,1259,+,-,"if (pack_to_stdout)
    f = hashfd_throughput(1, ""<stdout>"", progress_state);
else
    f = create_tmp_packfile(&pack_tmp_name);
",,
implicit_predicate,pack-objects.c,1271,+,-,"if (reused_chunks_nr)
    reuse_packfiles_used_nr++;
",,
implicit_predicate,pack-objects.c,1285,+,-,"if (pack_to_stdout){
    finalize_hashfile(f, hash, FSYNC_COMPONENT_NONE, CSUM_HASH_IN_STREAM | CSUM_CLOSE);
}else
    if (nr_written == nr_remaining){
        finalize_hashfile(f, hash, FSYNC_COMPONENT_PACK, CSUM_HASH_IN_STREAM | CSUM_FSYNC | CSUM_CLOSE);
    }else{
        int fd = finalize_hashfile(f, hash, FSYNC_COMPONENT_PACK, 0);
        fixup_pack_header_footer(fd, hash, pack_tmp_name, nr_written, hash, offset);
        close(fd);
        if (write_bitmap_index){
            if (write_bitmap_index != WRITE_BITMAP_QUIET)
                warning(_(no_split_warning));

            write_bitmap_index = 0;
        }
    }
",,
implicit_predicate,pack-objects.c,1350,+,-,"if (cruft)
    pack_idx_opts.flags |= WRITE_MTIMES;
",,
implicit_predicate,pack-objects.c,1439,+,-,"if (exclude){
    if (!entry->preferred_base)
        nr_result--;

    entry->preferred_base = 1;
}
",,
implicit_predicate,pack-objects.c,1451,+,-,"if (exclude)
    return 1;
",,
implicit_predicate,pack-objects.c,1453,+,-,"if (incremental)
    return 0;
",,
implicit_predicate,pack-objects.c,1494,+,-,"if (ignore_packed_keep_on_disk)
    flags |= ON_DISK_KEEP_PACKS;
",,
implicit_predicate,pack-objects.c,1496,+,-,"if (ignore_packed_keep_in_core)
    flags |= IN_CORE_KEEP_PACKS;
",,
implicit_predicate,pack-objects.c,1633,+,-,"if (exclude)
    entry->preferred_base = 1;
else
    nr_result++;
",,
implicit_predicate,pack-objects.c,1659,+,-,"if (have_duplicate_entry(oid, exclude))
    return 0;
",,
implicit_predicate,pack-objects.c,1996,+,-,"if (use_delta_islands){
    if (!in_same_island(&delta->idx.oid, base_oid))
        return 0;
}
",,
implicit_predicate,pack-objects.c,2092,+,-,"while (c & 128){
    ofs += 1;
    if (!ofs || MSB(ofs, 7)){
        error(_(""delta base offset overflow in pack for %s""), oid_to_hex(&entry->idx.oid));
        goto give_up;
    }
    c = buf[used_0++];
    ofs = (ofs << 7) + (c & 127);
}
",,
implicit_predicate,pack-objects.c,2227,+,-,"while (*idx){
    struct object_entry* oe = &to_pack.objects[*idx - 1];
    if (oe == entry)
        *idx = oe->delta_sibling_idx;
    else
        idx = &oe->delta_sibling_idx;
}
",,
implicit_predicate,pack-objects.c,2384,+,-,"if (progress)
    progress_state = start_progress(_(""Counting objects""), to_pack.nr_objects);
",,
implicit_predicate,pack-objects.c,2443,+,-,"if (use_delta_islands){
    const int island_cmp = island_delta_cmp(&a->idx.oid, &b->idx.oid);
    if (island_cmp)
        return island_cmp;
}
",,
implicit_predicate,pack-objects.c,2694,+,-,"if (delta_cacheable(src_size, trg_size, delta_size)){
    delta_cache_size += delta_size;
    cache_unlock();
    trg_entry->delta_data = xrealloc(delta_buf, delta_size);
}else{
    cache_unlock();
    free(delta_buf);
}
",,
implicit_predicate,pack-objects.c,2856,+,-,"while (dist--){
    int src = (dst + 1) % window;
    array[dst] = array[src];
    dst = src;
}
",,
implicit_predicate,pack-objects.c,2933,+,-,"while (me->remaining){
    progress_unlock();
    find_deltas(me->list, &me->remaining, me->window, me->depth, me->processed);
    progress_lock();
    me->working = 0;
    pthread_cond_signal(&progress_cond);
    progress_unlock();
    pthread_mutex_lock(&me->mutex);
    while (!me->data_ready)
        pthread_cond_wait(&me->cond, &me->mutex);
    me->data_ready = 0;
    pthread_mutex_unlock(&me->mutex);
    progress_lock();
}
",,
implicit_predicate,pack-objects.c,3019,+,-,"if (ret)
    die(_(""unable to create thread: %s""), strerror(ret));
",,
implicit_predicate,pack-objects.c,3032,+,-,"while (active_threads){
    struct thread_params* target = NULL;
    struct thread_params* victim = NULL;
    unsigned sub_size = 0;
    progress_lock();
    for (;;){
        for (i = 0;!target && i < delta_search_threads;i++)
            if (!p[i].working)
                target = &p[i];
        if (target)
            break;

        pthread_cond_wait(&progress_cond, &progress_mutex);
    }
    for (i = 0;i < delta_search_threads;i++)
        if (p[i].remaining > 2 * window && (!victim || victim->remaining < p[i].remaining))
            victim = &p[i];
    if (victim){
        sub_size = victim->remaining / 2;
        list = victim->list + victim->list_size - sub_size;
        while (sub_size && list[0]->hash && list[0]->hash == list[-1]->hash){
            list++;
            sub_size--;
        }
        if (!sub_size){
            sub_size = victim->remaining / 2;
            list -= sub_size;
        }
        target->list = list;
        victim->list_size -= sub_size;
        victim->remaining -= sub_size;
    }
    target->list_size = sub_size;
    target->remaining = sub_size;
    target->working = 1;
    progress_unlock();
    pthread_mutex_lock(&target->mutex);
    target->data_ready = 1;
    pthread_cond_signal(&target->cond);
    pthread_mutex_unlock(&target->mutex);
    if (!sub_size){
        pthread_join(target->thread, NULL);
        pthread_cond_destroy(&target->cond);
        pthread_mutex_destroy(&target->mutex);
        active_threads--;
    }
}
",,
implicit_predicate,pack-objects.c,3112,+,-,"if (obj_is_packed(oid))
    return;
",,
implicit_predicate,pack-objects.c,3116,+,-,"while (1){
    if (!tag || parse_tag(tag) || !tag->tagged)
        die(_(""unable to pack objects reachable from tag %s""), oid_to_hex(oid));

    add_object_entry(&tag->object.oid, OBJ_TAG, NULL, 0);
    if (tag->tagged->type != OBJ_TAG)
        return;

    tag = (struct tag*)tag->tagged;
}
",,
implicit_predicate,pack-objects.c,3146,+,-,"if (use_delta_islands)
    resolve_tree_islands(the_repository, progress, &to_pack);
",,
implicit_predicate,pack-objects.c,3204,+,-,"if (progress)
    progress_state = start_progress(_(""Compressing objects""), nr_deltas);
",,
implicit_predicate,pack-objects.c,3266,+,-,"if (res){
    allow_pack_reuse = SINGLE_PACK_REUSE;
}else{
    allow_pack_reuse = NO_PACK_REUSE;
}
",,
implicit_predicate,pack-objects.c,3342,+,-,"if (have_duplicate_entry(oid, 0))
    return 0;
",,
implicit_predicate,pack-objects.c,3632,+,-,"if (progress)
    progress_state = start_progress(_(""Enumerating cruft objects""), 0);
",,
implicit_predicate,pack-objects.c,3658,+,-,"if (progress)
    progress_state = start_progress(_(""Enumerating cruft objects""), 0);
",,
implicit_predicate,pack-objects.c,3664,+,-,"if (ret)
    die(_(""unable to add cruft objects""));
",,
implicit_predicate,pack-objects.c,3677,+,-,"if (progress)
    progress_state = start_progress(_(""Traversing cruft objects""), 0);
",,
implicit_predicate,pack-objects.c,3799,-,+,,11,		depth = *name ? 1 : 0;
implicit_predicate,pack-objects.c,4042,+,-,"if (pack_options_allow_reuse())
    reuse_partial_packfile_from_bitmap(bitmap_git, &reuse_packfiles, &reuse_packfiles_nr, &reuse_packfile_bitmap, allow_pack_reuse == MULTI_PACK_REUSE);
",,
implicit_predicate,pack-objects.c,4159,+,-,"if (use_delta_islands)
    load_delta_islands(the_repository, progress);
",,
implicit_predicate,pack-objects.c,4186,+,-,"if (keep_unreachable)
    add_objects_in_unpacked_packs();
",,
implicit_predicate,pack-objects.c,4188,+,-,"if (pack_loose_unreachable)
    add_unreachable_loose_objects();
",,
implicit_predicate,pack-objects.c,4190,+,-,"if (unpack_unreachable)
    loosen_unused_packed_objects();
",,
implicit_predicate,pack-objects.c,4425,+,-,"if (argc){
    base_name = argv[0];
    argc--;
}
",,
implicit_predicate,pack-objects.c,4448,+,-,"if (thin){
    use_internal_rev_list = 1;
    strvec_push(&rp, shallow ? ""--objects-edge-aggressive"" : ""--objects-edge"");
}else
    strvec_push(&rp, ""--objects"");
",,
implicit_predicate,pack-objects.c,4450,+,+,"shallow ? ""--objects-edge-aggressive"" : ""--objects-edge""",20,"		strvec_push(&rp, shallow
				? ""--objects-edge-aggressive""
				: ""--objects-edge"");"
implicit_predicate,pack-objects.c,4456,+,-,"if (rev_list_all){
    use_internal_rev_list = 1;
    strvec_push(&rp, ""--all"");
}
",,
implicit_predicate,pack-objects.c,4460,+,-,"if (rev_list_reflog){
    use_internal_rev_list = 1;
    strvec_push(&rp, ""--reflog"");
}
",,
implicit_predicate,pack-objects.c,4464,+,-,"if (rev_list_index){
    use_internal_rev_list = 1;
    strvec_push(&rp, ""--indexed-objects"");
}
",,
implicit_predicate,pack-objects.c,4473,+,-,"if (exclude_promisor_objects){
    use_internal_rev_list = 1;
    fetch_if_missing = 0;
    strvec_push(&rp, ""--exclude-promisor-objects"");
}
",,
implicit_predicate,pack-objects.c,4516,+,-,"if (cruft){
    if (use_internal_rev_list)
        die(_(""cannot use internal rev list with --cruft""));

    if (stdin_packs)
        die(_(""cannot use --stdin-packs with --cruft""));
}
",,
implicit_predicate,pack-objects.c,4517,+,-,"if (use_internal_rev_list)
    die(_(""cannot use internal rev list with --cruft""));
",,
implicit_predicate,pack-objects.c,4519,+,-,"if (stdin_packs)
    die(_(""cannot use --stdin-packs with --cruft""));
",,
implicit_predicate,pack-objects.c,4545,+,-,"if (use_delta_islands)
    strvec_push(&rp, ""--topo-order"");
",,
implicit_predicate,pack-objects.c,4552,+,-,"if (ignore_packed_keep_on_disk){
    struct packed_git* p;
    for (p = get_all_packs(the_repository);p;p = p->next)
        if (p->pack_local && p->pack_keep)
            break;
    if (!p)
        ignore_packed_keep_on_disk = 0;
}
",,
implicit_predicate,pack-objects.c,4560,+,-,"if (local){
    struct packed_git* p;
    for (p = get_all_packs(the_repository);p;p = p->next){
        if (!p->pack_local){
            have_non_local_packs = 1;
            break;
        }
    }
}
",,
implicit_predicate,pack-objects.c,4581,+,-,"if (stdin_packs){
    ignore_packed_keep_in_core = 1;
    read_packs_list_from_stdin();
    if (rev_list_unpacked)
        add_unreachable_loose_objects();
}else
    if (cruft){
        read_cruft_objects();
    }else
        if (!use_internal_rev_list){
            read_object_list_from_stdin();
        }else{
            struct rev_info revs;
            repo_init_revisions(the_repository, &revs, NULL);
            list_objects_filter_copy(&revs.filter, &filter_options);
            get_object_list(&revs, rp.nr, rp.v);
            release_revisions(&revs);
        }
",,
implicit_predicate,pack-objects.c,4585,+,-,"if (rev_list_unpacked)
    add_unreachable_loose_objects();
",,
implicit_predicate,pack-objects.c,4587,+,-,"if (cruft){
    read_cruft_objects();
}else
    if (!use_internal_rev_list){
        read_object_list_from_stdin();
    }else{
        struct rev_info revs;
        repo_init_revisions(the_repository, &revs, NULL);
        list_objects_filter_copy(&revs.filter, &filter_options);
        get_object_list(&revs, rp.nr, rp.v);
        release_revisions(&revs);
    }
",,
implicit_predicate,pack-objects.h,212,-,+,,9,	return e->type_valid ? e->type_ : OBJ_BAD;
implicit_predicate,pack-refs.c,45,+,-,"if (pack_all)
    string_list_append(pack_refs_opts.includes, ""*"");
",,
implicit_predicate,pack-revindex.c,258,+,-,"if (ret){
    if (data)
        munmap(data, revindex_size);
}else{
    *len_p = revindex_size;
    *data_p = (const uint32_t*)data;
}
",,
implicit_predicate,pack-revindex.c,284,+,-,"if (ret)
    goto cleanup;
",,
implicit_predicate,pack-revindex.c,329,+,-,"if (create_pack_revindex_in_memory(p))
    return res;
",,
implicit_predicate,pack-revindex.c,365,+,-,"if (can_use_midx_ridx_chunk(m)){
    trace2_data_string(""load_midx_revindex"", the_repository, ""source"", ""midx"");
    m->revindex_data = (const uint32_t*)m->chunk_revindex;
    return 0;
}
",,
implicit_predicate,pack-revindex.c,390,+,-,"if (ret)
    goto cleanup;
",,
implicit_predicate,pack-write.c,64,+,-,"if (nr_objects){
    sorted_by_sha = objects;
    list = sorted_by_sha;
    last = sorted_by_sha + nr_objects;
    for (i = 0;i < nr_objects;++i){
        if (objects[i]->offset > last_obj_offset)
            last_obj_offset = objects[i]->offset;
    }
    QSORT(sorted_by_sha, nr_objects, sha1_compare);
}else
    sorted_by_sha = list = last = NULL;
",,
implicit_predicate,pack-write.c,93,-,+,,18,"	index_version = need_large_offset(last_obj_offset, opts) ? 2 : opts->version;"
implicit_predicate,pack-write.c,151,-,+,,14,"			offset = (need_large_offset(obj->offset, opts)
				  ? (0x80000000 | nr_large_offset++)
				  : obj->offset);"
implicit_predicate,pack-write.c,159,+,-,"while (nr_large_offset){
    struct pack_idx_entry* obj = *list++;
    uint64_t offset = obj->offset;
    if (!need_large_offset(offset, opts))
        continue;

    hashwrite_be64(f, offset);
    nr_large_offset--;
}
",,
implicit_predicate,pack-write.c,173,-,+,,7,			  ((opts->flags & WRITE_IDX_VERIFY) ? 0 : CSUM_FSYNC));
implicit_predicate,pack-write.c,283,-,+,,7,			  ((flags & WRITE_IDX_VERIFY) ? 0 : CSUM_FSYNC));
implicit_predicate,pack-write.c,589,+,-,"if (err)
    die(_(""could not write '%s' promisor file""), promisor_name);
",,
implicit_predicate,packed-backend.c,176,+,-,"if (snapshot->mmapped){
    if (munmap(snapshot->buf, snapshot->eof - snapshot->buf))
        die_errno(""error ummapping packed-refs file %s"", snapshot->refs->path);

    snapshot->mmapped = 0;
}else{
    free(snapshot->buf);
}
",,
implicit_predicate,packed-backend.c,289,+,-,"while (1){
    if (*r1 == '\n')
        return *r2 == '\n' ? 0 : -1;

    if (*r1 != *r2){
        if (*r2 == '\n')
            return 1;
        else
            return (unsigned char)*r1 < (unsigned char)*r2 ? -1 : +1;
    }
    r1++;
    r2++;
}
",,
implicit_predicate,packed-backend.c,305,+,-,"while (1){
    if (*r1 == '\n')
        return *r2 == '\n' ? 0 : -1;

    if (*r1 != *r2){
        if (*r2 == '\n')
            return 1;
        else
            return (unsigned char)*r1 < (unsigned char)*r2 ? -1 : +1;
    }
    r1++;
    r2++;
}
",,
implicit_predicate,packed-backend.c,313,+,-,"while (1){
    if (*r1 == '\n')
        return *r2 ? -1 : 0;

    if (!*r2)
        return start ? 1 : -1;

    if (*r1 != *r2)
        return (unsigned char)*r1 < (unsigned char)*r2 ? -1 : +1;

    r1++;
    r2++;
}
",,
implicit_predicate,packed-backend.c,315,-,+,,11,			return *r2 ? -1 : 0;
implicit_predicate,packed-backend.c,317,+,+,start ? 1 : -1,11,			return start ? 1 : -1;
implicit_predicate,packed-backend.c,329,+,-,"while (1){
    if (*r1 == '\n')
        return *r2 ? -1 : 0;

    if (!*r2)
        return start ? 1 : -1;

    if (*r1 != *r2)
        return (unsigned char)*r1 < (unsigned char)*r2 ? -1 : +1;

    r1++;
    r2++;
}
",,
implicit_predicate,packed-backend.c,333,+,-,start ? 1 : -1,,
implicit_predicate,packed-backend.c,389,+,-,"if (sorted)
    goto cleanup;
",,
implicit_predicate,packed-backend.c,405,+,-,"if (sorted)
    goto cleanup;
",,
implicit_predicate,packed-backend.c,574,+,-,"if (mustexist)
    return NULL;
else
    return lo;
",,
implicit_predicate,packed-backend.c,591,+,-,"if (mustexist)
    return NULL;
else
    return lo;
",,
implicit_predicate,packed-backend.c,952,-,+,,10,		return is_null_oid(&iter->peeled) ? -1 : 0;
implicit_predicate,packed-backend.c,956,-,+,,10,"		return peel_object(&iter->oid, peeled) ? -1 : 0;"
implicit_predicate,packed-backend.c,1024,+,-,"if (has_glob_special(*pattern))
    continue;
",,
implicit_predicate,packed-backend.c,1038,+,-,"if (has_glob_special(*pattern))
    continue;
",,
implicit_predicate,packed-backend.c,1399,+,+,peel_error ? NULL : &peeled,13,					       peel_error ? NULL : &peeled))
implicit_predicate,packed-backend.c,1413,+,-,peel_error ? NULL : &peeled,,
implicit_predicate,packed-backend.c,1420,+,+,peel_error ? NULL : &peeled,13,					       peel_error ? NULL : &peeled))
implicit_predicate,packed-backend.c,1435,+,-,peel_error ? NULL : &peeled,,
implicit_predicate,packed-backend.c,1627,+,-,"if (packed_refs_lock(ref_store, 0, err))
    goto failure;
",,
implicit_predicate,packed-backend.c,1632,+,-,"if (write_with_updates(refs, &data->updates, err))
    goto failure;
",,
implicit_predicate,packed-backend.c,1642,+,-,"if (packed_refs_lock(ref_store, 0, err))
    goto failure;
",,
implicit_predicate,packed-backend.c,1647,+,-,"if (write_with_updates(refs, &data->updates, err))
    goto failure;
",,
implicit_predicate,packfile.c,110,+,-,"if (ret)
    munmap(idx_map, idx_size);
",,
implicit_predicate,packfile.c,218,+,-,"if (open_pack_index(p))
    return 0;
",,
implicit_predicate,packfile.c,246,+,-,"if (check_packed_git_idx(idx_path, p)){
    free(p);
    return NULL;
}
",,
implicit_predicate,packfile.c,432,+,-,"if (*accept_windows_inuse)
    has_windows_inuse = 1;
else
    return;
",,
implicit_predicate,packfile.c,544,+,-,"if (open_pack_index(p))
    return error(""packfile %s index unavailable"", p->pack_name);
",,
implicit_predicate,packfile.c,939,+,-,"if (open_pack_index(p))
    continue;
",,
implicit_predicate,packfile.c,962,+,-,"if (st)
    return -st;
",,
implicit_predicate,packfile.c,1219,+,-,"while (c & 128){
    base_offset += 1;
    if (!base_offset || MSB(base_offset, 7))
        return 0;

    c = base_info[used++];
    base_offset = (base_offset << 7) + (c & 127);
}
",,
implicit_predicate,packfile.c,1350,+,-,"while (poi_stack_nr){
    obj_offset = poi_stack[--poi_stack_nr];
    type = retry_bad_packed_offset(r, p, obj_offset);
    if (type > OBJ_NONE)
        goto out;
}
",,
implicit_predicate,packfile.c,1401,-,+,,9,"	return e ? container_of(e, struct delta_base_cache_entry, ent) : NULL;"
implicit_predicate,packfile.c,1599,-,+,,15,"	oi->whence = in_delta_base_cache(p, obj_offset) ? OI_DBCACHED :
							  OI_PACKED;"
implicit_predicate,packfile.c,1780,+,-,<!!!>,,
implicit_predicate,packfile.c,1912,+,-,"if (open_pack_index(p))
    return -1;
",,
implicit_predicate,packfile.c,1970,+,-,"if (open_pack_index(p))
    return 0;
",,
implicit_predicate,packfile.c,2120,+,-,"if (fill_pack_entry(oid, e, p))
    return 1;
",,
implicit_predicate,packfile.c,2185,+,-,"if (r)
    break;
",,
implicit_predicate,packfile.c,2211,+,-,"if (open_pack_index(p)){
    pack_errors = 1;
    continue;
}
",,
implicit_predicate,packfile.c,2216,+,-,"if (r)
    break;
",,
implicit_predicate,packfile.c,2219,+,+,r ? r : pack_errors,9,	return r ? r : pack_errors;
implicit_predicate,pager.c,170,+,-,"if (term_columns_at_startup)
    return term_columns_at_startup;
",,
implicit_predicate,parallel-checkout.c,99,-,+,,4,		(ca->working_tree_encoding ? strlen(ca->working_tree_encoding) : 0);
implicit_predicate,parallel-checkout.c,251,+,-,"if (have_pending)
    error(""parallel checkout finished with pending entries"");
",,
implicit_predicate,parallel-checkout.c,283,+,-,"if (reset_fd(fd, path))
    return -1;
",,
implicit_predicate,parallel-checkout.c,304,+,-,"if (ret){
    size_t newsize;
    free(blob);
    blob = strbuf_detach(&buf, &newsize);
    size = newsize;
}
",,
implicit_predicate,parallel-checkout.c,334,-,+,,22,	unsigned int mode = (pc_item->ce->ce_mode & 0100) ? 0777 : 0666;
implicit_predicate,parallel-checkout.c,388,+,-,"if (close_and_clear(&fd)){
    error_errno(""unable to close file '%s'"", path.buf);
    pc_item->status = PC_ITEM_FAILED;
    goto out;
}
",,
implicit_predicate,parallel-checkout.c,413,-,+,,37,"	size_t working_tree_encoding_len = working_tree_encoding ?
					   strlen(working_tree_encoding) : 0;"
implicit_predicate,parallel-checkout.c,598,+,-,"while (active_workers){
    int nr = poll(pfds, num_workers, -1);
    if (nr < 0){
        if (errno == EINTR)
            continue;

        die_errno(""failed to poll checkout workers"");
    }
    for (i = 0;i < num_workers && nr > 0;i++){
        struct pc_worker* worker = &workers[i];
        struct pollfd* pfd = &pfds[i];
        if (!pfd->revents)
            continue;

        if (pfd->revents & POLLIN){
            int len = packet_read(pfd->fd, packet_buffer, sizeof (packet_buffer), 0);
            if (len < 0){
                BUG(""packet_read() returned negative value"");
            }else
                if (!len){
                    pfd->fd = -1;
                    active_workers--;
                }else{
                    parse_and_save_result(packet_buffer, len, worker);
                }
        }else
            if (pfd->revents & POLLHUP){
                pfd->fd = -1;
                active_workers--;
            }else
                if (pfd->revents & (POLLNVAL | POLLERR)){
                    die(""error polling from checkout worker"");
                }

        nr--;
    }
}
",,
implicit_predicate,parse-options-cb.c,21,+,+,unset ? 0 : DEFAULT_ABBREV,7,		v = unset ? 0 : DEFAULT_ABBREV;
implicit_predicate,parse-options-cb.c,22,+,-,unset ? 0 : DEFAULT_ABBREV,,
implicit_predicate,parse-options-cb.c,42,+,-,"if (unset)
    arg = ""never"";
",,
implicit_predicate,parse-options-cb.c,43,+,-,"if (unset)
    arg = ""never"";
",,
implicit_predicate,parse-options-cb.c,55,+,+,"unset ? ""never"" : (const char*)opt->defval",9,"		arg = unset ? ""never"" : (const char *)opt->defval;"
implicit_predicate,parse-options-cb.c,56,+,-,"unset ? ""never"" : (const char*)opt->defval",,
implicit_predicate,parse-options-cb.c,71,+,-,"if (unset)
    *target = 0;
else
    if (opt->short_name == 'v'){
        if (*target >= 0)
            (*target)++;
        else
            *target = 1;
    }else{
        if (*target <= 0)
            (*target)--;
        else
            *target = -1;
    }
",,
implicit_predicate,parse-options-cb.c,72,+,-,"if (unset)
    *target = 0;
else
    if (opt->short_name == 'v'){
        if (*target >= 0)
            (*target)++;
        else
            *target = 1;
    }else{
        if (*target <= 0)
            (*target)--;
        else
            *target = -1;
    }
",,
implicit_predicate,parse-options-cb.c,129,+,-,"if (unset){
    oid_array_clear(opt->value);
    return 0;
}
",,
implicit_predicate,parse-options-cb.c,130,+,-,"if (unset){
    oid_array_clear(opt->value);
    return 0;
}
",,
implicit_predicate,parse-options-cb.c,146,+,-,"if (unset){
    oidcpy(target, null_oid());
    return 0;
}
",,
implicit_predicate,parse-options-cb.c,147,+,-,"if (unset){
    oidcpy(target, null_oid());
    return 0;
}
",,
implicit_predicate,parse-options-cb.c,164,+,+,unset ? 2 : 1,12,	*target = unset ? 2 : 1;
implicit_predicate,parse-options-cb.c,165,+,-,unset ? 2 : 1,,
implicit_predicate,parse-options-cb.c,202,+,-,"if (unset){
    string_list_clear(v, 0);
    return 0;
}
",,
implicit_predicate,parse-options-cb.c,203,+,-,"if (unset){
    string_list_clear(v, 0);
    return 0;
}
",,
implicit_predicate,parse-options-cb.c,218,+,-,"if (unset){
    strvec_clear(v);
    return 0;
}
",,
implicit_predicate,parse-options-cb.c,219,+,-,"if (unset){
    strvec_clear(v);
    return 0;
}
",,
implicit_predicate,parse-options-cb.c,246,+,+,"unset ? ""--no-"" : ""--""",21,"		strbuf_addstr(sb, unset ? ""--no-"" : ""--"");"
implicit_predicate,parse-options-cb.c,247,+,-,"unset ? ""--no-"" : ""--""",,
implicit_predicate,parse-options-cb.c,306,+,-,"if (unset)
    *(enum branch_track*)opt->value = BRANCH_TRACK_NEVER;
else
    if (!arg || !strcmp(arg, ""direct""))
        *(enum branch_track*)opt->value = BRANCH_TRACK_EXPLICIT;
    else
        if (!strcmp(arg, ""inherit""))
            *(enum branch_track*)opt->value = BRANCH_TRACK_INHERIT;
        else
            return error(_(""option `%s' expects \""%s\"" or \""%s\""""), ""--track"", ""direct"", ""inherit"");
",,
implicit_predicate,parse-options-cb.c,307,+,-,"if (unset)
    *(enum branch_track*)opt->value = BRANCH_TRACK_NEVER;
else
    if (!arg || !strcmp(arg, ""direct""))
        *(enum branch_track*)opt->value = BRANCH_TRACK_EXPLICIT;
    else
        if (!strcmp(arg, ""inherit""))
            *(enum branch_track*)opt->value = BRANCH_TRACK_INHERIT;
        else
            return error(_(""option `%s' expects \""%s\"" or \""%s\""""), ""--track"", ""direct"", ""inherit"");
",,
implicit_predicate,parse-options.c,34,+,-,"if (flags & OPT_SHORT)
    strbuf_addf(&sb, ""switch `%c'"", opt->short_name);
else
    if (flags & OPT_UNSET)
        strbuf_addf(&sb, ""option `no-%s'"", opt->long_name);
    else
        if (flags == OPT_LONG)
            strbuf_addf(&sb, ""option `%s'"", opt->long_name);
        else
            BUG(""optname() got unknown flags %d"", flags);
",,
implicit_predicate,parse-options.c,36,+,-,"if (flags & OPT_UNSET)
    strbuf_addf(&sb, ""option `no-%s'"", opt->long_name);
else
    if (flags == OPT_LONG)
        strbuf_addf(&sb, ""option `%s'"", opt->long_name);
    else
        BUG(""optname() got unknown flags %d"", flags);
",,
implicit_predicate,parse-options.c,115,-,+,,24,		*(int *)opt->value = unset ? 0 : *(int *)opt->value + 1;
implicit_predicate,parse-options.c,119,-,+,,24,		*(int *)opt->value = unset ? 0 : opt->defval;
implicit_predicate,parse-options.c,164,-,+,,11,"			return (*opt->callback)(opt, p_arg, p_unset) ? (-1) : 0;"
implicit_predicate,parse-options.c,246,+,-,"if (flags & OPT_SHORT)
    return xstrfmt(""-%c%s"", opt->short_name, arg ? arg : """");
",,
implicit_predicate,parse-options.c,247,-,+,,44,"		return xstrfmt(""-%c%s"", opt->short_name, arg ? arg : """");"
implicit_predicate,parse-options.c,248,+,+,"flags & OPT_UNSET ? ""no-"" : """"",31,"	return xstrfmt(""--%s%s%s%s"", flags & OPT_UNSET ? ""no-"" : """","
implicit_predicate,parse-options.c,249,-,+,,26,"		       opt->long_name, arg ? ""="" : """", arg ? arg : """");"
implicit_predicate,parse-options.c,294,-,+,,13,			p->opt = p->opt[1] ? p->opt + 1 : NULL;
implicit_predicate,parse-options.c,313,-,+,,12,		p->opt = p->opt[len] ? p->opt + len : NULL;
implicit_predicate,parse-options.c,315,-,+,,9,"			rc = (*numopt->callback)(numopt, arg, 0) ? (-1) : 0;"
implicit_predicate,parse-options.c,410,+,-,"if (arg_starts_with_no_no)
    continue;
",,
implicit_predicate,parse-options.c,443,+,-,"(ambiguous.flags & OPT_UNSET) ? ""no-"" : """"",,
implicit_predicate,parse-options.c,445,+,-,"(abbrev.flags & OPT_UNSET) ? ""no-"" : """"",,
implicit_predicate,parse-options.c,1073,+,+,"literal ? ""[=%s]"" : ""[=<%s>]""",8,"			s = literal ? ""[=%s]"" : ""[=<%s>]"";"
implicit_predicate,parse-options.c,1075,+,+,"literal ? ""[%s]"" : ""[<%s>]""",8,"			s = literal ? ""[%s]"" : ""[<%s>]"";"
implicit_predicate,parse-options.c,1077,+,+,"literal ? "" %s"" : "" <%s>""",7,"		s = literal ? "" %s"" : "" <%s>"";"
implicit_predicate,parse-options.c,1078,-,+,,34,"	return utf8_fprintf(outfile, s, opts->argh ? _(opts->argh) : _(""...""));"
implicit_predicate,parse-options.c,1112,+,+,err ? stderr : stdout,18,	FILE *outfile = err ? stderr : stdout;
implicit_predicate,parse-options.c,1175,+,-,"if (saw_empty_line)
    fputc('\n', outfile);
else
    if (!j)
        fprintf_ln(outfile, prefix, line);
    else
        fprintf_ln(outfile, usage_continued, (int)usage_len, """", line);
",,
implicit_predicate,parse-options.c,1207,+,-,"if (need_newline){
    fputc('\n', outfile);
    need_newline = 0;
}
",,
implicit_predicate,parse-options.c,1244,-,+,,13,"		for (cp = opts->help ? _(opts->help) : """"; *cp; cp = np) {"
implicit_predicate,parse-options.c,1308,+,-,"if (opt1)
    options[count++] = opt1_name;
",,
implicit_predicate,parse-options.c,1310,+,-,"if (opt2)
    options[count++] = opt2_name;
",,
implicit_predicate,parse-options.c,1312,+,-,"if (opt3)
    options[count++] = opt3_name;
",,
implicit_predicate,parse-options.c,1314,+,-,"if (opt4)
    options[count++] = opt4_name;
",,
implicit_predicate,parse.c,150,+,-,"if (git_parse_int(value, &v))
    return !!v;
",,
implicit_predicate,patch-delta.c,41,+,-,"if (cmd & 0x80){
    unsigned long cp_off = 0, cp_size = 0;
    PARSE_CP_PARAM(0x01, cp_off, 0);
    PARSE_CP_PARAM(0x02, cp_off, 8);
    PARSE_CP_PARAM(0x04, cp_off, 16);
    PARSE_CP_PARAM(0x08, cp_off, 24);
    PARSE_CP_PARAM(0x10, cp_size, 0);
    PARSE_CP_PARAM(0x20, cp_size, 8);
    PARSE_CP_PARAM(0x40, cp_size, 16);
    if (cp_size == 0)
        cp_size = 0x10000;

    if (unsigned_add_overflows(cp_off, cp_size) || cp_off + cp_size > src_size || cp_size > size)
        goto bad_length;

    memcpy(out, (char*)src_buf + cp_off, cp_size);
    out += cp_size;
    size -= cp_size;
}else
    if (cmd){
        if (cmd > size || cmd > top - data)
            goto bad_length;

        memcpy(out, data, cmd);
        out += cmd;
        data += cmd;
        size -= cmd;
    }else{
        error(""unexpected delta opcode 0"");
        goto bad;
    }
",,
implicit_predicate,patch-delta.c,49,+,-,"PARSE_CP_PARAM(0x01, cp_off, 0);
",,
implicit_predicate,patch-delta.c,50,+,-,"PARSE_CP_PARAM(0x02, cp_off, 8);
",,
implicit_predicate,patch-delta.c,51,+,-,"PARSE_CP_PARAM(0x04, cp_off, 16);
",,
implicit_predicate,patch-delta.c,52,+,-,"PARSE_CP_PARAM(0x08, cp_off, 24);
",,
implicit_predicate,patch-delta.c,53,+,-,"PARSE_CP_PARAM(0x10, cp_size, 0);
",,
implicit_predicate,patch-delta.c,54,+,-,"PARSE_CP_PARAM(0x20, cp_size, 8);
",,
implicit_predicate,patch-delta.c,55,+,-,"PARSE_CP_PARAM(0x40, cp_size, 16);
",,
implicit_predicate,patch-delta.c,65,+,-,"if (cmd){
    if (cmd > size || cmd > top - data)
        goto bad_length;

    memcpy(out, data, cmd);
    out += cmd;
    data += cmd;
    size -= cmd;
}else{
    error(""unexpected delta opcode 0"");
    goto bad;
}
",,
implicit_predicate,patch-id.c,11,+,-,"if (patchlen)
    printf(""%s %s\n"", oid_to_hex(result), oid_to_hex(id));
",,
implicit_predicate,patch-id.c,83,+,-,"if (verbatim)
    the_hash_algo->update_fn(&ctx, line, strlen(line));
",,
implicit_predicate,patch-id.c,107,+,-,"if (stable)
    flush_one_hunk(result, &ctx);
",,
implicit_predicate,patch-id.c,129,+,-,"if (diff_is_binary){
    if (starts_with(line, ""diff "")){
        diff_is_binary = 0;
        before = -1;
    }
    continue;
}
",,
implicit_predicate,patch-id.c,150,+,-,"if (stable)
    flush_one_hunk(result, &ctx);
",,
implicit_predicate,patch-id.c,162,+,+,verbatim ? strlen(line) : remove_space(line),9,		len = verbatim ? strlen(line) : remove_space(line);
implicit_predicate,patch-id.c,234,+,-,"if (config.verbatim)
    config.stable = 1;
",,
implicit_predicate,patch-id.c,240,+,+,opts ? opts > 1 : config.stable,19,"	generate_id_list(opts ? opts > 1 : config.stable,"
implicit_predicate,patch-id.c,241,+,+,opts ? opts == 3 : config.verbatim,5,			 opts ? opts == 3 : config.verbatim);
implicit_predicate,patch-ids.c,102,+,-,"if (init_patch_id_entry(&patch, commit, ids))
    return NULL;
",,
implicit_predicate,patch-ids.c,129,+,-,"if (init_patch_id_entry(key, commit, ids)){
    free(key);
    return NULL;
}
",,
implicit_predicate,path.c,82,+,-,"if (need_sep)
    len--;
",,
implicit_predicate,path.c,83,+,-,"if (need_sep)
    len--;
",,
implicit_predicate,path.c,85,+,-,"if (need_sep)
    buf->buf[newlen] = '/';
",,
implicit_predicate,path.c,86,+,-,"if (need_sep)
    buf->buf[newlen] = '/';
",,
implicit_predicate,path.c,157,+,-,"if (new_node->len){
    new_node->contents = xmalloc(new_node->len);
    memcpy(new_node->contents, key, new_node->len);
}
",,
implicit_predicate,path.c,158,+,-,"if (new_node->len){
    new_node->contents = xmalloc(new_node->len);
    memcpy(new_node->contents, key, new_node->len);
}
",,
implicit_predicate,path.c,194,+,-,"if (child->len){
    child->contents = xstrndup(root->contents + i + 1, child->len);
}
",,
implicit_predicate,path.c,195,+,-,"if (child->len){
    child->contents = xstrndup(root->contents + i + 1, child->len);
}
",,
implicit_predicate,path.c,324,+,-,"if (common_trie_done_setup)
    return;
",,
implicit_predicate,path.c,325,+,-,"if (common_trie_done_setup)
    return;
",,
implicit_predicate,path.c,361,+,-,"if (has_lock_suffix)
    strbuf_addstr(buf, LOCK_SUFFIX);
",,
implicit_predicate,path.c,362,+,-,"if (has_lock_suffix)
    strbuf_addstr(buf, LOCK_SUFFIX);
",,
implicit_predicate,path.c,391,+,-,"if (is_dir_file(base, ""info"", ""grafts""))
    strbuf_splice(buf, 0, buf->len, repo->graft_file, strlen(repo->graft_file));
else
    if (!strcmp(base, ""index""))
        strbuf_splice(buf, 0, buf->len, repo->index_file, strlen(repo->index_file));
    else
        if (dir_prefix(base, ""objects""))
            replace_dir(buf, git_dir_len + 7, repo->objects->odb->path);
        else
            if (git_hooks_path && dir_prefix(base, ""hooks""))
                replace_dir(buf, git_dir_len + 5, git_hooks_path);
            else
                if (repo->different_commondir)
                    update_common_dir(buf, git_dir_len, repo->commondir);
",,
implicit_predicate,path.c,392,+,-,"if (is_dir_file(base, ""info"", ""grafts""))
    strbuf_splice(buf, 0, buf->len, repo->graft_file, strlen(repo->graft_file));
else
    if (!strcmp(base, ""index""))
        strbuf_splice(buf, 0, buf->len, repo->index_file, strlen(repo->index_file));
    else
        if (dir_prefix(base, ""objects""))
            replace_dir(buf, git_dir_len + 7, repo->objects->odb->path);
        else
            if (git_hooks_path && dir_prefix(base, ""hooks""))
                replace_dir(buf, git_dir_len + 5, git_hooks_path);
            else
                if (repo->different_commondir)
                    update_common_dir(buf, git_dir_len, repo->commondir);
",,
implicit_predicate,path.c,397,+,-,"if (dir_prefix(base, ""objects""))
    replace_dir(buf, git_dir_len + 7, repo->objects->odb->path);
else
    if (git_hooks_path && dir_prefix(base, ""hooks""))
        replace_dir(buf, git_dir_len + 5, git_hooks_path);
    else
        if (repo->different_commondir)
            update_common_dir(buf, git_dir_len, repo->commondir);
",,
implicit_predicate,path.c,398,+,-,"if (dir_prefix(base, ""objects""))
    replace_dir(buf, git_dir_len + 7, repo->objects->odb->path);
else
    if (git_hooks_path && dir_prefix(base, ""hooks""))
        replace_dir(buf, git_dir_len + 5, git_hooks_path);
    else
        if (repo->different_commondir)
            update_common_dir(buf, git_dir_len, repo->commondir);
",,
implicit_predicate,path.c,572,+,-,"if (ret)
    goto cleanup;
",,
implicit_predicate,path.c,573,+,-,"if (ret)
    goto cleanup;
",,
implicit_predicate,path.c,598,+,-,"if (err){
    strbuf_release(&buf);
    return NULL;
}
",,
implicit_predicate,path.c,599,+,-,"if (err){
    strbuf_release(&buf);
    return NULL;
}
",,
implicit_predicate,path.c,686,+,-,"if (real_home)
    strbuf_add_real_path(&user_path, home);
else
    strbuf_addstr(&user_path, home);
",,
implicit_predicate,path.c,739,+,-,"if (real_home)
    strbuf_add_real_path(&user_path, home);
else
    strbuf_addstr(&user_path, home);
",,
implicit_predicate,path.c,899,+,-,"if (have_same_root(in, prefix))
    i = j = has_dos_drive_prefix(in);
else{
    return in;
}
",,
implicit_predicate,path.c,941,-,+,,15,	int in_len = in ? strlen(in) : 0;
implicit_predicate,path.c,942,-,+,,19,	int prefix_len = prefix ? strlen(prefix) : 0;
implicit_predicate,path.c,952,+,-,"if (have_same_root(in, prefix))
    i = j = has_dos_drive_prefix(in);
else{
    return in;
}
",,
implicit_predicate,path.c,1227,+,-,"while (suffix_len){
    if (!path_len)
        return -1;

    if (is_dir_sep(path[path_len - 1])){
        if (!is_dir_sep(suffix[suffix_len - 1]))
            return -1;

        path_len = chomp_trailing_dir_sep(path, path_len);
        suffix_len = chomp_trailing_dir_sep(suffix, suffix_len);
    }else
        if (path[--path_len] != suffix[--suffix_len])
            return -1;
}
",,
implicit_predicate,path.c,1280,+,-,"while (suffix_len){
    if (!path_len)
        return -1;

    if (is_dir_sep(path[path_len - 1])){
        if (!is_dir_sep(suffix[suffix_len - 1]))
            return -1;

        path_len = chomp_trailing_dir_sep(path, path_len);
        suffix_len = chomp_trailing_dir_sep(suffix, suffix_len);
    }else
        if (path[--path_len] != suffix[--suffix_len])
            return -1;
}
",,
implicit_predicate,path.c,1285,+,-,"while (1){
    char ch = *p++;
    if (sl){
        if (ch == '.')
            ndot++;
        else
            if (ch == '/'){
                if (ndot < 3)
                    return -1;

                ndot = 0;
            }else
                if (ch == 0){
                    if (0 < ndot && ndot < 3)
                        return -1;

                    return 0;
                }else
                    sl = ndot = 0;
    }else
        if (ch == 0)
            return 0;
        else
            if (ch == '/'){
                sl = 1;
                ndot = 0;
            }
}
",,
implicit_predicate,path.c,1287,+,-,"if (sl){
    if (ch == '.')
        ndot++;
    else
        if (ch == '/'){
            if (ndot < 3)
                return -1;

            ndot = 0;
        }else
            if (ch == 0){
                if (0 < ndot && ndot < 3)
                    return -1;

                return 0;
            }else
                sl = ndot = 0;
}else
    if (ch == 0)
        return 0;
    else
        if (ch == '/'){
            sl = 1;
            ndot = 0;
        }
",,
implicit_predicate,path.c,1338,+,-,"while (1){
    char ch = *p++;
    if (sl){
        if (ch == '.')
            ndot++;
        else
            if (ch == '/'){
                if (ndot < 3)
                    return -1;

                ndot = 0;
            }else
                if (ch == 0){
                    if (0 < ndot && ndot < 3)
                        return -1;

                    return 0;
                }else
                    sl = ndot = 0;
    }else
        if (ch == 0)
            return 0;
        else
            if (ch == '/'){
                sl = 1;
                ndot = 0;
            }
}
",,
implicit_predicate,path.c,1340,+,-,"if (sl){
    if (ch == '.')
        ndot++;
    else
        if (ch == '/'){
            if (ndot < 3)
                return -1;

            ndot = 0;
        }else
            if (ch == 0){
                if (0 < ndot && ndot < 3)
                    return -1;

                return 0;
            }else
                sl = ndot = 0;
}else
    if (ch == 0)
        return 0;
    else
        if (ch == '/'){
            sl = 1;
            ndot = 0;
        }
",,
implicit_predicate,path.c,1424,+,-,"if (saw_tilde){
    if (name[i] < '0' || name[i] > '9')
        return 0;
}else
    if (name[i] == '~'){
        if (name[++i] < '1' || name[i] > '9')
            return 0;

        saw_tilde = 1;
    }else
        if (i >= 6)
            return 0;
        else
            if (name[i] & 0x80){
                return 0;
            }else
                if (tolower(name[i]) != dotgit_ntfs_shortname_prefix[i])
                    return 0;
",,
implicit_predicate,path.c,1477,+,-,"if (saw_tilde){
    if (name[i] < '0' || name[i] > '9')
        return 0;
}else
    if (name[i] == '~'){
        if (name[++i] < '1' || name[i] > '9')
            return 0;

        saw_tilde = 1;
    }else
        if (i >= 6)
            return 0;
        else
            if (name[i] & 0x80){
                return 0;
            }else
                if (tolower(name[i]) != dotgit_ntfs_shortname_prefix[i])
                    return 0;
",,
implicit_predicate,pathspec.c,183,+,-,"if (invalid_value_char(*src))
    die(""cannot use '%c' for value matching"", *src);
",,
implicit_predicate,pathspec.c,300,+,-,"if (get_literal_global())
    global_magic |= PATHSPEC_LITERAL;
",,
implicit_predicate,pathspec.c,310,+,-,"if (get_icase_global())
    global_magic |= PATHSPEC_ICASE;
",,
implicit_predicate,pathspec.c,599,-,+,,22,	const char *entry = argv ? *argv : NULL;
implicit_predicate,pathspec.c,643,-,+,,14,	prefixlen = prefix ? strlen(prefix) : 0;
implicit_predicate,pathspec.c,687,+,+,nul_term_line ? strbuf_getline_nul : strbuf_getline,33,"	strbuf_getline_fn getline_fn = nul_term_line ? strbuf_getline_nul :
						       strbuf_getline;"
implicit_predicate,pkt-line.c,23,-,+,,9,"	return in_async() ? ""sideband"" : packet_trace_prefix;"
implicit_predicate,pkt-line.c,49,+,-,"if (in_pack){
    if (packet_trace_pack(buf, len, sideband))
        return;
}else
    if (starts_with(buf, ""PACK"") || starts_with(buf, ""\1PACK"")){
        in_pack = 1;
        sideband = *buf == '\1';
        packet_trace_pack(buf, len, sideband);
        buf = ""PACK ..."";
        len = strlen(buf);
    }
",,
implicit_predicate,pkt-line.c,50,+,-,"if (packet_trace_pack(buf, len, sideband))
    return;
",,
implicit_predicate,pkt-line.c,72,+,+,write ? '>' : '<',27,"		    get_trace_prefix(), write ? '>' : '<');"
implicit_predicate,pkt-line.c,584,+,-,"while (1){
    int status = packet_read_with_status(in_stream, NULL, NULL, buf, LARGE_PACKET_MAX, &len, PACKET_READ_GENTLE_ON_EOF);
    if (!demultiplex_sideband(me, status, buf, len, 0, &scratch, &sideband_type))
        continue;

    switch (sideband_type){
        case SIDEBAND_PRIMARY:
            write_or_die(out, buf + 1, len - 1);
            break;
        default:
            if (scratch.len > 0)
                BUG(""unhandled incomplete sideband: '%s'"", scratch.buf);

            return sideband_type;
    }
}
",,
implicit_predicate,pkt-line.c,637,+,-,"while (1){
    enum sideband_type sideband_type;
    reader->status = packet_read_with_status(reader->fd, &reader->src_buffer, &reader->src_len, reader->buffer, reader->buffer_size, &reader->pktlen, reader->options);
    if (!reader->use_sideband)
        break;

    if (demultiplex_sideband(reader->me, reader->status, reader->buffer, reader->pktlen, 1, &reader->scratch, &sideband_type))
        break;
}
",,
implicit_predicate,pkt-line.c,656,-,+,,18,"		reader->line = reader->use_sideband ?
			reader->buffer + 1 : reader->buffer;"
implicit_predicate,pkt-line.c,688,-,+,,7,"			   writer->use_sideband ? ""\001"" : """", fmt, args);"
implicit_predicate,pkt-line.c,698,-,+,,7,"			   writer->use_sideband ? ""\003"" : ""ERR "", fmt, args);"
implicit_predicate,poll.c,413,+,-,"if (happened){
    pfd[i].revents = happened;
    rc++;
}else{
    pfd[i].revents = 0;
}
",,
implicit_predicate,preload-index.c,149,+,-,"if (err)
    die(_(""unable to create threaded lstat: %s""), strerror(err));
",,
implicit_predicate,pretty.c,54,+,-,"if (is_tformat)
    rev->use_terminator = 1;
",,
implicit_predicate,pretty.c,241,+,-,"if (non_ascii(ch))
    return 1;
",,
implicit_predicate,pretty.c,273,+,-,"if (is_rfc822_special(s[i]))
    return 1;
",,
implicit_predicate,pretty.c,406,+,+,"is_special ? ""=%02X"" : ""%c""",29,"		const char *encoded_fmt = is_special ? ""=%02X""    : ""%c"";"
implicit_predicate,pretty.c,407,+,+,is_special ? 3 * chrlen : 1,25,		int	    encoded_len = is_special ? 3 * chrlen : 1;
implicit_predicate,pretty.c,487,+,-,"if (eflags)
    strbuf_add_with_color(sb, line_color, buf, eol - buf);
else{
    end:
    strbuf_add(sb, buf, eol - buf);
}
",,
implicit_predicate,pretty.c,572,-,+,,26,		struct grep_opt *opt = pp->rev ? &pp->rev->grep_filter : NULL;
implicit_predicate,pretty.c,662,-,+,,9,"	return v ? xmemdupz(v, len) : NULL;"
implicit_predicate,pretty.c,715,-,+,,17,	use_encoding = encoding ? encoding : utf8;
implicit_predicate,pretty.c,762,-,+,,9,	return out ? out : msg;
implicit_predicate,pretty.c,943,+,-,"if (istitlechar(msg[i])){
    if (space == 1)
        strbuf_addch(sb, '-');

    space = 0;
    strbuf_addch(sb, msg[i]);
    if (msg[i] == '.')
        while (msg[i + 1] == '.')
            i++;
}else
    space |= 1;
",,
implicit_predicate,pretty.c,1154,+,-,"if (to_column)
    width += term_columns();
",,
implicit_predicate,pretty.c,1159,+,+,to_column ? -width : width,16,		c->padding = to_column ? -width : width;
implicit_predicate,pretty.c,1348,+,-,"if (match_placeholder_bool_arg(arg, option[i].name, &arg, &optval)){
    if (optval)
        strvec_pushf(args, ""--%s"", option[i].name);
    else
        strvec_pushf(args, ""--no-%s"", option[i].name);

    found = 1;
}
",,
implicit_predicate,pretty.c,1349,+,-,"if (optval)
    strvec_pushf(args, ""--%s"", option[i].name);
else
    strvec_pushf(args, ""--no-%s"", option[i].name);
",,
implicit_predicate,pretty.c,1451,+,-,"if (ret)
    c->auto_color = 0;
",,
implicit_predicate,pretty.c,1791,+,-,"while (1){
    int modifier = *placeholder == 'C';
    size_t consumed = format_commit_one(&local_sb, placeholder, c);
    total_consumed += consumed;
    if (!modifier)
        break;

    placeholder += consumed;
    if (*placeholder != '%')
        break;

    placeholder++;
    total_consumed++;
}
",,
implicit_predicate,pretty.c,2091,-,+,,5,"				pp->preserve_subject ? ""\n"" : "" "");"
implicit_predicate,pretty.c,2203,-,+,,25,	struct grep_opt *opt = pp->rev ? &pp->rev->grep_filter : NULL;
implicit_predicate,pretty.c,2230,-,+,,25,	struct grep_opt *opt = pp->rev ? &pp->rev->grep_filter : NULL;
implicit_predicate,pretty.c,2241,+,-,"if (is_blank_line(line, &linelen)){
    if (first)
        continue;

    if (pp->fmt == CMIT_FMT_SHORT)
        break;
}
",,
implicit_predicate,pretty.c,2242,+,-,"if (first)
    continue;
",,
implicit_predicate,pretty.c,2250,+,-,"if (indent)
    pp_handle_indent(pp, sb, indent, line, linelen);
else
    if (pp->expand_tabs_in_log)
        strbuf_add_tabexpand(sb, opt, pp->color, pp->expand_tabs_in_log, line, linelen);
    else{
        if (pp->fmt == CMIT_FMT_MBOXRD && is_mboxrd_from(line, linelen))
            strbuf_addch(sb, '>');

        append_line_with_color(sb, opt, line, linelen, pp->color, GREP_CONTEXT_BODY, GREP_HEADER_FIELD_MAX);
    }
",,
implicit_predicate,pretty.c,2300,+,-,"for (in_body = i = 0;(ch = msg[i]);i++){
    if (!in_body){
        if (ch == '\n' && msg[i + 1] == '\n')
            in_body = 1;
    }else
        if (non_ascii(ch)){
            need_8bit_cte = 1;
            break;
        }
}
",,
implicit_predicate,pretty.c,2309,+,-,"if (non_ascii(ch)){
    need_8bit_cte = 1;
    break;
}
",,
implicit_predicate,prio-queue.c,49,+,-,"for (ix = queue->nr - 1;ix;ix = parent){
    parent = (ix - 1) / 2;
    if (compare(queue, parent, ix) <= 0)
        break;

    swap(queue, parent, ix);
}
",,
implicit_predicate,procinfo.c,143,+,-,"if (ppid)
    push_ancestry_name(names, ppid);
",,
implicit_predicate,progress.c,74,+,-,"if (progress_testing)
    return;
",,
implicit_predicate,progress.c,95,+,-,"if (progress_testing)
    return;
",,
implicit_predicate,progress.c,120,-,+,,7,"	tp = (progress->throughput) ? progress->throughput->display.buf : """";"
implicit_predicate,progress.c,139,+,-,"if (show_update){
    if (is_foreground_fd(fileno(stderr)) || done){
        const char* eol = done ? done : ""\r"";
        size_t clear_len = counters_sb->len < last_count_len ? last_count_len - counters_sb->len + 1 : 0;
        size_t progress_line_len = progress->title_len + counters_sb->len + 2;
        int cols = term_columns();
        if (progress->split){
            fprintf(stderr, ""  %s%*s"", counters_sb->buf, (int)clear_len, eol);
        }else
            if (!done && cols < progress_line_len){
                clear_len = progress->title_len + 1 < cols ? cols - progress->title_len - 1 : 0;
                fprintf(stderr, ""%s:%*s\n  %s%s"", progress->title, (int)clear_len, """", counters_sb->buf, eol);
                progress->split = 1;
            }else{
                fprintf(stderr, ""%s: %s%*s"", progress->title, counters_sb->buf, (int)clear_len, eol);
            }

        fflush (stderr);
    }
    progress_update = 0;
}
",,
implicit_predicate,progress.c,141,-,+,,22,"			const char *eol = done ? done : ""\r"";"
implicit_predicate,progress.c,150,+,-,"if (progress->split){
    fprintf(stderr, ""  %s%*s"", counters_sb->buf, (int)clear_len, eol);
}else
    if (!done && cols < progress_line_len){
        clear_len = progress->title_len + 1 < cols ? cols - progress->title_len - 1 : 0;
        fprintf(stderr, ""%s:%*s\n  %s%s"", progress->title, (int)clear_len, """", counters_sb->buf, eol);
        progress->split = 1;
    }else{
        fprintf(stderr, ""%s: %s%*s"", progress->title, counters_sb->buf, (int)clear_len, eol);
    }
",,
implicit_predicate,progress.c,182,+,-,"if (progress_testing)
    return progress->start_ns + progress_test_ns;
else
    return getnanotime();
",,
implicit_predicate,progress.c,330,+,+,misecs ? misecs : 1,28,		rate = tp->curr_total / (misecs ? misecs : 1);
implicit_predicate,promisor-remote.c,59,-,+,,9,	return finish_command(&child) ? -1 : 0;
implicit_predicate,promisor-remote.c,107,-,+,,23,		config->promisors = r->next ? r->next : r;
implicit_predicate,promisor-remote.c,233,+,-,"if (remaining_nr){
    int j = 0;
    CALLOC_ARRAY(new_oids, remaining_nr);
    for (i = 0;i < oid_nr;i++)
        if (remaining[i])
            oidcpy(&new_oids[j++], &old_oids[i]);
    *oids = new_oids;
    if (to_free)
        free(old_oids);
}
",,
implicit_predicate,promisor-remote.c,237,+,-,"if (remaining[i])
    oidcpy(&new_oids[j++], &old_oids[i]);
",,
implicit_predicate,promisor-remote.c,240,+,-,"if (to_free)
    free(old_oids);
",,
implicit_predicate,promisor-remote.c,270,+,-,"if (remaining_nr){
    to_free = 1;
    continue;
}
",,
implicit_predicate,promisor-remote.c,285,+,-,"if (to_free)
    free(remaining_oids);
",,
implicit_predicate,prompt.c,32,+,-,"if (err){
    error(""unable to read askpass response from '%s'"", cmd);
    strbuf_release(&buffer);
    return NULL;
}
",,
implicit_predicate,protocol-caps.c,47,+,-,"if (info->size)
    packet_writer_write(writer, ""size"");
",,
implicit_predicate,protocol-caps.c,65,+,-,"if (info->size){
    if (oid_object_info(r, &oid, &object_size) < 0){
        strbuf_addstr(&send_buffer, "" "");
    }else{
        strbuf_addf(&send_buffer, "" %lu"", object_size);
    }
}
",,
implicit_predicate,prune-packed.c,13,-,+,,13,	int opts = isatty(2) ? PRUNE_PACKED_VERBOSE : 0;
implicit_predicate,prune.c,60,+,-,"if (initialized)
    return;
",,
implicit_predicate,prune.c,63,+,-,"if (show_progress)
    progress = start_delayed_progress(_(""Checking connectivity""), 0);
",,
implicit_predicate,prune.c,87,+,-,"if (is_object_reachable(oid, revs))
    return 0;
",,
implicit_predicate,prune.c,176,+,-,"while (argc--){
    struct object_id oid;
    const char* name = *argv++;
    if (!repo_get_oid(the_repository, name, &oid)){
        struct object* object = parse_object_or_die(&oid, name);
        add_pending_object(&revs, object, """");
    }else
        die(""unrecognized argument: %s"", name);
}
",,
implicit_predicate,prune.c,191,+,-,"if (exclude_promisor_objects){
    fetch_if_missing = 0;
    revs.exclude_promisor_objects = 1;
}
",,
implicit_predicate,prune.c,199,+,+,show_only ? PRUNE_PACKED_DRY_RUN : 0,23,	prune_packed_objects(show_only ? PRUNE_PACKED_DRY_RUN : 0);
implicit_predicate,prune.c,207,+,+,show_only ? PRUNE_SHOW_ONLY : 0,17,		prune_shallow(show_only ? PRUNE_SHOW_ONLY : 0);
implicit_predicate,pull.c,45,+,-,"if (fatal)
    die(_(""invalid value for '%s': '%s'""), key, value);
else
    error(_(""invalid value for '%s': '%s'""), key, value);
",,
implicit_predicate,pull.c,63,+,+,unset ? REBASE_FALSE : REBASE_TRUE,12,		*value = unset ? REBASE_FALSE : REBASE_TRUE;
implicit_predicate,pull.c,290,+,-,"if (i)
    strbuf_addch(&msg, ' ');
",,
implicit_predicate,pull.c,368,-,+,,24,"		recurse_submodules = git_config_bool(var, value) ?
			RECURSE_SUBMODULES_ON : RECURSE_SUBMODULES_OFF;"
implicit_predicate,pull.c,442,-,+,,23,	const char *remote = curr_branch ? curr_branch->remote_name : NULL;
implicit_predicate,pull.c,551,+,-,"if (opt_dry_run)
    strvec_push(&cmd.args, ""--dry-run"");
",,
implicit_predicate,pull.c,797,+,-,"if (ret)
    goto cleanup;
",,
implicit_predicate,pull.c,801,+,-,"if (ret)
    goto cleanup;
",,
implicit_predicate,pull.c,806,+,+,ret ? -1 : 0,9,	return ret ? -1 : 0;
implicit_predicate,pull.c,1055,+,-,"if (get_rebase_fork_point(&rebase_fork_point, repo, *refspecs))
    oidclr(&rebase_fork_point);
",,
implicit_predicate,pull.c,1059,+,-,"if (run_fetch(repo, refspecs))
    return 1;
",,
implicit_predicate,pull.c,1062,+,-,"if (opt_dry_run)
    return 0;
",,
implicit_predicate,pull.c,1115,+,-,"if (divergent)
    die_ff_impossible();
",,
implicit_predicate,pull.c,1136,+,-,"if (can_ff){
    opt_ff = ""--ff-only"";
    ret = run_merge();
}else{
    ret = run_rebase(&newbase, &upstream);
}
",,
implicit_predicate,push.c,80,-,+,,6,"					query.force ? ""+"" : """","
implicit_predicate,push.c,111,+,-,"if (deleterefs)
    refspec_appendf(&rs, "":refs/tags/%s"", ref);
else
    refspec_appendf(&rs, ""refs/tags/%s"", ref);
",,
implicit_predicate,push.c,115,+,-,"if (deleterefs){
    if (strchr(ref, ':') || !*ref)
        die(_(""--delete only accepts plain target ref names""));

    refspec_appendf(&rs, "":%s"", ref);
}else
    if (!strchr(ref, ':')){
        struct ref* matched = NULL;
        if (!local_refs)
            local_refs = get_local_heads();

        if (count_refspec_match(ref, local_refs, &matched) != 1){
            refspec_append(&rs, ref);
        }else{
            if (!remote)
                remote = remote_get(repo);

            if (!remote)
                BUG(""must get a remote for repo '%s'"", repo);

            refspec_append_mapped(&rs, ref, remote, matched);
        }
    }else
        refspec_append(&rs, ref);
",,
implicit_predicate,push.c,389,+,+,"thin ? ""yes"" : NULL",50,"	transport_set_option(transport, TRANS_OPT_THIN, thin ? ""yes"" : NULL);"
implicit_predicate,push.c,452,+,-,"if (url_nr){
    for (i = 0;i < url_nr;i++){
        struct transport* transport = transport_get(remote, url[i]);
        if (flags & TRANSPORT_PUSH_OPTIONS)
            transport->push_options = push_options;

        if (push_with_options(transport, push_refspec, flags))
            errs++;
    }
}else{
    struct transport* transport = transport_get(remote, NULL);
    if (flags & TRANSPORT_PUSH_OPTIONS)
        transport->push_options = push_options;

    if (push_with_options(transport, push_refspec, flags))
        errs++;
}
",,
implicit_predicate,push.c,458,+,-,"if (push_with_options(transport, push_refspec, flags))
    errs++;
",,
implicit_predicate,push.c,466,+,-,"if (push_with_options(transport, push_refspec, flags))
    errs++;
",,
implicit_predicate,push.c,477,+,-,"if (unset)
    *recurse_submodules = RECURSE_SUBMODULES_OFF;
else{
    if (!strcmp(arg, ""only-is-on-demand"")){
        if (*recurse_submodules == RECURSE_SUBMODULES_ONLY){
            warning(_(""recursing into submodule with push.recurseSubmodules=only; using on-demand instead""));
            *recurse_submodules = RECURSE_SUBMODULES_ON_DEMAND;
        }
    }else{
        *recurse_submodules = parse_push_recurse_submodules_arg(opt->long_name, arg);
    }
}
",,
implicit_predicate,push.c,544,-,+,,13,"		int val = git_config_bool(k, v) ?
			RECURSE_SUBMODULES_ON_DEMAND : RECURSE_SUBMODULES_OFF;"
implicit_predicate,push.c,631,-,+,,18,"	push_options = (push_options_cmdline.nr
		? &push_options_cmdline
		: &push_options_config);"
implicit_predicate,push.c,650,+,-,"if (tags)
    refspec_append(&rs, ""refs/tags/*"");
",,
implicit_predicate,quote.c,38,+,-,"while (need_bs_quote(*src)){
    strbuf_addstr(dst, ""'\\"");
    strbuf_addch(dst, *src++);
    strbuf_addch(dst, '\'');
}
",,
implicit_predicate,quote.c,294,+,-,"EMIT('""');
",,
implicit_predicate,quote.c,296,+,-,"EMITBUF(p, len);
",,
implicit_predicate,quote.c,297,+,-,"EMIT('\\');
",,
implicit_predicate,quote.c,303,+,-,"EMIT(cq_lookup[ch]);
",,
implicit_predicate,quote.c,305,+,-,"EMIT(((ch >> 6) & 03) + '0');
",,
implicit_predicate,quote.c,306,+,-,"EMIT(((ch >> 3) & 07) + '0');
",,
implicit_predicate,quote.c,307,+,-,"EMIT(((ch >> 0) & 07) + '0');
",,
implicit_predicate,quote.c,311,+,-,"EMITBUF(p, len);
",,
implicit_predicate,quote.c,316,+,-,"EMIT('""');
",,
implicit_predicate,quote.c,345,+,-,"if (terminator){
    quote_c_style(name, NULL, fp, 0);
}else{
    fputs(name, fp);
}
",,
implicit_predicate,quote.c,378,+,-,"if (force_dq)
    strbuf_addch(out, '""');
",,
implicit_predicate,quote.c,381,+,+,force_dq ? CQUOTE_NODQ : 0,10,			      force_dq ? CQUOTE_NODQ : 0);
implicit_predicate,quote.c,382,+,-,"if (force_dq)
    strbuf_addch(out, '""');
",,
implicit_predicate,quote.c,468,+,-,"while ((c = *src++)){
    if (c == sq || c == bq)
        strbuf_addch(sb, bq);

    strbuf_addch(sb, c);
}
",,
implicit_predicate,quote.c,501,+,-,"while ((c = *src++)){
    if (c == nl){
        strbuf_addch(sb, bq);
        strbuf_addch(sb, 'n');
        continue;
    }
    if (c == sq || c == bq)
        strbuf_addch(sb, bq);

    strbuf_addch(sb, c);
}
",,
implicit_predicate,quote.c,519,+,-,"while ((c = *src++)){
    switch (c){
        case '[':
        case ']':
        case '{':
        case '}':
        case '$':
        case '\\':
        case '""':
            strbuf_addch(sb, '\\');
        default:
            strbuf_addch(sb, c);
            break;
        case '\f':
            strbuf_addstr(sb, ""\\f"");
            break;
        case '\r':
            strbuf_addstr(sb, ""\\r"");
            break;
        case '\n':
            strbuf_addstr(sb, ""\\n"");
            break;
        case '\t':
            strbuf_addstr(sb, ""\\t"");
            break;
        case '\v':
            strbuf_addstr(sb, ""\\v"");
            break;
    }
}
",,
implicit_predicate,quote.c,562,+,-,"while ((c = *src++)){
    switch (c){
        case '[':
        case '.':
        case '\\':
        case '*':
            strbuf_addch(sb, '\\');
            strbuf_addch(sb, c);
            break;
        case '$':
            if (*src == '\0')
                strbuf_addch(sb, '\\');

            strbuf_addch(sb, c);
            break;
        default:
            strbuf_addch(sb, c);
            break;
    }
}
",,
implicit_predicate,range-diff.c,166,+,-,"if (in_header){
    if (starts_with(line, ""Author: "")){
        strbuf_addstr(&buf, "" ## Metadata ##\n"");
        strbuf_addstr(&buf, line);
        strbuf_addstr(&buf, ""\n\n"");
        strbuf_addstr(&buf, "" ## Commit message ##\n"");
    }else
        if (starts_with(line, ""Notes"") && line[strlen(line) - 1] == ':'){
            strbuf_addstr(&buf, ""\n\n"");
            strbuf_addf(&buf, "" ## %.*s ##\n"", (int)(strlen(line) - 1), line);
        }else
            if (starts_with(line, ""    "")){
                p = line + len - 2;
                while (isspace(*p) && p >= line)
                    p--;
                strbuf_add(&buf, line, p - line + 1);
                strbuf_addch(&buf, '\n');
            }

    continue;
}else
    if (skip_prefix(line, ""@@ "", &p)){
        p = strstr(p, ""@@"");
        strbuf_addstr(&buf, ""@@"");
        if (current_filename && p[2])
            strbuf_addf(&buf, "" %s:"", current_filename);

        if (p)
            strbuf_addstr(&buf, p + 2);
    }else
        if (!line[0])
            continue;
        else
            if (line[0] == '>'){
                strbuf_addch(&buf, '+');
                strbuf_addstr(&buf, line + 1);
            }else
                if (line[0] == '<'){
                    strbuf_addch(&buf, '-');
                    strbuf_addstr(&buf, line + 1);
                }else
                    if (line[0] == '#'){
                        strbuf_addch(&buf, ' ');
                        strbuf_addstr(&buf, line + 1);
                    }else{
                        strbuf_addch(&buf, ' ');
                        strbuf_addstr(&buf, line);
                    }
",,
implicit_predicate,range-diff.c,240,-,+,,25,"	return strcmp(a->diff, keydata ? keydata : b->diff);"
implicit_predicate,range-diff.c,386,-,+,,26,	struct object_id *oid = a_util ? &a_util->oid : &b_util->oid;
implicit_predicate,reachable.c,173,+,-,"if (ret)
    die(_(""unable to enumerate additional recent objects""));
",,
implicit_predicate,reachable.c,318,+,-,"if (r)
    goto done;
",,
implicit_predicate,reachable.c,322,+,-,"if (ignore_in_core_kept_packs)
    flags |= FOR_EACH_OBJECT_SKIP_IN_CORE_KEPT_PACKS;
",,
implicit_predicate,reachable.c,377,+,-,"if (mark_reflog)
    add_reflogs_to_pending(revs, 0);
",,
implicit_predicate,read-cache.c,204,+,+,has_symlinks ? S_IFLNK : (S_IFREG | 0644),10,		return has_symlinks ? S_IFLNK : (S_IFREG | 0644);
implicit_predicate,read-cache.c,206,+,+,trust_executable_bit ? 0755 : 0644,26,		return (ce->ce_mode & (trust_executable_bit ? 0755 : 0644)) | S_IFREG;
implicit_predicate,read-cache.c,285,+,-,"if (ce_compare_data(istate, ce, st))
    return DATA_CHANGED;
",,
implicit_predicate,read-cache.c,286,+,-,"if (ce_compare_data(istate, ce, st))
    return DATA_CHANGED;
",,
implicit_predicate,read-cache.c,294,+,+,ce_compare_gitlink(ce) ? DATA_CHANGED : 0,11,			return ce_compare_gitlink(ce) ? DATA_CHANGED : 0;
implicit_predicate,read-cache.c,295,+,-,ce_compare_gitlink(ce) ? DATA_CHANGED : 0,,
implicit_predicate,read-cache.c,328,+,-,"if (ce_compare_gitlink(ce))
    changed |= DATA_CHANGED;
",,
implicit_predicate,read-cache.c,329,+,-,"if (ce_compare_gitlink(ce))
    changed |= DATA_CHANGED;
",,
implicit_predicate,read-cache.c,371,+,-,"if (is_racy_stat(istate, sd))
    return MTIME_CHANGED;
",,
implicit_predicate,read-cache.c,372,+,-,"if (is_racy_stat(istate, sd))
    return MTIME_CHANGED;
",,
implicit_predicate,read-cache.c,428,+,-,"if (assume_racy_is_modified)
    changed |= DATA_CHANGED;
else
    changed |= ce_modified_check_fs(istate, ce, st);
",,
implicit_predicate,read-cache.c,429,+,-,"if (assume_racy_is_modified)
    changed |= DATA_CHANGED;
else
    changed |= ce_modified_check_fs(istate, ce, st);
",,
implicit_predicate,read-cache.c,472,+,-,"if (changed_fs)
    return changed | changed_fs;
",,
implicit_predicate,read-cache.c,473,+,-,"if (changed_fs)
    return changed | changed_fs;
",,
implicit_predicate,read-cache.c,483,+,-,"if (cmp)
    return cmp;
",,
implicit_predicate,read-cache.c,484,+,-,"if (cmp)
    return cmp;
",,
implicit_predicate,read-cache.c,591,+,-,"if (invalidate){
    cache_tree_invalidate_path(istate, ce_array[i]->name);
    untracked_cache_remove_from_index(istate, ce_array[i]->name);
}
",,
implicit_predicate,read-cache.c,592,+,-,"if (invalidate){
    cache_tree_invalidate_path(istate, ce_array[i]->name);
    untracked_cache_remove_from_index(istate, ce_array[i]->name);
}
",,
implicit_predicate,read-cache.c,702,+,+,intent_only ? ADD_CACHE_NEW_ONLY : 0,7,			  (intent_only ? ADD_CACHE_NEW_ONLY : 0));
implicit_predicate,read-cache.c,703,+,+,intent_only ? ADD_CACHE_NEW_ONLY : 0,24,	unsigned hash_flags = pretend ? 0 : HASH_WRITE_OBJECT;
implicit_predicate,read-cache.c,704,+,-,pretend ? 0 : HASH_WRITE_OBJECT,,
implicit_predicate,read-cache.c,782,+,-,"if (pretend)
    discard_cache_entry(ce);
else
    if (add_index_entry(istate, ce, add_option)){
        discard_cache_entry(ce);
        return error(_(""unable to add '%s' to index""), path);
    }
",,
implicit_predicate,read-cache.c,783,+,-,"if (pretend)
    discard_cache_entry(ce);
else
    if (add_index_entry(istate, ce, add_option)){
        discard_cache_entry(ce);
        return error(_(""unable to add '%s' to index""), path);
    }
",,
implicit_predicate,read-cache.c,1391,+,-,"if (ignore_missing)
    return ce;
",,
implicit_predicate,read-cache.c,1392,+,-,"if (ignore_missing)
    return ce;
",,
implicit_predicate,read-cache.c,1438,+,-,"if (ie_modified(istate, ce, &st, options)){
    if (err)
        *err = EINVAL;

    return NULL;
}
",,
implicit_predicate,read-cache.c,1439,+,-,"if (ie_modified(istate, ce, &st, options)){
    if (err)
        *err = EINVAL;

    return NULL;
}
",,
implicit_predicate,read-cache.c,1508,+,+,really ? CE_MATCH_IGNORE_VALID : 0,6,				(really ? CE_MATCH_IGNORE_VALID : 0) |
implicit_predicate,read-cache.c,1509,+,+,really ? CE_MATCH_IGNORE_VALID : 0,6,				(not_new ? CE_MATCH_IGNORE_MISSING : 0));
implicit_predicate,read-cache.c,1510,+,-,not_new ? CE_MATCH_IGNORE_MISSING : 0,,
implicit_predicate,read-cache.c,1524,+,+,"in_porcelain ? ""M\t%s\n"" : ""%s: needs update\n""",19,"	modified_fmt   = in_porcelain ? ""M\t%s\n"" : ""%s: needs update\n"";"
implicit_predicate,read-cache.c,1525,+,+,"in_porcelain ? ""M\t%s\n"" : ""%s: needs update\n""",19,"	deleted_fmt    = in_porcelain ? ""D\t%s\n"" : ""%s: needs update\n"";"
implicit_predicate,read-cache.c,1526,+,+,"in_porcelain ? ""D\t%s\n"" : ""%s: needs update\n""",19,"	typechange_fmt = in_porcelain ? ""T\t%s\n"" : ""%s: needs update\n"";"
implicit_predicate,read-cache.c,1527,+,+,"in_porcelain ? ""T\t%s\n"" : ""%s: needs update\n""",19,"	added_fmt      = in_porcelain ? ""A\t%s\n"" : ""%s: needs update\n"";"
implicit_predicate,read-cache.c,1528,+,+,"in_porcelain ? ""A\t%s\n"" : ""%s: needs update\n""",19,"	unmerged_fmt   = in_porcelain ? ""U\t%s\n"" : ""%s: needs merge\n"";"
implicit_predicate,read-cache.c,1529,+,-,"in_porcelain ? ""U\t%s\n"" : ""%s: needs merge\n""",,
implicit_predicate,read-cache.c,1566,+,-,"if (allow_unmerged)
    continue;
",,
implicit_predicate,read-cache.c,1567,+,-,"if (allow_unmerged)
    continue;
",,
implicit_predicate,read-cache.c,1575,+,-,"if (filtered)
    continue;
",,
implicit_predicate,read-cache.c,1576,+,-,"if (filtered)
    continue;
",,
implicit_predicate,read-cache.c,1598,+,-,"if (quiet)
    continue;
",,
implicit_predicate,read-cache.c,1599,+,-,"if (quiet)
    continue;
",,
implicit_predicate,read-cache.c,1829,+,-,"if (expand_name_field){
    const unsigned char* cp = (const unsigned char*)name;
    size_t strip_len, previous_len;
    strip_len = decode_varint(&cp);
    if (previous_ce){
        previous_len = previous_ce->ce_namelen;
        if (previous_len < strip_len)
            die(_(""malformed name field in the index, near path '%s'""), previous_ce->name);

        copy_len = previous_len - strip_len;
    }
    name = (const char*)cp;
}
",,
implicit_predicate,read-cache.c,1830,+,-,"if (expand_name_field){
    const unsigned char* cp = (const unsigned char*)name;
    size_t strip_len, previous_len;
    strip_len = decode_varint(&cp);
    if (previous_ce){
        previous_len = previous_ce->ce_namelen;
        if (previous_len < strip_len)
            die(_(""malformed name field in the index, near path '%s'""), previous_ce->name);

        copy_len = previous_len - strip_len;
    }
    name = (const char*)cp;
}
",,
implicit_predicate,read-cache.c,1847,+,-,"if (expand_name_field)
    len += copy_len;
",,
implicit_predicate,read-cache.c,1848,+,-,"if (expand_name_field)
    len += copy_len;
",,
implicit_predicate,read-cache.c,1880,+,-,<!!!>,,
implicit_predicate,read-cache.c,1881,+,-,<!!!>,,
implicit_predicate,read-cache.c,2169,+,-,"if (err)
    die(_(""unable to create load_cache_entries thread: %s""), strerror(err));
",,
implicit_predicate,read-cache.c,2170,+,-,"if (err)
    die(_(""unable to create load_cache_entries thread: %s""), strerror(err));
",,
implicit_predicate,read-cache.c,2182,+,-,"if (err)
    die(_(""unable to join load_cache_entries thread: %s""), strerror(err));
",,
implicit_predicate,read-cache.c,2183,+,-,"if (err)
    die(_(""unable to join load_cache_entries thread: %s""), strerror(err));
",,
implicit_predicate,read-cache.c,2285,+,-,"if (err)
    die(_(""unable to create load_index_extensions thread: %s""), strerror(err));
",,
implicit_predicate,read-cache.c,2286,+,-,"if (err)
    die(_(""unable to create load_index_extensions thread: %s""), strerror(err));
",,
implicit_predicate,read-cache.c,2312,+,-,"if (ret)
    die(_(""unable to join load_index_extensions thread: %s""), strerror(ret));
",,
implicit_predicate,read-cache.c,2313,+,-,"if (ret)
    die(_(""unable to join load_index_extensions thread: %s""), strerror(ret));
",,
implicit_predicate,read-cache.c,2540,+,-,"if (i)
    strbuf_addch(sb, ' ');
",,
implicit_predicate,read-cache.c,2541,+,-,"if (i)
    strbuf_addch(sb, ' ');
",,
implicit_predicate,read-cache.c,2550,+,-,"if (i)
    strbuf_addch(sb, ' ');
",,
implicit_predicate,read-cache.c,2551,+,-,"if (i)
    strbuf_addch(sb, ' ');
",,
implicit_predicate,read-cache.c,2593,+,-,"if (ce_match_stat_basic(ce, &st))
    return;
",,
implicit_predicate,read-cache.c,2594,+,-,"if (ce_match_stat_basic(ce, &st))
    return;
",,
implicit_predicate,read-cache.c,2595,+,-,"if (ce_modified_check_fs(istate, ce, &st)){
    ce->ce_stat_data.sd_size = 0;
}
",,
implicit_predicate,read-cache.c,2596,+,-,"if (ce_modified_check_fs(istate, ce, &st)){
    ce->ce_stat_data.sd_size = 0;
}
",,
implicit_predicate,read-cache.c,2696,+,-,"if (stripped_name){
    ce->ce_namelen = saved_namelen;
    ce->ce_flags &= ~CE_STRIP_NAME;
}
",,
implicit_predicate,read-cache.c,2697,+,-,"if (stripped_name){
    ce->ce_namelen = saved_namelen;
    ce->ce_flags &= ~CE_STRIP_NAME;
}
",,
implicit_predicate,read-cache.c,2755,+,-,"if (is_racy_timestamp(istate, ce))
    return 1;
",,
implicit_predicate,read-cache.c,2756,+,-,"if (is_racy_timestamp(istate, ce))
    return 1;
",,
implicit_predicate,read-cache.c,2862,+,+,extended ? 3 : 2,21,		istate->version = extended ? 3 : 2;
implicit_predicate,read-cache.c,2863,+,-,extended ? 3 : 2,,
implicit_predicate,read-cache.c,2922,+,-,"if (allow)
    warning(msg, ce->name);
else
    err = error(msg, ce->name);
",,
implicit_predicate,read-cache.c,2923,+,-,"if (allow)
    warning(msg, ce->name);
else
    err = error(msg, ce->name);
",,
implicit_predicate,read-cache.c,2947,+,-,"if (err)
    break;
",,
implicit_predicate,read-cache.c,2948,+,-,"if (err)
    break;
",,
implicit_predicate,read-cache.c,2958,+,-,"if (err){
    free(ieot);
    return err;
}
",,
implicit_predicate,read-cache.c,2959,+,-,"if (err){
    free(ieot);
    return err;
}
",,
implicit_predicate,read-cache.c,2989,+,-,"if (err)
    return -1;
",,
implicit_predicate,read-cache.c,2990,+,-,"if (err)
    return -1;
",,
implicit_predicate,read-cache.c,3005,+,-,"if (err)
    return -1;
",,
implicit_predicate,read-cache.c,3006,+,-,"if (err)
    return -1;
",,
implicit_predicate,read-cache.c,3016,+,-,"if (err)
    return -1;
",,
implicit_predicate,read-cache.c,3017,+,-,"if (err)
    return -1;
",,
implicit_predicate,read-cache.c,3028,+,-,"if (err)
    return -1;
",,
implicit_predicate,read-cache.c,3029,+,-,"if (err)
    return -1;
",,
implicit_predicate,read-cache.c,3040,+,-,"if (err)
    return -1;
",,
implicit_predicate,read-cache.c,3041,+,-,"if (err)
    return -1;
",,
implicit_predicate,read-cache.c,3051,+,-,"if (err)
    return -1;
",,
implicit_predicate,read-cache.c,3052,+,-,"if (err)
    return -1;
",,
implicit_predicate,read-cache.c,3072,+,-,"if (err)
    return -1;
",,
implicit_predicate,read-cache.c,3073,+,-,"if (err)
    return -1;
",,
implicit_predicate,read-cache.c,3128,+,-,"if (ret){
    warning(_(""failed to convert to a sparse-index""));
    return ret;
}
",,
implicit_predicate,read-cache.c,3129,+,-,"if (ret){
    warning(_(""failed to convert to a sparse-index""));
    return ret;
}
",,
implicit_predicate,read-cache.c,3143,+,-,"if (was_full)
    ensure_full_index(istate);
",,
implicit_predicate,read-cache.c,3144,+,-,"if (was_full)
    ensure_full_index(istate);
",,
implicit_predicate,read-cache.c,3146,+,-,"if (ret)
    return ret;
",,
implicit_predicate,read-cache.c,3147,+,-,"if (ret)
    return ret;
",,
implicit_predicate,read-cache.c,3154,-,+,,4,"			istate->updated_workdir ? ""1"" : ""0"","
implicit_predicate,read-cache.c,3155,-,+,,4,"			istate->updated_skipworktree ? ""1"" : ""0"", NULL);"
implicit_predicate,read-cache.c,3247,+,-,"if (was_full)
    ensure_full_index(istate);
",,
implicit_predicate,read-cache.c,3248,+,-,"if (was_full)
    ensure_full_index(istate);
",,
implicit_predicate,read-cache.c,3250,+,-,"if (ret)
    return ret;
",,
implicit_predicate,read-cache.c,3251,+,-,"if (ret)
    return ret;
",,
implicit_predicate,read-cache.c,3253,+,-,"if (ret){
    error(_(""cannot fix permission bits on '%s'""), get_tempfile_path(*temp));
    return ret;
}
",,
implicit_predicate,read-cache.c,3254,+,-,"if (ret){
    error(_(""cannot fix permission bits on '%s'""), get_tempfile_path(*temp));
    return ret;
}
",,
implicit_predicate,read-cache.c,3325,+,-,"if (test_split_index_env){
    if (!si){
        si = init_split_index(istate);
        istate->cache_changed |= SPLIT_INDEX_ORDERED;
    }else{
        int v = si->base_oid.hash[0];
        if ((v & 15) < 6)
            istate->cache_changed |= SPLIT_INDEX_ORDERED;
    }
}
",,
implicit_predicate,read-cache.c,3326,+,-,"if (test_split_index_env){
    if (!si){
        si = init_split_index(istate);
        istate->cache_changed |= SPLIT_INDEX_ORDERED;
    }else{
        int v = si->base_oid.hash[0];
        if ((v & 15) < 6)
            istate->cache_changed |= SPLIT_INDEX_ORDERED;
    }
}
",,
implicit_predicate,read-cache.c,3335,+,-,"if (too_many_not_shared_entries(istate))
    istate->cache_changed |= SPLIT_INDEX_ORDERED;
",,
implicit_predicate,read-cache.c,3336,+,-,"if (too_many_not_shared_entries(istate))
    istate->cache_changed |= SPLIT_INDEX_ORDERED;
",,
implicit_predicate,read-cache.c,3340,+,-,"if (new_shared_index){
    struct tempfile* temp;
    int saved_errno;
    temp = mks_tempfile_sm(git_path(""sharedindex_XXXXXX""), 0, 0666);
    if (!temp){
        ret = do_write_locked_index(istate, lock, flags, ~WRITE_SPLIT_INDEX_EXTENSION);
        goto out;
    }
    ret = write_shared_index(istate, &temp, flags);
    saved_errno = errno;
    if (is_tempfile_active(temp))
        delete_tempfile(&temp);

    errno = saved_errno;
    if (ret)
        goto out;
}
",,
implicit_predicate,read-cache.c,3341,+,-,"if (new_shared_index){
    struct tempfile* temp;
    int saved_errno;
    temp = mks_tempfile_sm(git_path(""sharedindex_XXXXXX""), 0, 0666);
    if (!temp){
        ret = do_write_locked_index(istate, lock, flags, ~WRITE_SPLIT_INDEX_EXTENSION);
        goto out;
    }
    ret = write_shared_index(istate, &temp, flags);
    saved_errno = errno;
    if (is_tempfile_active(temp))
        delete_tempfile(&temp);

    errno = saved_errno;
    if (ret)
        goto out;
}
",,
implicit_predicate,read-cache.c,3358,+,-,"if (ret)
    goto out;
",,
implicit_predicate,read-cache.c,3359,+,-,"if (ret)
    goto out;
",,
implicit_predicate,read-cache.c,3829,+,-,"if (err)
    die(""unable to read tree entries %s"", tree_name);
",,
implicit_predicate,read-cache.c,3830,+,-,"if (err)
    die(""unable to read tree entries %s"", tree_name);
",,
implicit_predicate,read-tree.c,169,-,+,,15,	prefix_set = opts.prefix ? 1 : 0;
implicit_predicate,read-tree.c,219,-,+,,7,"		    opts.update ? ""-u"" : ""-i"");"
implicit_predicate,read-tree.c,235,-,+,,14,			opts.fn = opts.prefix ? bind_merge : oneway_merge;
implicit_predicate,reader.c,267,-,+,,29,"	int32_t guess_block_size = r->block_size ? r->block_size :
							 DEFAULT_BLOCK_SIZE;"
implicit_predicate,reader.c,272,-,+,,24,	uint32_t header_off = next_off ? 0 : header_size(r->version);
implicit_predicate,reader.c,323,+,-,"if (err)
    return err;
",,
implicit_predicate,reader.c,329,+,-,"if (err)
    return err;
",,
implicit_predicate,reader.c,338,+,-,"while (1){
    int err;
    if (ti->is_finished)
        return 1;

    err = table_iter_next_in_block(ti, rec);
    if (err <= 0)
        return err;

    err = table_iter_next_block(ti);
    if (err){
        ti->is_finished = 1;
        return err;
    }
}
",,
implicit_predicate,reader.c,341,+,-,"if (ti->is_finished)
    return 1;
",,
implicit_predicate,reader.c,344,+,-,"while (1){
    int err;
    if (ti->is_finished)
        return 1;

    err = table_iter_next_in_block(ti, rec);
    if (err <= 0)
        return err;

    err = table_iter_next_block(ti);
    if (err){
        ti->is_finished = 1;
        return err;
    }
}
",,
implicit_predicate,reader.c,347,+,-,"if (ti->is_finished)
    return 1;
",,
implicit_predicate,reader.c,359,+,-,"if (err){
    ti->is_finished = 1;
    return err;
}
",,
implicit_predicate,reader.c,365,+,-,"if (err){
    ti->is_finished = 1;
    return err;
}
",,
implicit_predicate,reader.c,390,+,-,"if (index){
    off = offs->index_offset;
    if (off == 0){
        return 1;
    }
    typ = BLOCK_TYPE_INDEX;
}
",,
implicit_predicate,reader.c,411,+,-,"if (index){
    off = offs->index_offset;
    if (off == 0){
        return 1;
    }
    typ = BLOCK_TYPE_INDEX;
}
",,
implicit_predicate,reader.c,424,+,-,"while (1){
    struct table_iter next = *ti;
    memset(&next.br.block, 0, sizeof (next.br.block));
    next.br.zstream = NULL;
    next.br.uncompressed_data = NULL;
    next.br.uncompressed_cap = 0;
    err = table_iter_next_block(&next);
    if (err < 0)
        goto done;

    if (err > 0)
        break;

    err = block_reader_first_key(&next.br, &got_key);
    if (err < 0)
        goto done;

    if (strbuf_cmp(&got_key, &want_key) > 0){
        table_iter_block_done(&next);
        break;
    }
    table_iter_block_done(ti);
    *ti = next;
}
",,
implicit_predicate,reader.c,445,+,-,"while (1){
    struct table_iter next = *ti;
    memset(&next.br.block, 0, sizeof (next.br.block));
    next.br.zstream = NULL;
    next.br.uncompressed_data = NULL;
    next.br.uncompressed_cap = 0;
    err = table_iter_next_block(&next);
    if (err < 0)
        goto done;

    if (err > 0)
        break;

    err = block_reader_first_key(&next.br, &got_key);
    if (err < 0)
        goto done;

    if (strbuf_cmp(&got_key, &want_key) > 0){
        table_iter_block_done(&next);
        break;
    }
    table_iter_block_done(ti);
    *ti = next;
}
",,
implicit_predicate,reader.c,508,+,-,"while (1){
    err = table_iter_next(ti, &index_result);
    if (err != 0)
        goto done;

    err = table_iter_seek_to(ti, index_result.u.idx.offset, 0);
    if (err != 0)
        goto done;

    err = block_iter_seek_key(&ti->bi, &ti->br, &want_index.u.idx.last_key);
    if (err < 0)
        goto done;

    if (ti->typ == reftable_record_type(rec)){
        err = 0;
        break;
    }
    if (ti->typ != BLOCK_TYPE_INDEX){
        err = REFTABLE_FORMAT_ERROR;
        goto done;
    }
}
",,
implicit_predicate,reader.c,536,+,-,"while (1){
    err = table_iter_next(&index_iter, &index_result);
    if (err != 0)
        goto done;

    err = reader_table_iter_at(r, &next, index_result.u.idx.offset, 0);
    if (err != 0)
        goto done;

    err = block_iter_seek_key(&next.bi, &next.br, &want_index.u.idx.last_key);
    if (err < 0)
        goto done;

    if (next.typ == reftable_record_type(rec)){
        err = 0;
        break;
    }
    if (next.typ != BLOCK_TYPE_INDEX){
        err = REFTABLE_FORMAT_ERROR;
        break;
    }
    table_iter_close(&index_iter);
    index_iter = next;
    next = empty;
}
",,
implicit_predicate,reader.c,572,+,-,"if (err)
    goto out;
",,
implicit_predicate,reader.c,624,+,-,"if (err)
    table_iter_close(&ti);
",,
implicit_predicate,reader.c,871,+,-,"while (1){
    printf(""  - length: %u\n"", ti.br.block_len);
    printf(""    restarts: %u\n"", ti.br.restart_count);
    err = table_iter_next_block(&ti);
    if (err < 0)
        goto done;

    if (err > 0)
        break;
}
",,
implicit_predicate,readwrite_test.c,259,+,-,"while (1){
    int err = reftable_iterator_next_log(&it, &log);
    if (err > 0){
        break;
    }
    EXPECT_ERR(err);
    EXPECT_STREQ(names[i], log.refname);
    EXPECT(i == log.update_index);
    i++;
    reftable_log_record_release(&log);
}
",,
implicit_predicate,readwrite_test.c,364,+,-,"while (1){
    struct reftable_ref_record ref = {NULL};
    int r = reftable_iterator_next_ref(&it, &ref);
    EXPECT(r >= 0);
    if (r > 0){
        break;
    }
    EXPECT(0 == strcmp(names[j], ref.refname));
    EXPECT(update_index == ref.update_index);
    j++;
    reftable_ref_record_release(&ref);
}
",,
implicit_predicate,readwrite_test.c,587,+,-,"while (1){
    int err = reftable_iterator_next_ref(&it, &ref);
    EXPECT(err >= 0);
    if (err > 0){
        break;
    }
    EXPECT(j < want_names_len);
    EXPECT(0 == strcmp(ref.refname, want_names[j]));
    j++;
    reftable_ref_record_release(&ref);
}
",,
implicit_predicate,rebase-interactive.c,92,+,-,"if (edit_todo)
    msg = _(""\nYou are editing the todo file of an ongoing interactive rebase.\nTo continue rebase after editing, run:\n    git rebase --continue\n\n"");
else
    msg = _(""\nHowever, if you remove everything, the rebase will be aborted.\n\n"");
",,
implicit_predicate,rebase-interactive.c,142,+,-,"if (incorrect){
    if (todo_list_check_against_backup(r, new_todo)){
        write_file(rebase_path_dropped(), ""%s"", """");
        return -4;
    }
    if (incorrect > 0)
        unlink (rebase_path_dropped());
}else
    if (todo_list_check(todo_list, new_todo)){
        write_file(rebase_path_dropped(), ""%s"", """");
        return -4;
    }
",,
implicit_predicate,rebase.c,222,-,+,,28,	struct commit *base_rev = upstream ? upstream : onto;
implicit_predicate,rebase.c,277,-,+,,9,"			     opts->head_name ? opts->head_name : ""detached HEAD"","
implicit_predicate,rebase.c,294,+,-,"if (ret)
    error(_(""could not generate todo list""));
else{
    discard_index(the_repository->index);
    if (todo_list_parse_insn_buffer(the_repository, todo_list.buf.buf, &todo_list))
        BUG(""unusable todo list"");

    ret = complete_action(the_repository, &replay, flags, shortrevisions, opts->onto_name, opts->onto, &opts->orig_head->object.oid, &opts->exec, opts->autosquash, opts->update_refs, &todo_list);
}
",,
implicit_predicate,rebase.c,325,+,+,opts->keep_empty ? TODO_LIST_KEEP_EMPTY : 0,11,	flags |= opts->keep_empty ? TODO_LIST_KEEP_EMPTY : 0;
implicit_predicate,rebase.c,326,+,+,abbreviate_commands ? TODO_LIST_ABBREVIATE_CMDS : 0,11,	flags |= abbreviate_commands ? TODO_LIST_ABBREVIATE_CMDS : 0;
implicit_predicate,rebase.c,327,+,+,opts->rebase_merges ? TODO_LIST_REBASE_MERGES : 0,11,	flags |= opts->rebase_merges ? TODO_LIST_REBASE_MERGES : 0;
implicit_predicate,rebase.c,329,+,+,opts->root_with_onto ? TODO_LIST_ROOT_WITH_ONTO : 0,11,	flags |= opts->root_with_onto ? TODO_LIST_ROOT_WITH_ONTO : 0;
implicit_predicate,rebase.c,330,+,+,opts->reapply_cherry_picks ? TODO_LIST_REAPPLY_CHERRY_PICKS : 0,11,	flags |= opts->reapply_cherry_picks ? TODO_LIST_REAPPLY_CHERRY_PICKS : 0;
implicit_predicate,rebase.c,331,-,+,,11,	flags |= opts->flags & REBASE_NO_QUIET ? TODO_LIST_WARN_SKIPPED_CHERRY_PICKS : 0;
implicit_predicate,rebase.c,420,-,+,,20,"	opts->head_name = starts_with(head_name.buf, ""refs/"") ?
		xstrdup(head_name.buf) : NULL;"
implicit_predicate,rebase.c,488,-,+,,6,"		   opts->head_name ? opts->head_name : ""detached HEAD"");"
implicit_predicate,rebase.c,490,-,+,,6,"		   opts->onto ? oid_to_hex(&opts->onto->object.oid) : """");"
implicit_predicate,rebase.c,505,+,-,"if (opts->signoff)
    write_file(state_dir_path(""signoff"", opts), ""--signoff"");
",,
implicit_predicate,rebase.c,588,+,-,"if (status)
    return status;
",,
implicit_predicate,rebase.c,597,+,-,"if (status)
    return status;
",,
implicit_predicate,rebase.c,628,+,+,opts->root ? &opts->onto->object.oid : &opts->upstream->object.oid,19,"		     oid_to_hex(opts->root ?
				/* this is now equivalent to !opts->upstream */
				&opts->onto->object.oid :
				&opts->upstream->object.oid),"
implicit_predicate,rebase.c,638,+,-,"if (status){
    struct reset_head_opts ropts = {0};
    unlink(rebased_patches);
    free(rebased_patches);
    child_process_clear(&am);
    ropts.oid = &opts->orig_head->object.oid;
    ropts.branch = opts->head_name;
    ropts.default_reflog_action = opts->reflog_action;
    reset_head(the_repository, &ropts);
    error(_(""\ngit encountered an error while preparing the patches to replay\nthese revisions:\n\n    %s\n\nAs a result, git cannot rebase them.""), opts->revisions);
    return status;
}
",,
implicit_predicate,rebase.c,712,+,-,"if (opts->dont_finish_rebase);

else
    if (opts->type == REBASE_MERGE);

    else
        if (status == 0){
            if (!file_exists(state_dir_path(""stopped-sha"", opts)))
                finish_rebase(opts);
        }else
            if (status == 2){
                struct strbuf dir = STRBUF_INIT;
                apply_autostash(state_dir_path(""autostash"", opts));
                strbuf_addstr(&dir, opts->state_dir);
                remove_dir_recursively(&dir, 0);
                strbuf_release(&dir);
                die(""Nothing to do"");
            }
",,
implicit_predicate,rebase.c,729,+,+,status ? -1 : 0,9,	return status ? -1 : 0;
implicit_predicate,rebase.c,762,-,+,,24,"		opts->gpg_sign_opt = git_config_bool(var, value) ?
			xstrdup(""-S"") : NULL;"
implicit_predicate,rebase.c,794,-,+,,22,"		opts->fork_point = git_config_bool(var, value) ? -1 : 0;"
implicit_predicate,rebase.c,966,+,+,"unset ? ""--no-keep-empty"" : ""--keep-empty""",20,"	imply_merge(opts, unset ? ""--no-keep-empty"" : ""--keep-empty"");"
implicit_predicate,rebase.c,1014,-,+,,3,"		current_branch ? _(""There is no tracking information for ""
			""the current branch."") :
			_(""You are not currently on a branch.""));"
implicit_predicate,rebase.c,1190,-,+,,13,"	gpg_sign = options.gpg_sign_opt ? """" : NULL;"
implicit_predicate,rebase.c,1226,+,-,"if (preserve_merges_selected)
    die(_(""--preserve-merges was replaced by --rebase-merges\nNote: Your `pull.rebase` configuration may also be set to 'preserve',\nwhich is no longer supported; use 'merges' instead""));
",,
implicit_predicate,rebase.c,1240,+,-,"if (keep_base){
    if (options.onto_name)
        die(_(""options '%s' and '%s' cannot be used together""), ""--keep-base"", ""--onto"");

    if (options.root)
        die(_(""options '%s' and '%s' cannot be used together""), ""--keep-base"", ""--root"");

    if (options.fork_point < 0)
        options.fork_point = 0;
}
",,
implicit_predicate,rebase.c,1243,+,-,"if (options.root)
    die(_(""options '%s' and '%s' cannot be used together""), ""--keep-base"", ""--root"");
",,
implicit_predicate,rebase.c,1263,+,-,"if (is_merge(&options))
    trace2_cmd_mode(""interactive"");
else
    if (options.exec.nr)
        trace2_cmd_mode(""interactive-exec"");
    else
        trace2_cmd_mode(action_names[options.action]);
",,
implicit_predicate,rebase.c,1273,-,+,,11,"		xstrdup(options.reflog_action ? options.reflog_action : ""rebase"");"
implicit_predicate,rebase.c,1299,+,-,"if (read_basic_state(&options))
    exit(1);
",,
implicit_predicate,rebase.c,1312,+,-,"if (read_basic_state(&options))
    exit(1);
",,
implicit_predicate,rebase.c,1323,+,-,"if (read_basic_state(&options))
    exit(1);
",,
implicit_predicate,rebase.c,1328,-,+,,8,"			    options.head_name ? options.head_name
					      : oid_to_hex(&options.orig_head->object.oid));"
implicit_predicate,rebase.c,1354,+,-,"if (ret)
    error(_(""could not remove '%s'""), options.state_dir);
",,
implicit_predicate,rebase.c,1373,+,-,"if (in_progress){
    const char* last_slash = strrchr(options.state_dir, '/');
    const char* state_dir_base = last_slash ? last_slash + 1 : options.state_dir;
    const char* cmd_live_rebase = ""git rebase (--continue | --abort | --skip)"";
    strbuf_reset(&buf);
    strbuf_addf(&buf, ""rm -fr \""%s\"""", options.state_dir);
    die(_(""It seems that there is already a %s directory, and\nI wonder if you are in the middle of another rebase.  If that is the\ncase, please try\n\t%s\nIf that is not the case, please\n\t%s\nand run me again.  I am stopping in case you still have something\nvaluable there.\n""), state_dir_base, cmd_live_rebase, buf.buf);
}
",,
implicit_predicate,rebase.c,1376,-,+,,4,			last_slash ? last_slash + 1 : options.state_dir;
implicit_predicate,rebase.c,1446,+,+,"options.reapply_cherry_picks ? ""--reapply-cherry-picks"" : ""--no-reapply-cherry-picks""",25,"		imply_merge(&options, options.reapply_cherry_picks ?
					  ""--reapply-cherry-picks"" :
					  ""--no-reapply-cherry-picks"");"
implicit_predicate,rebase.c,1457,+,-,"if (ignore_whitespace)
    strvec_push(&options.git_am_opts, ""--ignore-whitespace"");
",,
implicit_predicate,rebase.c,1460,+,-,"if (options.committer_date_is_author_date)
    strvec_push(&options.git_am_opts, ""--committer-date-is-author-date"");
",,
implicit_predicate,rebase.c,1463,+,-,"if (options.ignore_date)
    strvec_push(&options.git_am_opts, ""--ignore-date"");
",,
implicit_predicate,rebase.c,1467,+,-,"if (ignore_whitespace){
    string_list_append(&options.strategy_opts, ""ignore-space-change"");
}
",,
implicit_predicate,rebase.c,1494,+,-,"if (is_merge(&options))
    die(_(""apply options and merge options cannot be used together""));
else
    if (options.rebase_merges == -1 && options.config_rebase_merges == 1)
        die(_(""apply options are incompatible with rebase.rebaseMerges.  Consider adding --no-rebase-merges""));
    else
        if (options.update_refs == -1 && options.config_update_refs == 1)
            die(_(""apply options are incompatible with rebase.updateRefs.  Consider adding --no-update-refs""));
        else
            options.type = REBASE_APPLY;
",,
implicit_predicate,rebase.c,1564,+,-,"if (options.signoff){
    strvec_push(&options.git_am_opts, ""--signoff"");
    options.flags |= REBASE_FORCE;
}
",,
implicit_predicate,rebase.c,1664,+,-,"if (keep_base){
    strbuf_reset(&buf);
    strbuf_addstr(&buf, options.upstream_name);
    strbuf_addstr(&buf, ""..."");
    strbuf_addstr(&buf, branch_name);
    options.onto_name = keep_base_onto_name = xstrdup(buf.buf);
}else
    if (!options.onto_name)
        options.onto_name = options.upstream_name;
",,
implicit_predicate,rebase.c,1674,+,-,"if (keep_base)
    die(_(""'%s': need exactly one merge base with branch""), options.upstream_name);
else
    die(_(""'%s': need exactly one merge base""), options.onto_name);
",,
implicit_predicate,rebase.c,1702,+,-,"if (options.autostash)
    create_autostash(the_repository, state_dir_path(""autostash"", &options));
",,
implicit_predicate,rebase.c,1732,+,-,"if (ret)
    goto cleanup;
",,
implicit_predicate,rebase.c,1759,+,+,argc ? argv[0] : NULL,4,"			argc ? argv[0] : NULL, NULL))"
implicit_predicate,rebase.c,1782,-,+,,17,"		diff_tree_oid(is_null_oid(&branch_base) ?
			      the_hash_algo->empty_tree : &branch_base,"
implicit_predicate,rebase.c,1789,+,-,"if (is_merge(&options))
    goto run_rebase;
",,
implicit_predicate,rebase.c,1822,+,+,options.root ? oid_to_hex(&options.onto->object.oid) : (options.restrict_revision ? oid_to_hex(&options.restrict_revision->object.oid) : oid_to_hex(&options.upstream->object.oid)),7,"		    options.root ? oid_to_hex(&options.onto->object.oid) :
		    (options.restrict_revision ?
		     oid_to_hex(&options.restrict_revision->object.oid) :
		     oid_to_hex(&options.upstream->object.oid)),"
implicit_predicate,rebase.c,1823,-,+,,8,"		    (options.restrict_revision ?
		     oid_to_hex(&options.restrict_revision->object.oid) :
		     oid_to_hex(&options.upstream->object.oid)),"
implicit_predicate,receive-pack.c,147,+,-,"if (status)
    return status;
",,
implicit_predicate,receive-pack.c,176,-,+,,4,"			fsck_msg_types.len ? ',' : '=', path);"
implicit_predicate,receive-pack.c,186,-,+,,5,"				fsck_msg_types.len ? ',' : '=', msg_id, value);"
implicit_predicate,receive-pack.c,277,+,-,"if (sent_capabilities){
    packet_write_fmt(1, ""%s %s\n"", oid_to_hex(oid), path);
}else{
    struct strbuf cap = STRBUF_INIT;
    strbuf_addstr(&cap, ""report-status report-status-v2 delete-refs side-band-64k quiet"");
    if (advertise_atomic_push)
        strbuf_addstr(&cap, "" atomic"");

    if (prefer_ofs_delta)
        strbuf_addstr(&cap, "" ofs-delta"");

    if (push_cert_nonce)
        strbuf_addf(&cap, "" push-cert=%s"", push_cert_nonce);

    if (advertise_push_options)
        strbuf_addstr(&cap, "" push-options"");

    if (advertise_sid)
        strbuf_addf(&cap, "" session-id=%s"", trace2_session_id());

    strbuf_addf(&cap, "" object-format=%s"", the_hash_algo->name);
    strbuf_addf(&cap, "" agent=%s"", git_user_agent_sanitized());
    packet_write_fmt(1, ""%s %s%c%s\n"", oid_to_hex(oid), path, 0, cap.buf);
    strbuf_release(&cap);
    sent_capabilities = 1;
}
",,
implicit_predicate,receive-pack.c,284,+,-,"if (advertise_atomic_push)
    strbuf_addstr(&cap, "" atomic"");
",,
implicit_predicate,receive-pack.c,286,+,-,"if (prefer_ofs_delta)
    strbuf_addstr(&cap, "" ofs-delta"");
",,
implicit_predicate,receive-pack.c,290,+,-,"if (advertise_push_options)
    strbuf_addstr(&cap, "" push-options"");
",,
implicit_predicate,receive-pack.c,292,+,-,"if (advertise_sid)
    strbuf_addf(&cap, "" session-id=%s"", trace2_session_id());
",,
implicit_predicate,receive-pack.c,438,+,-,"if (p->negative_ref){
    return 1;
}
",,
implicit_predicate,receive-pack.c,456,+,-,"if (use_sideband)
    send_sideband(1, 2, msg, sz, use_sideband);
else
    xwrite(2, msg, sz);
",,
implicit_predicate,receive-pack.c,614,-,+,,16,"	char *nonce = found ? xmemdupz(found, noncelen) : NULL;"
implicit_predicate,receive-pack.c,760,-,+,,9,"			     sigcheck.signer ? sigcheck.signer : """");"
implicit_predicate,receive-pack.c,762,-,+,,9,"			     sigcheck.key ? sigcheck.key : """");"
implicit_predicate,receive-pack.c,820,+,-,"if (use_sideband){
    memset(&muxer, 0, sizeof (muxer));
    muxer.proc = copy_to_sideband;
    muxer.in = -1;
    code = start_async(&muxer);
    if (code)
        return code;

    proc.err = muxer.in;
}
",,
implicit_predicate,receive-pack.c,825,+,-,"if (code)
    return code;
",,
implicit_predicate,receive-pack.c,833,+,-,"if (code){
    if (use_sideband)
        finish_async(&muxer);

    return code;
}
",,
implicit_predicate,receive-pack.c,834,+,-,"if (use_sideband)
    finish_async(&muxer);
",,
implicit_predicate,receive-pack.c,841,+,-,"while (1){
    const char* buf;
    size_t n;
    if (feed(feed_state, &buf, &n))
        break;

    if (write_in_full(proc.in, buf, n) < 0)
        break;
}
",,
implicit_predicate,receive-pack.c,844,+,-,"if (feed(feed_state, &buf, &n))
    break;
",,
implicit_predicate,receive-pack.c,850,+,-,"if (use_sideband)
    finish_async(&muxer);
",,
implicit_predicate,receive-pack.c,878,-,+,,13,		old_oid = state->report->old_oid ? state->report->old_oid : &cmd->old_oid;
implicit_predicate,receive-pack.c,879,-,+,,13,		new_oid = state->report->new_oid ? state->report->new_oid : &cmd->new_oid;
implicit_predicate,receive-pack.c,880,-,+,,14,		ref_name = state->report->ref_name ? state->report->ref_name : cmd->ref_name;
implicit_predicate,receive-pack.c,937,+,+,use_sideband ? -1 : 0,13,	proc.err = use_sideband ? -1 : 0;
implicit_predicate,receive-pack.c,941,+,-,"if (code)
    return code;
",,
implicit_predicate,receive-pack.c,943,+,-,"if (use_sideband)
    copy_to_sideband(proc.err, -1, NULL);
",,
implicit_predicate,receive-pack.c,1004,+,-,"if (new_report){
    if (!hint->report){
        CALLOC_ARRAY(hint->report, 1);
        report = hint->report;
    }else{
        report = hint->report;
        while (report->next)
            report = report->next;
        report->next = xcalloc(1, sizeof (struct ref_push_report));
        report = report->next;
    }
    new_report = 0;
}
",,
implicit_predicate,receive-pack.c,1113,+,-,"if (use_sideband){
    memset(&muxer, 0, sizeof (muxer));
    muxer.proc = copy_to_sideband;
    muxer.in = -1;
    code = start_async(&muxer);
    if (code)
        return code;

    proc.err = muxer.in;
}else{
    proc.err = 0;
}
",,
implicit_predicate,receive-pack.c,1118,+,-,"if (code)
    return code;
",,
implicit_predicate,receive-pack.c,1126,+,-,"if (code){
    if (use_sideband)
        finish_async(&muxer);

    return code;
}
",,
implicit_predicate,receive-pack.c,1127,+,-,"if (use_sideband)
    finish_async(&muxer);
",,
implicit_predicate,receive-pack.c,1138,+,-,"if (use_atomic)
    strbuf_addstr(&cap, "" atomic"");
",,
implicit_predicate,receive-pack.c,1140,+,-,"if (use_push_options)
    strbuf_addstr(&cap, "" push-options"");
",,
implicit_predicate,receive-pack.c,1175,+,-,"if (code){
    strbuf_addstr(&errmsg, ""fail to negotiate version with proc-receive hook"");
    goto cleanup;
}
",,
implicit_predicate,receive-pack.c,1200,+,-,"if (code)
    break;
",,
implicit_predicate,receive-pack.c,1205,+,-,"if (code){
    strbuf_addstr(&errmsg, ""fail to write commands to proc-receive hook"");
    goto cleanup;
}
",,
implicit_predicate,receive-pack.c,1211,+,-,<!!!>,,
implicit_predicate,receive-pack.c,1216,+,-,"if (code)
    break;
",,
implicit_predicate,receive-pack.c,1221,+,-,"if (code){
    strbuf_addstr(&errmsg, ""fail to write push-options to proc-receive hook"");
    goto cleanup;
}
",,
implicit_predicate,receive-pack.c,1234,+,-,"if (use_sideband)
    finish_async(&muxer);
",,
implicit_predicate,receive-pack.c,1374,+,+,"head_has_history() ? ""HEAD"" : empty_tree_oid_hex()",8,"		     head_has_history() ? ""HEAD"" : empty_tree_oid_hex(),"
implicit_predicate,receive-pack.c,1456,-,+,,37,"	    check_refname_format(name + 5, is_null_oid(new_oid) ?
				 REFNAME_ALLOW_ONELEVEL : 0)) {"
implicit_predicate,receive-pack.c,1553,+,-,"if (run_update_hook(cmd)){
    rp_error(""hook declined to update %s"", name);
    ret = ""hook declined"";
    goto out;
}
",,
implicit_predicate,receive-pack.c,1559,+,-,"if (do_update_worktree){
    ret = update_worktree(new_oid->hash, worktree);
    if (ret)
        goto out;
}
",,
implicit_predicate,receive-pack.c,1636,+,+,use_sideband ? -1 : 0,13,	proc.err = use_sideband ? -1 : 0;
implicit_predicate,receive-pack.c,1640,+,-,"if (use_sideband)
    copy_to_sideband(proc.err, -1, NULL);
",,
implicit_predicate,receive-pack.c,1917,+,-,"if (use_sideband){
    memset(&muxer, 0, sizeof (muxer));
    muxer.proc = copy_to_sideband;
    muxer.in = -1;
    if (!start_async(&muxer))
        err_fd = muxer.in;
}
",,
implicit_predicate,receive-pack.c,1936,+,-,"if (use_sideband)
    finish_async(&muxer);
",,
implicit_predicate,receive-pack.c,1950,+,-,"if (proc_receive_ref_matches(cmd)){
    cmd->run_proc_receive = RUN_PROC_RECEIVE_SCHEDULED;
    run_proc_receive = 1;
}
",,
implicit_predicate,receive-pack.c,1957,+,-,"if (run_receive_hook(commands, ""pre-receive"", 0, push_options)){
    for (cmd = commands;cmd;cmd = cmd->next){
        if (!cmd->error_string)
            cmd->error_string = ""pre-receive hook declined"";
    }
    return;
}
",,
implicit_predicate,receive-pack.c,2002,+,-,"if (use_atomic)
    execute_commands_atomic(commands, si);
else
    execute_commands_non_atomic(commands, si);
",,
implicit_predicate,receive-pack.c,2007,+,-,"if (shallow_update)
    BUG_if_skipped_connectivity_check(commands, si);
",,
implicit_predicate,receive-pack.c,2063,-,+,,35,"		tail = queue_command(tail, boc, eol ? eol - boc : eoc - boc);"
implicit_predicate,receive-pack.c,2064,-,+,,9,		boc = eol ? eol + 1 : eoc;
implicit_predicate,receive-pack.c,2143,+,-,"if (true_flush)
    break;
",,
implicit_predicate,receive-pack.c,2160,+,-,"while (1){
    if (packet_reader_read(reader) != PACKET_READ_NORMAL)
        break;

    string_list_append(options, reader->line);
}
",,
implicit_predicate,receive-pack.c,2239,+,-,"if (quiet)
    strvec_push(&child.args, ""-q"");
",,
implicit_predicate,receive-pack.c,2241,+,-,"if (fsck_objects)
    strvec_pushf(&child.args, ""--strict%s"", fsck_msg_types.buf);
",,
implicit_predicate,receive-pack.c,2251,+,-,"if (status)
    return ""unpack-objects abnormal exit"";
",,
implicit_predicate,receive-pack.c,2269,+,-,"if (use_sideband)
    strvec_push(&child.args, ""--report-end-of-input"");
",,
implicit_predicate,receive-pack.c,2271,+,-,"if (fsck_objects)
    strvec_pushf(&child.args, ""--strict%s"", fsck_msg_types.buf);
",,
implicit_predicate,receive-pack.c,2283,+,-,"if (status)
    return ""index-pack fork failed"";
",,
implicit_predicate,receive-pack.c,2294,+,-,"if (status)
    return ""index-pack abnormal exit"";
",,
implicit_predicate,receive-pack.c,2385,+,-,"if (shallow_update){
    prepare_shallow_update(si);
    return;
}
",,
implicit_predicate,receive-pack.c,2395,+,-,"if (ref_status[cmd->index]){
    cmd->error_string = ""shallow update not allowed"";
    cmd->skip_update = 1;
}
",,
implicit_predicate,receive-pack.c,2409,-,+,,5,"			 unpack_status ? unpack_status : ""ok"");"
implicit_predicate,receive-pack.c,2420,+,-,"if (use_sideband)
    send_sideband(1, 1, buf.buf, buf.len, use_sideband);
else
    write_or_die(1, buf.buf, buf.len);
",,
implicit_predicate,receive-pack.c,2434,-,+,,5,"			 unpack_status ? unpack_status : ""ok"");"
implicit_predicate,receive-pack.c,2465,+,-,"if (use_sideband)
    send_sideband(1, 1, buf.buf, buf.len, use_sideband);
else
    write_or_die(1, buf.buf, buf.len);
",,
implicit_predicate,receive-pack.c,2550,+,-,"if (advertise_refs)
    return 0;
",,
implicit_predicate,receive-pack.c,2561,+,-,"if (use_push_options)
    read_push_options(&reader, &push_options);
",,
implicit_predicate,receive-pack.c,2581,+,-,"if (report_status_v2)
    report_v2(commands, unpack_status);
else
    if (report_status)
        report(commands, unpack_status);
",,
implicit_predicate,receive-pack.c,2583,+,-,"if (report_status)
    report(commands, unpack_status);
",,
implicit_predicate,receive-pack.c,2591,+,-,"if (auto_gc){
    struct child_process proc = CHILD_PROCESS_INIT;
    if (prepare_auto_maintenance(1, &proc)){
        proc.no_stdin = 1;
        proc.stdout_to_stderr = 1;
        proc.err = use_sideband ? -1 : 0;
        if (!start_command(&proc)){
            if (use_sideband)
                copy_to_sideband(proc.err, -1, NULL);

            finish_command(&proc);
        }
    }
}
",,
implicit_predicate,receive-pack.c,2597,+,+,use_sideband ? -1 : 0,16,				proc.err = use_sideband ? -1 : 0;
implicit_predicate,receive-pack.c,2600,+,-,"if (use_sideband)
    copy_to_sideband(proc.err, -1, NULL);
",,
implicit_predicate,receive-pack.c,2606,+,-,"if (auto_update_server_info)
    update_server_info(0);
",,
implicit_predicate,receive-pack.c,2610,+,-,"if (use_sideband)
    packet_flush(1);
",,
implicit_predicate,record.c,50,+,-,"while (1){
    val >>= 7;
    if (!val){
        break;
    }
    val--;
    buf[i] = 0x80 | (uint8_t)(val & 0x7f);
    i--;
}
",,
implicit_predicate,record.c,683,+,-,"if (cmp)
    return cmp;
",,
implicit_predicate,record.c,720,-,+,,10,"		       log->value.update.name ? log->value.update.name : """","
implicit_predicate,record.c,721,-,+,,10,"		       log->value.update.email ? log->value.update.email : """","
implicit_predicate,record.c,728,-,+,,10,"		       log->value.update.message ? log->value.update.message : """");"
implicit_predicate,record.c,817,-,+,,9,	return reftable_log_record_is_deletion(log) ? 0 : 1;
implicit_predicate,record.c,836,-,+,,20,"	n = encode_string(r->value.update.name ? r->value.update.name : """", s);"
implicit_predicate,record.c,841,-,+,,20,"	n = encode_string(r->value.update.email ? r->value.update.email : """","
implicit_predicate,record.c,859,-,+,,3,"		r->value.update.message ? r->value.update.message : """", s);"
implicit_predicate,record.c,997,+,-,"if (cmp)
    return cmp;
",,
implicit_predicate,record.c,1277,+,-,"if (cmp)
    return cmp;
",,
implicit_predicate,ref-cache.c,120,+,-,"if (cmp)
    return cmp;
",,
implicit_predicate,ref-cache.c,201,-,+,,9,	return (entry->flag & REF_DIR) ? NULL : entry;
implicit_predicate,ref-cache.c,392,+,-,"while (1){
    struct cache_ref_iterator_level* level = &iter->levels[iter->levels_nr - 1];
    struct ref_dir* dir = level->dir;
    struct ref_entry* entry;
    enum prefix_state entry_prefix_state;
    if (level->index == -1)
        sort_ref_dir(dir);

    if (++level->index == level->dir->nr){
        if (--iter->levels_nr == 0)
            return ref_iterator_abort(ref_iterator);

        continue;
    }
    entry = dir->entries[level->index];
    if (level->prefix_state == PREFIX_WITHIN_DIR){
        entry_prefix_state = overlaps_prefix(entry->name, iter->prefix);
        if (entry_prefix_state == PREFIX_EXCLUDES_DIR || (entry_prefix_state == PREFIX_WITHIN_DIR && !(entry->flag & REF_DIR)))
            continue;
    }else{
        entry_prefix_state = level->prefix_state;
    }
    if (entry->flag & REF_DIR){
        ALLOC_GROW(iter->levels, iter->levels_nr + 1, iter->levels_alloc);
        level = &iter->levels[iter->levels_nr++];
        level->dir = get_ref_dir(entry);
        level->prefix_state = entry_prefix_state;
        level->index = -1;
    }else{
        iter->base.refname = entry->name;
        iter->base.oid = &entry->u.value.oid;
        iter->base.flags = entry->flag;
        return ITER_OK;
    }
}
",,
implicit_predicate,ref-cache.c,447,-,+,,9,"	return peel_object(ref_iterator->oid, peeled) ? -1 : 0;"
implicit_predicate,ref-cache.c,481,+,-,"if (prime_dir)
    prime_ref_dir(dir, prefix);
",,
implicit_predicate,ref-cache.c,484,+,-,"if (prime_dir)
    prime_ref_dir(dir, prefix);
",,
implicit_predicate,ref-filter.c,109,-,+,,3,		keydata_aka_refname ? keydata_aka_refname : k->wt->head_ref);
implicit_predicate,ref-filter.c,622,+,-,"if (match_atom_bool_arg(*arg, ""tags"", arg, &optval)){
    if (!optval)
        strvec_push(args, ""--no-tags"");
    else
        strvec_push(args, ""--tags"");

    return 1;
}
",,
implicit_predicate,ref-filter.c,1017,-,+,,14,	atom_len = (arg ? arg : ep) - sp;
implicit_predicate,ref-filter.c,1173,+,-,"if (if_then_else->else_atom_seen){
    if (if_then_else->condition_satisfied){
        strbuf_reset(&cur->output);
        pop_stack_element(&cur);
    }else{
        strbuf_swap(&cur->output, &prev->output);
        strbuf_reset(&cur->output);
        pop_stack_element(&cur);
    }
}else
    if (!if_then_else->condition_satisfied){
        strbuf_reset(&cur->output);
    }
",,
implicit_predicate,ref-filter.c,1179,+,-,"if (if_then_else->condition_satisfied){
    strbuf_reset(&cur->output);
    pop_stack_element(&cur);
}else{
    strbuf_swap(&cur->output, &prev->output);
    strbuf_reset(&cur->output);
    pop_stack_element(&cur);
}
",,
implicit_predicate,ref-filter.c,1362,+,-,"if (reject_atom(used_atom[at].atom_type))
    die(_(""this command reject atom %%(%.*s)""), (int)(ep - sp - 2), sp + 2);
",,
implicit_predicate,ref-filter.c,1421,+,-,"if (deref)
    name++;
",,
implicit_predicate,ref-filter.c,1452,+,-,"if (deref)
    name++;
",,
implicit_predicate,ref-filter.c,1475,+,-,"if (deref)
    name++;
",,
implicit_predicate,ref-filter.c,1660,+,-,"if (deref)
    name++;
",,
implicit_predicate,ref-filter.c,1713,+,-,"if (deref)
    name++;
",,
implicit_predicate,ref-filter.c,1738,+,-,"if (deref)
    name++;
",,
implicit_predicate,ref-filter.c,1760,-,+,,19,"			v->s = xstrdup(sigc.output ? sigc.output: """");"
implicit_predicate,ref-filter.c,1763,-,+,,19,"			v->s = xstrdup(sigc.signer ? sigc.signer : """");"
implicit_predicate,ref-filter.c,1789,-,+,,19,"			v->s = xstrdup(sigc.key ? sigc.key : """");"
implicit_predicate,ref-filter.c,1792,-,+,,19,"			v->s = xstrdup(sigc.fingerprint ?
				       sigc.fingerprint : """");"
implicit_predicate,ref-filter.c,1796,-,+,,19,"			v->s = xstrdup(sigc.primary_key_fingerprint ?
				       sigc.primary_key_fingerprint : """");"
implicit_predicate,ref-filter.c,1805,+,-,"if (signature_checked)
    signature_check_clear(&sigc);
",,
implicit_predicate,ref-filter.c,1876,+,-,"if (i)
    strbuf_addstr(out, ""\n    "");
",,
implicit_predicate,ref-filter.c,1879,-,+,,9,		len = eol ? eol - sp : size - (sp - buf);
implicit_predicate,ref-filter.c,1941,+,-,"if (deref)
    name++;
",,
implicit_predicate,ref-filter.c,2193,-,+,,24,"		const char *remote = atom->u.remote_ref.push ?
			pushremote_for_branch(branch, &explicit) :
			remote_for_branch(branch, &explicit);"
implicit_predicate,ref-filter.c,2196,-,+,,16,"		*s = xstrdup(explicit ? remote : """");"
implicit_predicate,ref-filter.c,2201,-,+,,16,"		*s = xstrdup(merge ? merge : """");"
implicit_predicate,ref-filter.c,2408,+,-,"if (atom->u.remote_ref.push_remote)
    refname = NULL;
else{
    refname = branch_get_push(branch, NULL);
    if (!refname)
        continue;
}
",,
implicit_predicate,ref-filter.c,2501,+,-,"if (need_tagged)
    oi.info.contentp = &oi.content;
",,
implicit_predicate,ref-filter.c,2509,+,-,"if (get_object(ref, 0, &obj, &oi, err))
    return -1;
",,
implicit_predicate,ref-filter.c,2537,+,-,"if (populate_value(ref, err))
    return -1;
",,
implicit_predicate,ref-filter.c,2556,+,-,"if (ignore_case)
    flags |= WM_CASEFOLD;
",,
implicit_predicate,ref-filter.c,2587,+,-,"if (ignore_case)
    flags |= WM_CASEFOLD;
",,
implicit_predicate,ref-filter.c,2818,+,-,"if (filter_exclude_match(filter, refname))
    return NULL;
",,
implicit_predicate,ref-filter.c,3153,+,-,"if (can_do_iterative_format(filter, sorting, format)){
    int save_commit_buffer_orig;
    struct ref_filter_and_format_cbdata ref_cbdata = {.filter = filter, .format = format};
    save_commit_buffer_orig = save_commit_buffer;
    save_commit_buffer = 0;
    do_filter_refs(filter, type, filter_and_format_one, &ref_cbdata);
    save_commit_buffer = save_commit_buffer_orig;
}else{
    struct ref_array array = {0};
    filter_refs(&array, filter, type);
    filter_ahead_behind(the_repository, format, &array);
    ref_array_sort(sorting, &array);
    print_formatted_ref_array(&array, format);
    ref_array_clear(&array);
}
",,
implicit_predicate,ref-filter.c,3195,+,-,"if (diff)
    return diff;
",,
implicit_predicate,ref-filter.c,3229,-,+,,13,"			cmp_fn = s->sort_flags & REF_SORTING_ICASE
				? strcasecmp : strcmp;"
implicit_predicate,ref-filter.c,3238,-,+,,13,"			cmp_fn = s->sort_flags & REF_SORTING_ICASE
				? memcasecmp : memcmp;"
implicit_predicate,ref-filter.c,3271,+,-,"if (cmp)
    return cmp;
",,
implicit_predicate,ref-filter.c,3284,+,-,"if (on)
    sorting->sort_flags |= mask;
else
    sorting->sort_flags &= ~mask;
",,
implicit_predicate,ref-filter.c,3397,+,-,"if (format_ref_array_item(ref_item, format, &output, &err))
    die(""%s"", err.buf);
",,
implicit_predicate,reflog-walk.c,245,+,-,"if (shorten){
    if (!commit_reflog->reflogs->short_ref)
        commit_reflog->reflogs->short_ref = refs_shorten_unambiguous_ref(get_main_ref_store(the_repository), commit_reflog->reflogs->ref, 0);

    printed_ref = commit_reflog->reflogs->short_ref;
}else{
    printed_ref = commit_reflog->reflogs->ref;
}
",,
implicit_predicate,reflog-walk.c,320,+,-,"if (oneline){
    printf(""%s: %s"", selector.buf, info->message);
}else{
    printf(""Reflog: %s (%s)\nReflog message: %s"", selector.buf, info->email, info->message);
}
",,
implicit_predicate,reflog.c,53,+,-,"if (complete)
    tree->object.flags |= SEEN;
",,
implicit_predicate,reflog.c,127,+,-,"if (is_incomplete)
    commit->object.flags |= INCOMPLETE;
else{
    for (i = 0;i < found.nr;i++)
        found.objects[i].item->flags |= SEEN;
}
",,
implicit_predicate,reflog.c,264,+,-,"if (argc)
    return error(_(""%s does not accept arguments: '%s'""), ""list"", argv[0]);
",,
implicit_predicate,reflog.c,320,+,-,"if (verbose)
    should_prune_fn = should_expire_reflog_ent_verbose;
",,
implicit_predicate,reflog.c,335,+,-,"if (verbose)
    printf(_(""Marking reachable objects...""));
",,
implicit_predicate,reflog.c,336,-,+,,33,		cb->unreachable_expire_kind = commit ? UE_NORMAL : UE_ALWAYS;
implicit_predicate,reflog.c,339,+,-,"if (verbose)
    putchar('\n');
",,
implicit_predicate,reflog.c,343,+,-,<!!!>,,
implicit_predicate,reflog.c,406,+,-,"if (verbose)
    should_prune_fn = should_expire_reflog_ent_verbose;
",,
implicit_predicate,refs.c,282,+,-,"while (1){
    if (sanitized && sanitized->len)
        strbuf_complete(sanitized, '/');

    component_len = check_refname_component(refname, &flags, sanitized);
    if (sanitized && component_len == 0);

    else
        if (component_len <= 0)
            return -1;

    component_count++;
    if (refname[component_len] == '\0')
        break;

    refname += component_len + 1;
}
",,
implicit_predicate,refs.c,283,+,-,"while (1){
    if (sanitized && sanitized->len)
        strbuf_complete(sanitized, '/');

    component_len = check_refname_component(refname, &flags, sanitized);
    if (sanitized && component_len == 0);

    else
        if (component_len <= 0)
            return -1;

    component_count++;
    if (refname[component_len] == '\0')
        break;

    refname += component_len + 1;
}
",,
implicit_predicate,refs.c,469,-,+,,10,"	    || (d->refname
		? strcmp(resolves_to, d->refname)
		: !string_list_has_string(d->refnames, resolves_to))) {"
implicit_predicate,refs.c,556,-,+,,15,	item->util = has_glob_specials(pattern) ? NULL : item->string;
implicit_predicate,refs.c,660,+,-,"if (check_refname_format(full_ref, 0))
    die(_(""invalid branch name: %s = %s""), config_display_key, ret);
",,
implicit_predicate,refs.c,682,+,-,"if (check_refname_format(full_ref, 0))
    die(_(""invalid branch name: %s = %s""), config_display_key, ret);
",,
implicit_predicate,refs.c,716,+,-,refs_found ? &oid_from_ref : oid,,
implicit_predicate,refs.c,748,+,+,refs_found ? &oid_from_ref : oid,17,		this_result = refs_found ? &oid_from_ref : oid;
implicit_predicate,refs.c,787,-,+,,12,"					      oid ? &hash : NULL, NULL);"
implicit_predicate,refs.c,872,+,-,"if (is_current_worktree_ref(*bare_refname))
    return REF_WORKTREE_OTHER;
",,
implicit_predicate,refs.c,884,+,-,"if (is_current_worktree_ref(maybe_worktree_ref))
    return REF_WORKTREE_CURRENT;
",,
implicit_predicate,refs.c,909,+,-,"if (is_current_worktree_ref(*bare_refname))
    return REF_WORKTREE_OTHER;
",,
implicit_predicate,refs.c,921,+,-,"if (is_current_worktree_ref(maybe_worktree_ref))
    return REF_WORKTREE_CURRENT;
",,
implicit_predicate,refs.c,933,+,-,"while ((c = *msg++)){
    if (wasspace && isspace(c))
        continue;

    wasspace = isspace(c);
    if (wasspace)
        c = ' ';

    strbuf_addch(sb, c);
}
",,
implicit_predicate,refs.c,937,+,-,"if (wasspace)
    c = ' ';
",,
implicit_predicate,refs.c,970,+,-,"while ((c = *msg++)){
    if (wasspace && isspace(c))
        continue;

    wasspace = isspace(c);
    if (wasspace)
        c = ' ';

    strbuf_addch(sb, c);
}
",,
implicit_predicate,refs.c,974,+,-,"if (wasspace)
    c = ' ';
",,
implicit_predicate,refs.c,1101,+,-,"if (cb.found_it)
    return 0;
",,
implicit_predicate,refs.c,1138,+,-,"if (cb.found_it)
    return 0;
",,
implicit_predicate,refs.c,1259,-,+,,12,	flags |= (new_oid ? REF_HAVE_NEW : 0) | (old_oid ? REF_HAVE_OLD : 0);
implicit_predicate,refs.c,1260,-,+,,12,	flags |= (new_target ? REF_HAVE_NEW : 0) | (old_target ? REF_HAVE_OLD : 0);
implicit_predicate,refs.c,1291,+,-,"if (ret){
    const char* str = _(""update_ref failed for ref '%s': %s"");
    switch (onerr){
        case UPDATE_REFS_MSG_ON_ERR:
            error(str, refname, err.buf);
            break;
        case UPDATE_REFS_DIE_ON_ERR:
            die(str, refname, err.buf);
            break;
        case UPDATE_REFS_QUIET_ON_ERR:
            break;
    }
    strbuf_release(&err);
    return 1;
}
",,
implicit_predicate,refs.c,1328,+,-,"if (ret){
    const char* str = _(""update_ref failed for ref '%s': %s"");
    switch (onerr){
        case UPDATE_REFS_MSG_ON_ERR:
            error(str, refname, err.buf);
            break;
        case UPDATE_REFS_DIE_ON_ERR:
            die(str, refname, err.buf);
            break;
        case UPDATE_REFS_QUIET_ON_ERR:
            break;
    }
    strbuf_release(&err);
    return 1;
}
",,
implicit_predicate,refs.c,1373,+,-,"if (strict)
    rules_to_fail = NUM_REV_PARSE_RULES;
",,
implicit_predicate,refs.c,1410,+,-,"if (strict)
    rules_to_fail = NUM_REV_PARSE_RULES;
",,
implicit_predicate,refs.c,1546,+,-,"if (ref_paranoia){
    flags |= DO_FOR_EACH_INCLUDE_BROKEN;
    flags |= DO_FOR_EACH_OMIT_DANGLING_SYMREFS;
}
",,
implicit_predicate,refs.c,1557,+,-,"if (trim)
    iter = prefix_ref_iterator_begin(iter, """", trim);
",,
implicit_predicate,refs.c,1583,+,-,"if (ref_paranoia){
    flags |= DO_FOR_EACH_INCLUDE_BROKEN;
    flags |= DO_FOR_EACH_OMIT_DANGLING_SYMREFS;
}
",,
implicit_predicate,refs.c,1594,+,-,"if (trim)
    iter = prefix_ref_iterator_begin(iter, """", trim);
",,
implicit_predicate,refs.c,1748,+,-,"if (is_pseudo_ref(refname))
    return refs_read_special_head(ref_store, refname, oid, referent, type, failure_errno);
",,
implicit_predicate,refs.c,1800,+,-,"if (refs_read_raw_ref(refs, refname, oid, &sb_refname, &read_flags, &failure_errno)){
    *flags |= read_flags;
    if (resolve_flags & RESOLVE_REF_READING)
        return NULL;

    if (failure_errno != ENOENT && failure_errno != EISDIR && failure_errno != ENOTDIR)
        return NULL;

    oidclr(oid);
    if (*flags & REF_BAD_NAME)
        *flags |= REF_ISBROKEN;

    return refname;
}
",,
implicit_predicate,refs.c,1827,+,-,"if (is_pseudo_ref(refname))
    return refs_read_special_head(ref_store, refname, oid, referent, type, failure_errno);
",,
implicit_predicate,refs.c,1879,+,-,"if (refs_read_raw_ref(refs, refname, oid, &sb_refname, &read_flags, &failure_errno)){
    *flags |= read_flags;
    if (resolve_flags & RESOLVE_REF_READING)
        return NULL;

    if (failure_errno != ENOENT && failure_errno != EISDIR && failure_errno != ENOTDIR)
        return NULL;

    oidclr(oid);
    if (*flags & REF_BAD_NAME)
        *flags |= REF_ISBROKEN;

    return refname;
}
",,
implicit_predicate,refs.c,1973,-,+,,9,	name = keydata ? keydata : e2->name;
implicit_predicate,refs.c,2012,-,+,,9,	return entry ? entry->refs : NULL;
implicit_predicate,refs.c,2116,+,-,"if (ret)
    return ret;
",,
implicit_predicate,refs.c,2130,-,+,,7,"	id = wt->id ? wt->id : ""/"";"
implicit_predicate,refs.c,2171,-,+,,9,"	return peel_object(base, peeled) ? -1 : 0;"
implicit_predicate,refs.c,2188,+,-,"if (ret)
    return ret;
",,
implicit_predicate,refs.c,2192,+,-,"if (ret){
    ref_transaction_abort(transaction, err);
    die(_(""ref updates aborted by hook""));
}
",,
implicit_predicate,refs.c,2237,+,-,"if (ret)
    return ret;
",,
implicit_predicate,refs.c,2238,+,-,"if (ret)
    return ret;
",,
implicit_predicate,refs.c,2310,+,-,"if (ret)
    return ret;
",,
implicit_predicate,refs.c,2314,+,-,"if (ret){
    ref_transaction_abort(transaction, err);
    die(_(""ref updates aborted by hook""));
}
",,
implicit_predicate,refs.c,2359,+,-,"if (ret)
    return ret;
",,
implicit_predicate,refs.c,2474,+,-,"if (ret){
    warning(_(""could not delete reference %s: %s""), item->string, err.buf);
    strbuf_reset(&err);
    failures = 1;
}
",,
implicit_predicate,refs.c,2483,+,-,"if (ret){
    if (refnames->nr == 1)
        error(_(""could not delete reference %s: %s""), refnames->items[0].string, err.buf);
    else
        error(_(""could not delete references: %s""), err.buf);
}
",,
implicit_predicate,refs.c,2564,-,+,,6,"		   (update->flags & REF_HAVE_OLD) ? &update->old_oid : NULL,"
implicit_predicate,refs.c,2565,-,+,,6,"		   (update->flags & REF_HAVE_NEW) ? &update->new_oid : NULL,"
implicit_predicate,refs.c,2598,+,-,"if (ret){
    warning(_(""could not delete reference %s: %s""), item->string, err.buf);
    strbuf_reset(&err);
    failures = 1;
}
",,
implicit_predicate,refs.c,2607,+,-,"if (ret){
    if (refnames->nr == 1)
        error(_(""could not delete reference %s: %s""), refnames->items[0].string, err.buf);
    else
        error(_(""could not delete references: %s""), err.buf);
}
",,
implicit_predicate,refspec.c,68,-,+,,10,	llen = (rhs ? (rhs - lhs - 1) : strlen(lhs));
implicit_predicate,refspec.c,82,+,+,is_glob ? REFNAME_REFSPEC_PATTERN : 0,36,	flags = REFNAME_ALLOW_ONELEVEL | (is_glob ? REFNAME_REFSPEC_PATTERN : 0);
implicit_predicate,refspec.c,106,+,-,"if (fetch){
    struct object_id unused;
    if (!*item->src);

    else
        if (llen == the_hash_algo->hexsz && !get_oid_hex(item->src, &unused))
            item->exact_sha1 = 1;
        else
            if (!check_refname_format(item->src, flags));

            else
                return 0;

    if (!item->dst);

    else
        if (!*item->dst);

        else
            if (!check_refname_format(item->dst, flags));

            else
                return 0;
}else{
    if (!*item->src);

    else
        if (is_glob){
            if (check_refname_format(item->src, flags))
                return 0;
        }else;


    if (!item->dst){
        if (check_refname_format(item->src, flags))
            return 0;
    }else
        if (!*item->dst){
            return 0;
        }else{
            if (check_refname_format(item->dst, flags))
                return 0;
        }
}
",,
implicit_predicate,refspec.c,137,+,-,"if (is_glob){
    if (check_refname_format(item->src, flags))
        return 0;
}else;

",,
implicit_predicate,reftable-backend.c,159,-,+,,25,		log_all_ref_updates = is_bare_repository() ? LOG_REFS_NONE : LOG_REFS_NORMAL;
implicit_predicate,reftable-backend.c,211,+,-,"if (ret)
    goto done;
",,
implicit_predicate,reftable-backend.c,267,+,-,"if (refs->err)
    goto done;
",,
implicit_predicate,reftable-backend.c,278,+,-,"if (is_worktree){
    strbuf_reset(&path);
    strbuf_addf(&path, ""%s/reftable"", gitdir);
    refs->err = reftable_new_stack(&refs->worktree_stack, path.buf, refs->write_options);
    if (refs->err)
        goto done;
}
",,
implicit_predicate,reftable-backend.c,284,+,-,"if (refs->err)
    goto done;
",,
implicit_predicate,reftable-backend.c,307,+,-,"if (refs->err)
    goto done;
",,
implicit_predicate,reftable-backend.c,318,+,-,"if (is_worktree){
    strbuf_reset(&path);
    strbuf_addf(&path, ""%s/reftable"", gitdir);
    refs->err = reftable_new_stack(&refs->worktree_stack, path.buf, &refs->write_options);
    if (refs->err)
        goto done;
}
",,
implicit_predicate,reftable-backend.c,324,+,-,"if (refs->err)
    goto done;
",,
implicit_predicate,reftable-backend.c,348,+,-,"if (iter->err)
    break;
",,
implicit_predicate,reftable-backend.c,409,+,-,"if (iter->err)
    break;
",,
implicit_predicate,reftable-backend.c,471,-,+,,21,	iter->prefix_len = prefix ? strlen(prefix) : 0;
implicit_predicate,reftable-backend.c,477,+,-,"if (ret)
    goto done;
",,
implicit_predicate,reftable-backend.c,481,+,-,"if (ret)
    goto done;
",,
implicit_predicate,reftable-backend.c,487,+,-,"if (ret)
    goto done;
",,
implicit_predicate,reftable-backend.c,537,+,-,"if (ret)
    goto done;
",,
implicit_predicate,reftable-backend.c,541,+,-,"if (ret)
    goto done;
",,
implicit_predicate,reftable-backend.c,543,+,-,"if (ret)
    return ret;
",,
implicit_predicate,reftable-backend.c,546,+,-,"if (ret)
    goto done;
",,
implicit_predicate,reftable-backend.c,568,+,-,"if (ret)
    return ret;
",,
implicit_predicate,reftable-backend.c,602,+,-,"if (ret)
    return ret;
",,
implicit_predicate,reftable-backend.c,627,+,-,"if (ret)
    return ret;
",,
implicit_predicate,reftable-backend.c,640,+,-,"if (ret)
    return ret;
",,
implicit_predicate,reftable-backend.c,644,+,-,"if (ret){
    if (ret == REFTABLE_LOCK_ERROR)
        strbuf_addstr(err, ""cannot lock references"");

    return ret;
}
",,
implicit_predicate,reftable-backend.c,699,+,-,"if (ret)
    return ret;
",,
implicit_predicate,reftable-backend.c,703,+,-,"if (ret){
    if (ret == REFTABLE_LOCK_ERROR)
        strbuf_addstr(err, ""cannot lock references"");

    return ret;
}
",,
implicit_predicate,reftable-backend.c,728,+,-,"if (ret)
    goto done;
",,
implicit_predicate,reftable-backend.c,787,+,-,"if (ret)
    goto done;
",,
implicit_predicate,reftable-backend.c,849,+,-,"if (ret)
    goto done;
",,
implicit_predicate,reftable-backend.c,908,+,-,"if (ret)
    goto done;
",,
implicit_predicate,reftable-backend.c,971,+,-,"if (ret)
    goto done;
",,
implicit_predicate,reftable-backend.c,1030,+,-,"if (ret)
    goto done;
",,
implicit_predicate,reftable-backend.c,1083,+,-,"if (ret)
    goto done;
",,
implicit_predicate,reftable-backend.c,1103,+,-,"if (create_reflog){
    ALLOC_GROW(logs, logs_nr + 1, logs_alloc);
    log = &logs[logs_nr++];
    memset(log, 0, sizeof (*log));
    fill_reftable_log_record(log, &committer_ident);
    log->update_index = ts;
    log->refname = xstrdup(u->refname);
    memcpy(log->value.update.new_hash, u->new_oid.hash, GIT_MAX_RAWSZ);
    memcpy(log->value.update.old_hash, tx_update->current_oid.hash, GIT_MAX_RAWSZ);
    log->value.update.message = xstrndup(u->msg, arg->refs->write_options.block_size / 2);
}
",,
implicit_predicate,reftable-backend.c,1142,+,-,"if (ret)
    goto done;
",,
implicit_predicate,reftable-backend.c,1162,+,-,"if (create_reflog){
    ALLOC_GROW(logs, logs_nr + 1, logs_alloc);
    log = &logs[logs_nr++];
    memset(log, 0, sizeof (*log));
    fill_reftable_log_record(log, &committer_ident);
    log->update_index = ts;
    log->refname = xstrdup(u->refname);
    memcpy(log->value.update.new_hash, u->new_oid.hash, GIT_MAX_RAWSZ);
    memcpy(log->value.update.old_hash, tx_update->current_oid.hash, GIT_MAX_RAWSZ);
    log->value.update.message = xstrndup(u->msg, arg->refs->write_options.block_size / 2);
}
",,
implicit_predicate,reftable-backend.c,1209,+,-,"if (ret){
    strbuf_addf(err, _(""reftable: transaction failure: %s""), reftable_error_str(ret));
    return -1;
}
",,
implicit_predicate,reftable-backend.c,1232,+,-,"if (refs->err)
    return refs->err;
",,
implicit_predicate,reftable-backend.c,1250,+,-,"if (ret)
    goto out;
",,
implicit_predicate,reftable-backend.c,1268,+,-,"if (ret){
    strbuf_addf(err, _(""reftable: transaction failure: %s""), reftable_error_str(ret));
    return -1;
}
",,
implicit_predicate,reftable-backend.c,1291,+,-,"if (refs->err)
    return refs->err;
",,
implicit_predicate,reftable-backend.c,1309,+,-,"if (ret)
    goto out;
",,
implicit_predicate,reftable-backend.c,1316,+,-,"if (arg->delete_old)
    string_list_insert(&skip, arg->oldname);
",,
implicit_predicate,reftable-backend.c,1334,+,-,"if (arg->delete_old)
    creation_ts++;
",,
implicit_predicate,reftable-backend.c,1345,+,-,"if (arg->delete_old){
    refs[1].refname = (char*)arg->oldname;
    refs[1].value_type = REFTABLE_REF_DELETION;
    refs[1].update_index = deletion_ts;
}
",,
implicit_predicate,reftable-backend.c,1350,+,+,arg->delete_old ? 2 : 1,47,"	ret = reftable_writer_add_refs(writer, refs, arg->delete_old ? 2 : 1);"
implicit_predicate,reftable-backend.c,1360,+,-,"if (arg->delete_old){
    struct strbuf head_referent = STRBUF_INIT;
    struct object_id head_oid;
    int append_head_reflog;
    unsigned head_type = 0;
    ALLOC_GROW(logs, logs_nr + 1, logs_alloc);
    memset(&logs[logs_nr], 0, sizeof (logs[logs_nr]));
    fill_reftable_log_record(&logs[logs_nr], &committer_ident);
    logs[logs_nr].refname = (char*)arg->newname;
    logs[logs_nr].update_index = deletion_ts;
    logs[logs_nr].value.update.message = xstrndup(arg->logmsg, arg->refs->write_options.block_size / 2);
    memcpy(logs[logs_nr].value.update.old_hash, old_ref.value.val1, GIT_MAX_RAWSZ);
    logs_nr++;
    ret = read_ref_without_reload(arg->stack, ""HEAD"", &head_oid, &head_referent, &head_type);
    if (ret < 0)
        goto done;

    append_head_reflog = (head_type & REF_ISSYMREF) && !strcmp(head_referent.buf, arg->oldname);
    strbuf_release(&head_referent);
    if (append_head_reflog){
        ALLOC_GROW(logs, logs_nr + 1, logs_alloc);
        logs[logs_nr] = logs[logs_nr - 1];
        logs[logs_nr].refname = ""HEAD"";
        logs_nr++;
    }
}
",,
implicit_predicate,reftable-backend.c,1374,+,-,"if (arg->delete_old)
    string_list_insert(&skip, arg->oldname);
",,
implicit_predicate,reftable-backend.c,1387,+,-,"if (append_head_reflog){
    ALLOC_GROW(logs, logs_nr + 1, logs_alloc);
    logs[logs_nr] = logs[logs_nr - 1];
    logs[logs_nr].refname = ""HEAD"";
    logs_nr++;
}
",,
implicit_predicate,reftable-backend.c,1392,+,-,"if (arg->delete_old)
    creation_ts++;
",,
implicit_predicate,reftable-backend.c,1403,+,-,"if (arg->delete_old){
    refs[1].refname = (char*)arg->oldname;
    refs[1].value_type = REFTABLE_REF_DELETION;
    refs[1].update_index = deletion_ts;
}
",,
implicit_predicate,reftable-backend.c,1408,+,-,arg->delete_old ? 2 : 1,,
implicit_predicate,reftable-backend.c,1417,+,-,"while (1){
    ret = reftable_iterator_next_log(&it, &old_log);
    if (ret < 0)
        goto done;

    if (ret > 0 || strcmp(old_log.refname, arg->oldname)){
        ret = 0;
        break;
    }
    free(old_log.refname);
    ALLOC_GROW(logs, logs_nr + 1, logs_alloc);
    logs[logs_nr] = old_log;
    logs[logs_nr].refname = (char*)arg->newname;
    logs_nr++;
    if (arg->delete_old){
        ALLOC_GROW(logs, logs_nr + 1, logs_alloc);
        memset(&logs[logs_nr], 0, sizeof (logs[logs_nr]));
        logs[logs_nr].refname = (char*)arg->oldname;
        logs[logs_nr].value_type = REFTABLE_LOG_DELETION;
        logs[logs_nr].update_index = old_log.update_index;
        logs_nr++;
    }
    memset(&old_log, 0, sizeof (old_log));
}
",,
implicit_predicate,reftable-backend.c,1418,+,-,"if (arg->delete_old){
    struct strbuf head_referent = STRBUF_INIT;
    struct object_id head_oid;
    int append_head_reflog;
    unsigned head_type = 0;
    ALLOC_GROW(logs, logs_nr + 1, logs_alloc);
    memset(&logs[logs_nr], 0, sizeof (logs[logs_nr]));
    fill_reftable_log_record(&logs[logs_nr], &committer_ident);
    logs[logs_nr].refname = (char*)arg->newname;
    logs[logs_nr].update_index = deletion_ts;
    logs[logs_nr].value.update.message = xstrndup(arg->logmsg, arg->refs->write_options.block_size / 2);
    memcpy(logs[logs_nr].value.update.old_hash, old_ref.value.val1, GIT_MAX_RAWSZ);
    logs_nr++;
    ret = read_ref_without_reload(arg->stack, ""HEAD"", &head_oid, &head_referent, &head_type);
    if (ret < 0)
        goto done;

    append_head_reflog = (head_type & REF_ISSYMREF) && !strcmp(head_referent.buf, arg->oldname);
    strbuf_release(&head_referent);
    if (append_head_reflog){
        ALLOC_GROW(logs, logs_nr + 1, logs_alloc);
        logs[logs_nr] = logs[logs_nr - 1];
        logs[logs_nr].refname = ""HEAD"";
        logs_nr++;
    }
}
",,
implicit_predicate,reftable-backend.c,1439,+,-,"if (arg->delete_old){
    ALLOC_GROW(logs, logs_nr + 1, logs_alloc);
    memset(&logs[logs_nr], 0, sizeof (logs[logs_nr]));
    logs[logs_nr].refname = (char*)arg->oldname;
    logs[logs_nr].value_type = REFTABLE_LOG_DELETION;
    logs[logs_nr].update_index = old_log.update_index;
    logs_nr++;
}
",,
implicit_predicate,reftable-backend.c,1445,+,-,"if (append_head_reflog){
    ALLOC_GROW(logs, logs_nr + 1, logs_alloc);
    logs[logs_nr] = logs[logs_nr - 1];
    logs[logs_nr].refname = ""HEAD"";
    logs_nr++;
}
",,
implicit_predicate,reftable-backend.c,1476,+,-,"while (1){
    ret = reftable_iterator_next_log(&it, &old_log);
    if (ret < 0)
        goto done;

    if (ret > 0 || strcmp(old_log.refname, arg->oldname)){
        ret = 0;
        break;
    }
    free(old_log.refname);
    ALLOC_GROW(logs, logs_nr + 1, logs_alloc);
    logs[logs_nr] = old_log;
    logs[logs_nr].refname = (char*)arg->newname;
    logs_nr++;
    if (arg->delete_old){
        ALLOC_GROW(logs, logs_nr + 1, logs_alloc);
        memset(&logs[logs_nr], 0, sizeof (logs[logs_nr]));
        logs[logs_nr].refname = (char*)arg->oldname;
        logs[logs_nr].value_type = REFTABLE_LOG_DELETION;
        logs[logs_nr].update_index = old_log.update_index;
        logs_nr++;
    }
    memset(&old_log, 0, sizeof (old_log));
}
",,
implicit_predicate,reftable-backend.c,1498,+,-,"if (arg->delete_old){
    ALLOC_GROW(logs, logs_nr + 1, logs_alloc);
    memset(&logs[logs_nr], 0, sizeof (logs[logs_nr]));
    logs[logs_nr].refname = (char*)arg->oldname;
    logs[logs_nr].value_type = REFTABLE_LOG_DELETION;
    logs[logs_nr].update_index = old_log.update_index;
    logs_nr++;
}
",,
implicit_predicate,reftable-backend.c,1500,+,-,"if (ret)
    goto done;
",,
implicit_predicate,reftable-backend.c,1531,+,-,"if (ret)
    goto done;
",,
implicit_predicate,reftable-backend.c,1556,+,-,"if (iter->err)
    break;
",,
implicit_predicate,reftable-backend.c,1559,+,-,"if (ret)
    goto done;
",,
implicit_predicate,reftable-backend.c,1590,+,-,"if (ret)
    goto done;
",,
implicit_predicate,reftable-backend.c,1615,+,-,"if (iter->err)
    break;
",,
implicit_predicate,reftable-backend.c,1629,+,-,"if (ret)
    goto done;
",,
implicit_predicate,reftable-backend.c,1687,+,-,"if (ret)
    goto done;
",,
implicit_predicate,reftable-backend.c,1716,+,-,"if (ret)
    break;
",,
implicit_predicate,reftable-backend.c,1762,+,-,"if (ret)
    goto done;
",,
implicit_predicate,reftable-backend.c,1772,+,-,"if (ret)
    break;
",,
implicit_predicate,reftable-backend.c,1817,+,-,"if (ret)
    goto done;
",,
implicit_predicate,reftable-backend.c,1874,+,-,"if (ret)
    goto done;
",,
implicit_predicate,reftable-backend.c,1929,+,-,"if (ret)
    goto done;
",,
implicit_predicate,reftable-backend.c,1940,+,-,"if (ret)
    return ret;
",,
implicit_predicate,reftable-backend.c,1995,+,-,"if (ret)
    return ret;
",,
implicit_predicate,reftable-backend.c,2004,+,-,"if (ret)
    return ret;
",,
implicit_predicate,reftable-backend.c,2010,+,-,"if (ret)
    return ret;
",,
implicit_predicate,reftable-backend.c,2060,+,-,"if (ret)
    return ret;
",,
implicit_predicate,reftable-backend.c,2066,+,-,"if (ret)
    return ret;
",,
implicit_predicate,reftable-backend.c,2075,+,-,"while (1){
    struct reftable_log_record log = {0};
    struct object_id old_oid, new_oid;
    ret = reftable_iterator_next_log(&it, &log);
    if (ret < 0)
        goto done;

    if (ret > 0 || strcmp(log.refname, refname)){
        reftable_log_record_release(&log);
        break;
    }
    oidread(&old_oid, log.value.update.old_hash);
    oidread(&new_oid, log.value.update.new_hash);
    if (is_null_oid(&old_oid) && is_null_oid(&new_oid)){
        reftable_log_record_release(&log);
        continue;
    }
    ALLOC_GROW(logs, logs_nr + 1, logs_alloc);
    logs[logs_nr++] = log;
}
",,
implicit_predicate,reftable-backend.c,2132,+,-,"while (1){
    struct reftable_log_record log = {0};
    struct object_id old_oid, new_oid;
    ret = reftable_iterator_next_log(&it, &log);
    if (ret < 0)
        goto done;

    if (ret > 0 || strcmp(log.refname, refname)){
        reftable_log_record_release(&log);
        break;
    }
    oidread(&old_oid, log.value.update.old_hash);
    oidread(&new_oid, log.value.update.new_hash);
    if (is_null_oid(&old_oid) && is_null_oid(&new_oid)){
        reftable_log_record_release(&log);
        continue;
    }
    ALLOC_GROW(logs, logs_nr + 1, logs_alloc);
    logs[logs_nr++] = log;
}
",,
implicit_predicate,regcomp.c,317,+,-,"if (icase)
    fastmap[tolower(ch)] = 1;
",,
implicit_predicate,regcomp.c,3123,+,-,"while (1){
    bracket_elem_t start_elem, end_elem;
    unsigned char start_name_buf[BRACKET_NAME_BUF_SIZE];
    unsigned char end_name_buf[BRACKET_NAME_BUF_SIZE];
    reg_errcode_t ret;
    int token_len2 = 0, is_range_exp = 0;
    re_token_t token2;
    start_elem.opr.name = start_name_buf;
    ret = parse_bracket_element(&start_elem, regexp, token, token_len, dfa, syntax, first_round);
    if (BE(ret != REG_NOERROR, 0)){
        *err = ret;
        goto parse_bracket_exp_free_return;
    }
    first_round = 0;
    token_len = peek_token_bracket(token, regexp, syntax);
    if (start_elem.type != CHAR_CLASS && start_elem.type != EQUIV_CLASS){
        if (BE(token->type == END_OF_RE, 0)){
            *err = REG_EBRACK;
            goto parse_bracket_exp_free_return;
        }
        if (token->type == OP_CHARSET_RANGE){
            re_string_skip_bytes(regexp, token_len);
            token_len2 = peek_token_bracket(&token2, regexp, syntax);
            if (BE(token2.type == END_OF_RE, 0)){
                *err = REG_EBRACK;
                goto parse_bracket_exp_free_return;
            }
            if (token2.type == OP_CLOSE_BRACKET){
                re_string_skip_bytes(regexp, -token_len);
                token->type = CHARACTER;
            }else
                is_range_exp = 1;
        }
    }
    if (is_range_exp == 1){
        end_elem.opr.name = end_name_buf;
        ret = parse_bracket_element(&end_elem, regexp, &token2, token_len2, dfa, syntax, 1);
        if (BE(ret != REG_NOERROR, 0)){
            *err = ret;
            goto parse_bracket_exp_free_return;
        }
        token_len = peek_token_bracket(token, regexp, syntax);
        *err = build_range_exp(sbcset, &start_elem, &end_elem);
        if (BE(*err != REG_NOERROR, 0))
            goto parse_bracket_exp_free_return;
    }else{
        switch (start_elem.type){
            case SB_CHAR:
                bitset_set(sbcset, start_elem.opr.ch);
                break;
            case EQUIV_CLASS:
                *err = build_equiv_class(sbcset, start_elem.opr.name);
                if (BE(*err != REG_NOERROR, 0))
                    goto parse_bracket_exp_free_return;

                break;
            case COLL_SYM:
                *err = build_collating_symbol(sbcset, start_elem.opr.name);
                if (BE(*err != REG_NOERROR, 0))
                    goto parse_bracket_exp_free_return;

                break;
            case CHAR_CLASS:
                *err = build_charclass(regexp->trans, sbcset, (const char*)start_elem.opr.name, syntax);
                if (BE(*err != REG_NOERROR, 0))
                    goto parse_bracket_exp_free_return;

                break;
            default:
                assert(0);
                break;
        }
    }
    if (BE(token->type == END_OF_RE, 0)){
        *err = REG_EBRACK;
        goto parse_bracket_exp_free_return;
    }
    if (token->type == OP_CLOSE_BRACKET)
        break;
}
",,
implicit_predicate,regcomp.c,3271,+,-,"if (non_match)
    bitset_not(sbcset);
",,
implicit_predicate,regcomp.c,3580,+,-,"BUILD_CHARCLASS_LOOP (isalnum);
",,
implicit_predicate,regcomp.c,3582,+,-,"BUILD_CHARCLASS_LOOP (iscntrl);
",,
implicit_predicate,regcomp.c,3584,+,-,"BUILD_CHARCLASS_LOOP (islower);
",,
implicit_predicate,regcomp.c,3586,+,-,"BUILD_CHARCLASS_LOOP (isspace);
",,
implicit_predicate,regcomp.c,3588,+,-,"BUILD_CHARCLASS_LOOP (isalpha);
",,
implicit_predicate,regcomp.c,3590,+,-,"BUILD_CHARCLASS_LOOP (isdigit);
",,
implicit_predicate,regcomp.c,3592,+,-,"BUILD_CHARCLASS_LOOP (isprint);
",,
implicit_predicate,regcomp.c,3594,+,-,"BUILD_CHARCLASS_LOOP (isupper);
",,
implicit_predicate,regcomp.c,3597,+,-,"BUILD_CHARCLASS_LOOP (isblank);
",,
implicit_predicate,regcomp.c,3603,+,-,"BUILD_CHARCLASS_LOOP (isgraph);
",,
implicit_predicate,regcomp.c,3605,+,-,"BUILD_CHARCLASS_LOOP (ispunct);
",,
implicit_predicate,regcomp.c,3607,+,-,"BUILD_CHARCLASS_LOOP (isxdigit);
",,
implicit_predicate,regcomp.c,3644,+,-,"if (non_match){
}
",,
implicit_predicate,regcomp.c,3672,+,-,"if (non_match)
    bitset_not(sbcset);
",,
implicit_predicate,regcomp.c,3732,+,-,"while (1){
    fetch_token(token, input, syntax);
    c = token->opr.c;
    if (BE(token->type == END_OF_RE, 0))
        return -2;

    if (token->type == OP_CLOSE_DUP_NUM || c == ',')
        break;

    num = ((token->type != CHARACTER || c < '0' || '9' < c || num == -2) ? -2 : ((num == -1) ? c - '0' : num * 10 + c - '0'));
    num = (num > RE_DUP_MAX) ? -2 : num;
}
",,
implicit_predicate,regexec.c,388,+,-,"if (free_str)
    re_free((char*)str);
",,
implicit_predicate,regexec.c,471,+,-,"if (ret_len){
    assert(pmatch[0].rm_so == start);
    rval = pmatch[0].rm_eo - start;
}else
    rval = pmatch[0].rm_so;
",,
implicit_predicate,regexec.c,571,+,-,"if (num_regs){
    bufp->regs_allocated = REGS_REALLOCATE;
    regs->num_regs = num_regs;
    regs->start = starts;
    regs->end = ends;
}else{
    bufp->regs_allocated = REGS_UNALLOCATED;
    regs->num_regs = 0;
    regs->start = regs->end = (regoff_t*)0;
}
",,
implicit_predicate,regexec.c,800,+,-,"if (fastmap[ch])
    break;
",,
implicit_predicate,regexec.c,972,+,-,"while (1){
    memset(lim_states, '\0', sizeof (re_dfastate_t*) * (match_last + 1));
    sift_ctx_init(&sctx, sifted_states, lim_states, halt_node, match_last);
    ret = sift_states_backward(mctx, &sctx);
    re_node_set_free(&sctx.limits);
    if (BE(ret != REG_NOERROR, 0))
        goto free_return;

    if (sifted_states[0] != NULL || lim_states[0] != NULL)
        break;

    do{
        --match_last;
        if (match_last < 0){
            ret = REG_NOMATCH;
            goto free_return;
        }
    } while (mctx->state_log[match_last] == NULL || !mctx->state_log[match_last]->halt);
    halt_node = check_halt_state_context(mctx, mctx->state_log[match_last], match_last);
}
",,
implicit_predicate,remote-curl.c,258,+,+,for_push ? REF_NORMAL : 0,36,"		get_remote_heads(&reader, &list, for_push ? REF_NORMAL : 0,"
implicit_predicate,remote-curl.c,529,+,-,"if (maybe_smart)
    check_smart_http(last, service, &type);
",,
implicit_predicate,remote-curl.c,532,+,-,"if (last->proto_git)
    last->refs = parse_git_refs(last, for_push);
else
    last->refs = parse_info_refs(last);
",,
implicit_predicate,remote-curl.c,552,+,-,"if (for_push)
    heads = discover_refs(""git-receive-pack"", for_push);
else
    heads = discover_refs(""git-upload-pack"", for_push);
",,
implicit_predicate,remote-curl.c,632,+,-,"if (rpc->write_line_lengths){
    left = rpc->alloc - rpc->len - 4;
    buf = rpc->buf + rpc->len + 4;
}else{
    left = rpc->alloc - rpc->len;
    buf = rpc->buf + rpc->len;
}
",,
implicit_predicate,remote-curl.c,646,+,+,rpc->write_line_lengths ? 4 : 0,29,		*appended = pktlen_raw + (rpc->write_line_lengths ? 4 : 0);
implicit_predicate,remote-curl.c,650,+,-,"if (rpc->write_line_lengths){
    switch (*status){
        case PACKET_READ_EOF:
            if (!(options & PACKET_READ_GENTLE_ON_EOF))
                die(_(""shouldn't have EOF when not gentle on EOF""));

            break;
        case PACKET_READ_NORMAL:
            set_packet_header(buf - 4, *appended);
            break;
        case PACKET_READ_DELIM:
            memcpy(buf - 4, ""0001"", 4);
            break;
        case PACKET_READ_FLUSH:
            memcpy(buf - 4, ""0000"", 4);
            break;
        case PACKET_READ_RESPONSE_END:
            die(_(""remote server sent unexpected response end packet""));
    }
}
",,
implicit_predicate,remote-curl.c,697,+,-,"if (rpc->flush_read_but_not_sent){
    if (!avail){
        rpc->flush_read_but_not_sent = 0;
        return 0;
    }
}
",,
implicit_predicate,remote-curl.c,729,+,-,"if (rpc->initial_buffer){
    if (offset < 0 || offset > rpc->len){
        error(""curl seek would be outside of rpc buffer"");
        return CURL_SEEKFUNC_FAIL;
    }
    rpc->pos = offset;
    return CURL_SEEKFUNC_OK;
}
",,
implicit_predicate,remote-curl.c,775,+,-,"if (state->remaining){
    int remaining = state->remaining;
    if (remaining > size)
        remaining = size;

    ptr += remaining;
    size -= remaining;
    state->remaining -= remaining;
}
",,
implicit_predicate,remote-curl.c,811,+,-,"if (data->check_pktline)
    check_pktline(&data->pktline_state, ptr, size);
",,
implicit_predicate,remote-curl.c,905,+,-,"while (1){
    size_t n;
    enum packet_read_status status;
    if (!rpc_read_from_out(rpc, 0, &n, &status)){
        large_request = 1;
        use_gzip = 0;
        break;
    }
    if (status == PACKET_READ_FLUSH)
        break;
}
",,
implicit_predicate,remote-curl.c,919,+,-,"if (large_request){
    struct slot_results results;
    do{
        err = probe_rpc(rpc, &results);
        if (err == HTTP_REAUTH)
            credential_fill(&http_auth, 0);
    } while (err == HTTP_REAUTH);
    if (err != HTTP_OK)
        return -1;

    if (results.auth_avail & CURLAUTH_GSSNEGOTIATE || http_auth.authtype)
        needs_100_continue = 1;
}
",,
implicit_predicate,remote-curl.c,938,+,+,"needs_100_continue ? ""Expect: 100-continue"" : ""Expect:""",39,"	headers = curl_slist_append(headers, needs_100_continue ?
		""Expect: 100-continue"" : ""Expect:"");"
implicit_predicate,remote-curl.c,958,+,-,"if (large_request){
    rpc->initial_buffer = 1;
    curl_easy_setopt(slot->curl, CURLOPT_READFUNCTION, rpc_out);
    curl_easy_setopt(slot->curl, CURLOPT_INFILE, rpc);
    curl_easy_setopt(slot->curl, CURLOPT_SEEKFUNCTION, rpc_seek);
    curl_easy_setopt(slot->curl, CURLOPT_SEEKDATA, rpc);
    if (options.verbosity > 1){
        fprintf(stderr, ""POST %s (chunked)\n"", rpc->service_name);
        fflush (stderr);
    }
}else
    if (gzip_body){
        curl_easy_setopt(slot->curl, CURLOPT_POSTFIELDS, gzip_body);
        curl_easy_setopt(slot->curl, CURLOPT_POSTFIELDSIZE_LARGE, xcurl_off_t(gzip_size));
    }else
        if (use_gzip && 1024 < rpc->len){
            git_zstream stream;
            int ret;
            git_deflate_init_gzip(&stream, Z_BEST_COMPRESSION);
            gzip_size = git_deflate_bound(&stream, rpc->len);
            gzip_body = xmalloc(gzip_size);
            stream.next_in = (unsigned char*)rpc->buf;
            stream.avail_in = rpc->len;
            stream.next_out = (unsigned char*)gzip_body;
            stream.avail_out = gzip_size;
            ret = git_deflate(&stream, Z_FINISH);
            if (ret != Z_STREAM_END)
                die(_(""cannot deflate request; zlib deflate error %d""), ret);

            ret = git_deflate_end_gently(&stream);
            if (ret != Z_OK)
                die(_(""cannot deflate request; zlib end error %d""), ret);

            gzip_size = stream.total_out;
            headers = curl_slist_append(headers, ""Content-Encoding: gzip"");
            curl_easy_setopt(slot->curl, CURLOPT_POSTFIELDS, gzip_body);
            curl_easy_setopt(slot->curl, CURLOPT_POSTFIELDSIZE_LARGE, xcurl_off_t(gzip_size));
            if (options.verbosity > 1){
                fprintf(stderr, ""POST %s (gzip %lu to %lu bytes)\n"", rpc->service_name, (unsigned long )rpc->len, (unsigned long )gzip_size);
                fflush (stderr);
            }
        }else{
            curl_easy_setopt(slot->curl, CURLOPT_POSTFIELDS, rpc->buf);
            curl_easy_setopt(slot->curl, CURLOPT_POSTFIELDSIZE_LARGE, xcurl_off_t(rpc->len));
            if (options.verbosity > 1){
                fprintf(stderr, ""POST %s (%lu bytes)\n"", rpc->service_name, (unsigned long )rpc->len);
                fflush (stderr);
            }
        }
",,
implicit_predicate,remote-curl.c,1057,+,-,"if (rpc_in_data.pktline_state.len_filled)
    err = error(_(""%d bytes of length header were received""), rpc_in_data.pktline_state.len_filled);
",,
implicit_predicate,remote-curl.c,1059,+,-,"if (rpc_in_data.pktline_state.remaining)
    err = error(_(""%d bytes of body are still expected""), rpc_in_data.pktline_state.remaining);
",,
implicit_predicate,remote-curl.c,1062,+,-,"if (stateless_connect)
    packet_response_end(rpc->in);
",,
implicit_predicate,remote-curl.c,1167,+,+,"ret ? error(_(""fetch failed."")) : 0",9,"	return ret ? error(_(""fetch failed."")) : 0;"
implicit_predicate,remote-curl.c,1181,+,-,"if (options.followtags)
    strvec_push(&args, ""--include-tag"");
",,
implicit_predicate,remote-curl.c,1183,+,-,"if (options.thin)
    strvec_push(&args, ""--thin"");
",,
implicit_predicate,remote-curl.c,1187,+,-,"if (options.check_self_contained_and_connected)
    strvec_push(&args, ""--check-self-contained-and-connected"");
",,
implicit_predicate,remote-curl.c,1189,+,-,"if (options.cloning)
    strvec_push(&args, ""--cloning"");
",,
implicit_predicate,remote-curl.c,1191,+,-,"if (options.update_shallow)
    strvec_push(&args, ""--update-shallow"");
",,
implicit_predicate,remote-curl.c,1195,+,-,"if (options.depth)
    strvec_pushf(&args, ""--depth=%lu"", options.depth);
",,
implicit_predicate,remote-curl.c,1204,+,-,"if (options.from_promisor)
    strvec_push(&args, ""--from-promisor"");
",,
implicit_predicate,remote-curl.c,1206,+,-,"if (options.refetch)
    strvec_push(&args, ""--refetch"");
",,
implicit_predicate,remote-curl.c,1237,+,-,"if (d->proto_git)
    return fetch_git(d, nr_heads, to_fetch);
else
    return fetch_dumb(nr_heads, to_fetch);
",,
implicit_predicate,remote-curl.c,1250,+,-,"do{
    const char* p;
    if (skip_prefix(buf->buf, ""fetch "", &p)){
        const char* name;
        struct ref* ref;
        struct object_id old_oid;
        const char* q;
        if (parse_oid_hex(p, &old_oid, &q))
            die(_(""protocol error: expected sha/ref, got '%s'""), p);

        if (*q == ' ')
            name = q + 1;
        else
            if (!*q)
                name = """";
            else
                die(_(""protocol error: expected sha/ref, got '%s'""), p);

        ref = alloc_ref(name);
        oidcpy(&ref->old_oid, &old_oid);
        *list = ref;
        list = &ref->next;
        ALLOC_GROW(to_fetch, nr_heads + 1, alloc_heads);
        to_fetch[nr_heads++] = ref;
    }else
        die(_(""http transport does not support %s""), buf->buf);

    strbuf_reset(buf);
    if (strbuf_getline_lf(buf, stdin) == EOF)
        return;

    if (!*buf->buf)
        break;
} while (1);
",,
implicit_predicate,remote-curl.c,1286,+,-,"if (fetch(nr_heads, to_fetch))
    exit(128);
",,
implicit_predicate,remote-curl.c,1327,+,-,"if (options.dry_run)
    strvec_push(&child.args, ""--dry-run"");
",,
implicit_predicate,remote-curl.c,1353,+,-,"if (options.thin)
    strvec_push(&args, ""--thin"");
",,
implicit_predicate,remote-curl.c,1355,+,-,"if (options.dry_run)
    strvec_push(&args, ""--dry-run"");
",,
implicit_predicate,remote-curl.c,1361,+,-,"if (options.atomic)
    strvec_push(&args, ""--atomic"");
",,
implicit_predicate,remote-curl.c,1370,+,+,"options.progress ? ""--progress"" : ""--no-progress""",21,"	strvec_push(&args, options.progress ? ""--progress"" : ""--no-progress"");"
implicit_predicate,remote-curl.c,1375,+,-,"if (options.force_if_includes)
    strvec_push(&args, ""--force-if-includes"");
",,
implicit_predicate,remote-curl.c,1400,+,-,"if (heads->proto_git)
    ret = push_git(heads, nr_spec, specs);
else
    ret = push_dav(nr_spec, specs);
",,
implicit_predicate,remote-curl.c,1413,+,-,"do{
    const char* arg;
    if (skip_prefix(buf->buf, ""push "", &arg))
        strvec_push(&specs, arg);
    else
        die(_(""http transport does not support %s""), buf->buf);

    strbuf_reset(buf);
    if (strbuf_getline_lf(buf, stdin) == EOF)
        goto free_specs;

    if (!*buf->buf)
        break;
} while (1);
",,
implicit_predicate,remote-curl.c,1431,+,-,"if (ret)
    exit(128);
",,
implicit_predicate,remote-curl.c,1503,+,-,"while (1){
    size_t avail;
    enum packet_read_status status;
    if (!rpc_read_from_out(&rpc, PACKET_READ_GENTLE_ON_EOF, &avail, &status))
        BUG(""The entire rpc->buf should be larger than LARGE_PACKET_MAX"");

    if (status == PACKET_READ_EOF)
        break;

    if (post_rpc(&rpc, 1, status == PACKET_READ_FLUSH))
        break;

    rpc.len = 0;
}
",,
implicit_predicate,remote-curl.c,1565,+,-,"do{
    const char* arg;
    if (strbuf_getline_lf(&buf, stdin) == EOF){
        if (ferror (stdin))
            error(_(""remote-curl: error reading command stream from git""));

        goto cleanup;
    }
    if (buf.len == 0)
        break;

    if (starts_with(buf.buf, ""fetch "")){
        if (nongit){
            setup_git_directory_gently(&nongit);
            if (nongit)
                die(_(""remote-curl: fetch attempted without a local repo""));
        }
        parse_fetch(&buf);
    }else
        if (!strcmp(buf.buf, ""list"") || starts_with(buf.buf, ""list "")){
            int for_push = !!strstr(buf.buf + 4, ""for-push"");
            output_refs(get_refs(for_push));
        }else
            if (starts_with(buf.buf, ""push "")){
                parse_push(&buf);
            }else
                if (skip_prefix(buf.buf, ""option "", &arg)){
                    char* value = strchr(arg, ' ');
                    int result;
                    if (value)
                        *value++ = '\0';
                    else
                        value = ""true"";

                    result = set_option(arg, value);
                    if (!result)
                        printf(""ok\n"");
                    else
                        if (result < 0)
                            printf(""error invalid value\n"");
                        else
                            printf(""unsupported\n"");

                    fflush (stdout);
                }else
                    if (skip_prefix(buf.buf, ""get "", &arg)){
                        parse_get(arg);
                        fflush (stdout);
                    }else
                        if (!strcmp(buf.buf, ""capabilities"")){
                            printf(""stateless-connect\n"");
                            printf(""fetch\n"");
                            printf(""get\n"");
                            printf(""option\n"");
                            printf(""push\n"");
                            printf(""check-connectivity\n"");
                            printf(""object-format\n"");
                            printf(""\n"");
                            fflush (stdout);
                        }else
                            if (skip_prefix(buf.buf, ""stateless-connect "", &arg)){
                                if (!stateless_connect(arg))
                                    break;
                            }else{
                                error(_(""remote-curl: unknown command '%s' from git""), buf.buf);
                                goto cleanup;
                            }

    strbuf_reset(&buf);
} while (1);
",,
implicit_predicate,remote-curl.c,1576,+,-,"if (nongit){
    setup_git_directory_gently(&nongit);
    if (nongit)
        die(_(""remote-curl: fetch attempted without a local repo""));
}
",,
implicit_predicate,remote-curl.c,1578,+,-,"if (nongit)
    die(_(""remote-curl: fetch attempted without a local repo""));
",,
implicit_predicate,remote-ext.c,48,+,-,"if (escape){
    switch (str[rpos]){
        case ' ':
        case '%':
        case 's':
        case 'S':
            break;
        case 'G':
        case 'V':
            special = str[rpos];
            if (rpos == 1)
                break;

        default:
            die(""Bad remote-ext placeholder '%%%c'."", str[rpos]);
    }
    escape = 0;
}else
    escape = (str[rpos] == '%');
",,
implicit_predicate,remote-ext.c,80,+,+,special ? 2 : 0,9,	rpos = special ? 2 : 0;		/* Skip first 2 bytes in specials. */
implicit_predicate,remote-ext.c,83,+,-,"if (escape){
    switch (str[rpos]){
        case ' ':
        case '%':
            strbuf_addch(&ret, str[rpos]);
            break;
        case 's':
            strbuf_addstr(&ret, service_noprefix);
            break;
        case 'S':
            strbuf_addstr(&ret, service);
            break;
    }
    escape = 0;
}else
    switch (str[rpos]){
        case '%':
            escape = 1;
            break;
        default:
            strbuf_addch(&ret, str[rpos]);
            break;
    }
",,
implicit_predicate,remote-ext.c,170,+,-,"while (1){
    size_t i;
    const char* arg;
    if (!fgets(buffer, MAXCOMMAND - 1, stdin)){
        if (ferror (stdin))
            die(""Command input error"");

        exit(0);
    }
    i = strlen(buffer);
    while (i > 0 && isspace(buffer[i - 1]))
        buffer[--i] = 0;
    if (!strcmp(buffer, ""capabilities"")){
        printf(""*connect\n\n"");
        fflush (stdout);
    }else
        if (skip_prefix(buffer, ""connect "", &arg)){
            printf(""\n"");
            fflush (stdout);
            return run_child(child, arg);
        }else{
            fprintf(stderr, ""Bad command"");
            return 1;
        }
}
",,
implicit_predicate,remote-fd.c,28,+,-,"while (1){
    size_t i;
    if (!fgets(buffer, MAXCOMMAND - 1, stdin)){
        if (ferror (stdin))
            die(""Input error"");

        return;
    }
    i = strlen(buffer);
    while (i > 0 && isspace(buffer[i - 1]))
        buffer[--i] = 0;
    if (!strcmp(buffer, ""capabilities"")){
        printf(""*connect\n\n"");
        fflush (stdout);
    }else
        if (starts_with(buffer, ""connect "")){
            printf(""\n"");
            fflush (stdout);
            if (bidirectional_transfer_loop(input_fd, output_fd))
                die(""Copying data between file descriptors failed"");

            return;
        }else{
            die(""Bad command: %s"", buffer);
        }
}
",,
implicit_predicate,remote.c,100,+,-,"if (verbose)
    strvec_push(&cmd.args, ""-v"");
",,
implicit_predicate,remote.c,126,+,-,"if (mirror)
    strbuf_addf(tmp, ""refs/%s:refs/%s"", branchname, branchname);
else
    strbuf_addf(tmp, ""refs/heads/%s:refs/remotes/%s/%s"", branchname, remotename, branchname);
",,
implicit_predicate,remote.c,220,+,-,"if (mirror & MIRROR_PUSH){
    strbuf_reset(&buf);
    strbuf_addf(&buf, ""remote.%s.mirror"", name);
    git_config_set(buf.buf, ""true"");
}
",,
implicit_predicate,remote.c,487,-,+,,24,		info->dest = xstrdup(spec->dst ? spec->dst : item->string);
implicit_predicate,remote.c,499,+,-,"if (add_pushurl_aliases)
    add_pushurl_alias(remote_state, remote_state->remotes[i], remote_state->remotes[i]->url[j]);
",,
implicit_predicate,remote.c,501,+,-,"if (add_pushurl_aliases)
    add_pushurl_alias(remote_state, remote_state->remotes[i], remote_state->remotes[i]->url[j]);
",,
implicit_predicate,remote.c,658,+,-,"if (warn_not_die)
    warning(_(""URL '%s' uses plaintext credentials""), redacted.buf);
else
    die(_(""URL '%s' uses plaintext credentials""), redacted.buf);
",,
implicit_predicate,remote.c,660,+,-,"if (warn_not_die)
    warning(_(""URL '%s' uses plaintext credentials""), redacted.buf);
else
    die(_(""URL '%s' uses plaintext credentials""), redacted.buf);
",,
implicit_predicate,remote.c,737,+,-,"if (in_repo)
    return remote->configured_in_repo;
",,
implicit_predicate,remote.c,739,+,-,"if (in_repo)
    return remote->configured_in_repo;
",,
implicit_predicate,remote.c,795,+,-,"if (show_progress){
    progress = start_progress(_(""Renaming remote references""), rename.remote_branches->nr + rename.symrefs_nr);
}
",,
implicit_predicate,remote.c,900,+,+,find_src ? query->dst : query->src,23,	const char *needle = find_src ? query->dst : query->src;
implicit_predicate,remote.c,902,+,-,find_src ? query->dst : query->src,,
implicit_predicate,remote.c,927,-,+,,22,			const char *key = refspec->dst ? refspec->dst : refspec->src;
implicit_predicate,remote.c,930,+,-,"if (match_name_with_pattern(key, needle, value, &expn_name))
    string_list_append_nodup(&reversed, expn_name);
",,
implicit_predicate,remote.c,932,+,-,"if (match_name_with_pattern(key, needle, value, &expn_name))
    string_list_append_nodup(&reversed, expn_name);
",,
implicit_predicate,remote.c,962,+,-,"if (query_matches_negative_refspec(rs, query))
    return;
",,
implicit_predicate,remote.c,964,+,-,"if (query_matches_negative_refspec(rs, query))
    return;
",,
implicit_predicate,remote.c,967,+,+,find_src ? refspec->dst : refspec->src,21,		const char *key = find_src ? refspec->dst : refspec->src;
implicit_predicate,remote.c,968,+,+,find_src ? refspec->src : refspec->dst,23,		const char *value = find_src ? refspec->src : refspec->dst;
implicit_predicate,remote.c,969,+,+,find_src ? query->dst : query->src,24,		const char *needle = find_src ? query->dst : query->src;
implicit_predicate,remote.c,970,+,+,find_src ? &query->src : &query->dst,19,		char **result = find_src ? &query->src : &query->dst;
implicit_predicate,remote.c,971,+,-,find_src ? query->dst : query->src,,
implicit_predicate,remote.c,972,+,-,find_src ? &query->src : &query->dst,,
implicit_predicate,remote.c,975,+,-,"if (match_name_with_pattern(key, needle, value, result))
    string_list_append_nodup(results, *result);
",,
implicit_predicate,remote.c,977,+,-,"if (match_name_with_pattern(key, needle, value, result))
    string_list_append_nodup(results, *result);
",,
implicit_predicate,remote.c,987,+,+,find_src ? query->dst : query->src,23,	const char *needle = find_src ? query->dst : query->src;
implicit_predicate,remote.c,988,+,+,find_src ? &query->src : &query->dst,18,	char **result = find_src ? &query->src : &query->dst;
implicit_predicate,remote.c,989,+,-,find_src ? query->dst : query->src,,
implicit_predicate,remote.c,990,+,-,find_src ? &query->src : &query->dst,,
implicit_predicate,remote.c,993,+,-,"if (query_matches_negative_refspec(rs, query))
    return -1;
",,
implicit_predicate,remote.c,995,+,-,"if (query_matches_negative_refspec(rs, query))
    return -1;
",,
implicit_predicate,remote.c,998,+,+,find_src ? refspec->dst : refspec->src,21,		const char *key = find_src ? refspec->dst : refspec->src;
implicit_predicate,remote.c,999,+,+,find_src ? refspec->src : refspec->dst,23,		const char *value = find_src ? refspec->src : refspec->dst;
implicit_predicate,remote.c,1000,+,-,find_src ? refspec->dst : refspec->src,,
implicit_predicate,remote.c,1001,+,-,find_src ? refspec->src : refspec->dst,,
implicit_predicate,remote.c,1004,+,-,"if (match_name_with_pattern(key, needle, value, result)){
    query->force = refspec->force;
    return 0;
}
",,
implicit_predicate,remote.c,1006,+,-,"if (match_name_with_pattern(key, needle, value, result)){
    query->force = refspec->force;
    return 0;
}
",,
implicit_predicate,remote.c,1010,+,-,"if (query & GET_REF_STATES)
    get_ref_states(remote_refs, states);
",,
implicit_predicate,remote.c,1012,+,-,"if (query & GET_HEAD_NAMES)
    get_head_names(remote_refs, states);
",,
implicit_predicate,remote.c,1014,+,-,"if (query & GET_PUSH_REF_STATES)
    get_push_ref_states(remote_refs, states);
",,
implicit_predicate,remote.c,1024,+,-,"if (query_refspecs(rs, &query))
    return NULL;
",,
implicit_predicate,remote.c,1026,+,-,"if (query_refspecs(rs, &query))
    return NULL;
",,
implicit_predicate,remote.c,1055,+,-,"if (states->queried){
    const char* fmt = ""%s"";
    const char* arg = """";
    if (string_list_has_string(&states->new_refs, name)){
        fmt = _("" new (next fetch will store in remotes/%s)"");
        arg = states->remote->name;
    }else
        if (string_list_has_string(&states->tracked, name))
            arg = _("" tracked"");
        else
            if (string_list_has_string(&states->skipped, name))
                arg = _("" skipped"");
            else
                if (string_list_has_string(&states->stale, name))
                    arg = _("" stale (use 'git remote prune' to remove)"");
                else
                    arg = _("" ???"");

    printf(""    %-*s"", info->width, name);
    printf(fmt, arg);
    printf(""\n"");
}else
    printf(""    %s\n"", name);
",,
implicit_predicate,remote.c,1126,+,-,"if (show_info->any_rebase){
    printf_ln(_("" merges with remote %s""), merge->items[0].string);
    width++;
}else{
    printf_ln(_(""merges with remote %s""), merge->items[0].string);
}
",,
implicit_predicate,remote.c,1165,+,+,"cmp ? cmp : strcmp(a_push->dest, b_push->dest)",9,"	return cmp ? cmp : strcmp(a_push->dest, b_push->dest);"
implicit_predicate,remote.c,1195,+,-,"if (push_info->forced)
    printf_ln(_(""    %-*s forces to %-*s (%s)""), show_info->width, src, show_info->width2, push_info->dest, status);
else
    printf_ln(_(""    %-*s pushes to %-*s (%s)""), show_info->width, src, show_info->width2, push_info->dest, status);
",,
implicit_predicate,remote.c,1202,+,-,"if (push_info->forced)
    printf_ln(_(""    %-*s forces to %s""), show_info->width, src, push_info->dest);
else
    printf_ln(_(""    %-*s pushes to %s""), show_info->width, src, push_info->dest);
",,
implicit_predicate,remote.c,1263,+,-,"if (verbose)
    printf(""%s\t%s\n"", item->string, item->util ? (const char*)item->util : """");
else{
    if (i && !strcmp((item - 1)->string, item->string))
        continue;

    printf(""%s\n"", item->string);
}
",,
implicit_predicate,remote.c,1265,-,+,,6,"					item->util ? (const char *)item->util : """");"
implicit_predicate,remote.c,1296,+,-,"for (;argc;argc--, argv++){
    int i;
    const char** url;
    int url_nr;
    get_remote_ref_states(*argv, &info.states, query_flag);
    printf_ln(_(""* remote %s""), *argv);
    printf_ln(_(""  Fetch URL: %s""), info.states.remote->url_nr > 0 ? info.states.remote->url[0] : _(""(no URL)""));
    if (info.states.remote->pushurl_nr){
        url = info.states.remote->pushurl;
        url_nr = info.states.remote->pushurl_nr;
    }else{
        url = info.states.remote->url;
        url_nr = info.states.remote->url_nr;
    }
    for (i = 0;i < url_nr;i++)
        printf_ln(_(""  Push  URL: %s""), url[i]);
    if (!i)
        printf_ln(_(""  Push  URL: %s""), _(""(no URL)""));

    if (no_query)
        printf_ln(_(""  HEAD branch: %s""), _(""(not queried)""));
    else
        if (!info.states.heads.nr)
            printf_ln(_(""  HEAD branch: %s""), _(""(unknown)""));
        else
            if (info.states.heads.nr == 1)
                printf_ln(_(""  HEAD branch: %s""), info.states.heads.items[0].string);
            else{
                printf(_(""  HEAD branch (remote HEAD is ambiguous, may be one of the following):\n""));
                for (i = 0;i < info.states.heads.nr;i++)
                    printf(""    %s\n"", info.states.heads.items[i].string);
            }

    info.width = 0;
    for_each_string_list(&info.states.new_refs, add_remote_to_show_info, &info);
    for_each_string_list(&info.states.skipped, add_remote_to_show_info, &info);
    for_each_string_list(&info.states.tracked, add_remote_to_show_info, &info);
    for_each_string_list(&info.states.stale, add_remote_to_show_info, &info);
    if (info.list.nr)
        printf_ln(Q_(""  Remote branch:%s"", ""  Remote branches:%s"", info.list.nr), no_query ? _("" (status not queried)"") : """");

    for_each_string_list(&info.list, show_remote_info_item, &info);
    string_list_clear(&info.list, 0);
    info.width = 0;
    info.any_rebase = 0;
    for_each_string_list(&branch_list, add_local_to_show_info, &info);
    if (info.list.nr)
        printf_ln(Q_(""  Local branch configured for 'git pull':"", ""  Local branches configured for 'git pull':"", info.list.nr));

    for_each_string_list(&info.list, show_local_info_item, &info);
    string_list_clear(&info.list, 0);
    if (info.states.remote->mirror)
        printf_ln(_(""  Local refs will be mirrored by 'git push'""));

    info.width = info.width2 = 0;
    for_each_string_list(&info.states.push, add_push_to_show_info, &info);
    QSORT(info.list.items, info.list.nr, cmp_string_with_push);
    if (info.list.nr)
        printf_ln(Q_(""  Local ref configured for 'git push'%s:"", ""  Local refs configured for 'git push'%s:"", info.list.nr), no_query ? _("" (status not queried)"") : """");

    for_each_string_list(&info.list, show_push_info_item, &info);
    string_list_clear(&info.list, 0);
    free_remote_ref_states(&info.states);
}
",,
implicit_predicate,remote.c,1322,+,-,"if (no_query)
    printf_ln(_(""  HEAD branch: %s""), _(""(not queried)""));
else
    if (!info.states.heads.nr)
        printf_ln(_(""  HEAD branch: %s""), _(""(unknown)""));
    else
        if (info.states.heads.nr == 1)
            printf_ln(_(""  HEAD branch: %s""), info.states.heads.items[0].string);
        else{
            printf(_(""  HEAD branch (remote HEAD is ambiguous, may be one of the following):\n""));
            for (i = 0;i < info.states.heads.nr;i++)
                printf(""    %s\n"", info.states.heads.items[i].string);
        }
",,
implicit_predicate,remote.c,1345,+,+,"no_query ? _("" (status not queried)"") : """"",7,"				  no_query ? _("" (status not queried)"") : """");"
implicit_predicate,remote.c,1361,+,+,allocated_src ? matched_src : copy_ref(matched_src),27,"		matched_dst->peer_ref = allocated_src ?
					matched_src :
					copy_ref(matched_src);"
implicit_predicate,remote.c,1363,+,-,allocated_src ? matched_src : copy_ref(matched_src),,
implicit_predicate,remote.c,1371,+,+,"no_query ? _("" (status not queried)"") : """"",7,"				  no_query ? _("" (status not queried)"") : """");"
implicit_predicate,remote.c,1396,+,-,"if (argc)
    strbuf_addf(&buf, ""refs/remotes/%s/HEAD"", argv[0]);
",,
implicit_predicate,remote.c,1399,-,+,,27,			const char *dst_side = item->dst ? item->dst : item->src;
implicit_predicate,remote.c,1405,+,-,"if (match){
    matching_refs = i;
    break;
}
",,
implicit_predicate,remote.c,1407,+,-,"if (match){
    matching_refs = i;
    break;
}
",,
implicit_predicate,remote.c,1428,+,-,"if (opt_a)
    printf(""%s/HEAD set to %s\n"", argv[0], head_name);
",,
implicit_predicate,remote.c,1444,+,+,"dry_run ? _("" %s will become dangling!"") : _("" %s has become dangling!"")",29,"	const char *dangling_msg = dry_run
		? _("" %s will become dangling!"")
		: _("" %s has become dangling!"");"
implicit_predicate,remote.c,1457,-,+,,5,"		  states.remote->url_nr
		  ? states.remote->url[0]
		  : _(""(no URL)""));"
implicit_predicate,remote.c,1472,+,-,"if (dry_run)
    printf_ln(_("" * [would prune] %s""), abbrev_ref(refname, ""refs/remotes/""));
else
    printf_ln(_("" * [pruned] %s""), abbrev_ref(refname, ""refs/remotes/""));
",,
implicit_predicate,remote.c,1501,+,-,"for (;argc;argc--, argv++)
    result |= prune_remote(*argv, dry_run);
",,
implicit_predicate,remote.c,1503,+,-,<!!!>,,
implicit_predicate,remote.c,1505,+,-,<!!!>,,
implicit_predicate,remote.c,1536,+,+,"prune ? ""--prune"" : ""--no-prune""",26,"		strvec_push(&cmd.args, prune ? ""--prune"" : ""--no-prune"");"
implicit_predicate,remote.c,1537,+,-,"if (verbose)
    strvec_push(&cmd.args, ""-v"");
",,
implicit_predicate,remote.c,1645,-,+,,14,		dst_peer = dst_item ? dst_item->util : NULL;
implicit_predicate,remote.c,1648,+,-,"if (push_mode){
    url = remote->pushurl;
    url_nr = remote->pushurl_nr;
}
",,
implicit_predicate,remote.c,1663,+,-,"if (all_mode){
    for (i = 0;i < url_nr;i++)
        printf_ln(""%s"", url[i]);
}else{
    printf_ln(""%s"", *url);
}
",,
implicit_predicate,remote.c,1676,+,-,"if (send_prune){
    struct string_list src_ref_index = STRING_LIST_INIT_NODUP;
    for (ref = *dst;ref;ref = ref->next){
        char* src_name;
        if (ref->peer_ref)
            continue;

        src_name = get_ref_match(rs, ref, send_mirror, FROM_DST, NULL);
        if (src_name){
            if (!src_ref_index.nr)
                prepare_ref_index(&src_ref_index, src);

            if (!string_list_has_string(&src_ref_index, src_name))
                ref->peer_ref = alloc_delete_ref();

            free(src_name);
        }
    }
    string_list_clear(&src_ref_index, 0);
}
",,
implicit_predicate,remote.c,1678,+,-,"if (send_prune){
    struct string_list src_ref_index = STRING_LIST_INIT_NODUP;
    for (ref = *dst;ref;ref = ref->next){
        char* src_name;
        if (ref->peer_ref)
            continue;

        src_name = get_ref_match(rs, ref, send_mirror, FROM_DST, NULL);
        if (src_name){
            if (!src_ref_index.nr)
                prepare_ref_index(&src_ref_index, src);

            if (!string_list_has_string(&src_ref_index, src_name))
                ref->peer_ref = alloc_delete_ref();

            free(src_name);
        }
    }
    string_list_clear(&src_ref_index, 0);
}
",,
implicit_predicate,remote.c,1701,+,-,"if (errs)
    return -1;
",,
implicit_predicate,remote.c,1703,+,-,"if (errs)
    return -1;
",,
implicit_predicate,remote.c,1709,+,-,"if (delete_mode)
    oldurl = newurl;
",,
implicit_predicate,remote.c,1718,+,-,"if (push_mode){
    strbuf_addf(&name_buf, ""remote.%s.pushurl"", remotename);
    urlset = remote->pushurl;
    urlset_nr = remote->pushurl_nr;
}else{
    strbuf_addf(&name_buf, ""remote.%s.url"", remotename);
    urlset = remote->url;
    urlset_nr = remote->url_nr;
}
",,
implicit_predicate,remote.c,1730,+,-,"if (add_mode)
    git_config_set_multivar(name_buf.buf, newurl, ""^$"", 0);
else
    git_config_set(name_buf.buf, newurl);
",,
implicit_predicate,remote.c,1789,+,-,"if (argc){
    error(_(""unknown subcommand: `%s'""), argv[0]);
    usage_with_options(builtin_remote_usage, options);
}
",,
implicit_predicate,remote.c,1794,+,-,"if (reject_reason)
    ref->forced_update = 1;
",,
implicit_predicate,remote.c,1796,+,-,"if (reject_reason)
    ref->forced_update = 1;
",,
implicit_predicate,remote.c,2096,-,+,,22,"		const char *name = refspec->src[0] ? refspec->src : ""HEAD"";"
implicit_predicate,remote.c,2210,+,-,"while (1){
    struct commit* c = get_revision(&revs);
    if (!c)
        break;

    if (c->object.flags & SYMMETRIC_LEFT)
        (*num_ours)++;
    else
        (*num_theirs)++;
}
",,
implicit_predicate,remote.c,2212,+,-,"while (1){
    struct commit* c = get_revision(&revs);
    if (!c)
        break;

    if (c->object.flags & SYMMETRIC_LEFT)
        (*num_ours)++;
    else
        (*num_theirs)++;
}
",,
implicit_predicate,remote.c,2255,+,+,"for_push ? branch_get_push(branch, NULL) : branch_get_upstream(branch, NULL)",9,"	base = for_push ? branch_get_push(branch, NULL) :
		branch_get_upstream(branch, NULL);"
implicit_predicate,remote.c,2257,+,-,"for_push ? branch_get_push(branch, NULL) : branch_get_upstream(branch, NULL)",,
implicit_predicate,remote.c,2286,+,-,"if (upstream_is_gone){
    strbuf_addf(sb, _(""Your branch is based on '%s', but the upstream is gone.\n""), base);
    if (advice_enabled (ADVICE_STATUS_HINTS))
        strbuf_addstr(sb, _(""  (use \""git branch --unset-upstream\"" to fixup)\n""));
}else
    if (!sti){
        strbuf_addf(sb, _(""Your branch is up to date with '%s'.\n""), base);
    }else
        if (abf == AHEAD_BEHIND_QUICK){
            strbuf_addf(sb, _(""Your branch and '%s' refer to different commits.\n""), base);
            if (advice_enabled (ADVICE_STATUS_HINTS))
                strbuf_addf(sb, _(""  (use \""%s\"" for details)\n""), ""git status --ahead-behind"");
        }else
            if (!theirs){
                strbuf_addf(sb, Q_(""Your branch is ahead of '%s' by %d commit.\n"", ""Your branch is ahead of '%s' by %d commits.\n"", ours), base, ours);
                if (advice_enabled (ADVICE_STATUS_HINTS))
                    strbuf_addstr(sb, _(""  (use \""git push\"" to publish your local commits)\n""));
            }else
                if (!ours){
                    strbuf_addf(sb, Q_(""Your branch is behind '%s' by %d commit, and can be fast-forwarded.\n"", ""Your branch is behind '%s' by %d commits, and can be fast-forwarded.\n"", theirs), base, theirs);
                    if (advice_enabled (ADVICE_STATUS_HINTS))
                        strbuf_addstr(sb, _(""  (use \""git pull\"" to update your local branch)\n""));
                }else{
                    strbuf_addf(sb, Q_(""Your branch and '%s' have diverged,\nand have %d and %d different commit each, respectively.\n"", ""Your branch and '%s' have diverged,\nand have %d and %d different commits each, respectively.\n"", ours + theirs), base, ours, theirs);
                    if (show_divergence_advice && advice_enabled(ADVICE_STATUS_HINTS))
                        strbuf_addstr(sb, _(""  (use \""git pull\"" if you want to integrate the remote branch with yours)\n""));
                }
",,
implicit_predicate,remote.c,2288,+,-,"if (upstream_is_gone){
    strbuf_addf(sb, _(""Your branch is based on '%s', but the upstream is gone.\n""), base);
    if (advice_enabled (ADVICE_STATUS_HINTS))
        strbuf_addstr(sb, _(""  (use \""git branch --unset-upstream\"" to fixup)\n""));
}else
    if (!sti){
        strbuf_addf(sb, _(""Your branch is up to date with '%s'.\n""), base);
    }else
        if (abf == AHEAD_BEHIND_QUICK){
            strbuf_addf(sb, _(""Your branch and '%s' refer to different commits.\n""), base);
            if (advice_enabled (ADVICE_STATUS_HINTS))
                strbuf_addf(sb, _(""  (use \""%s\"" for details)\n""), ""git status --ahead-behind"");
        }else
            if (!theirs){
                strbuf_addf(sb, Q_(""Your branch is ahead of '%s' by %d commit.\n"", ""Your branch is ahead of '%s' by %d commits.\n"", ours), base, ours);
                if (advice_enabled (ADVICE_STATUS_HINTS))
                    strbuf_addstr(sb, _(""  (use \""git push\"" to publish your local commits)\n""));
            }else
                if (!ours){
                    strbuf_addf(sb, Q_(""Your branch is behind '%s' by %d commit, and can be fast-forwarded.\n"", ""Your branch is behind '%s' by %d commits, and can be fast-forwarded.\n"", theirs), base, theirs);
                    if (advice_enabled (ADVICE_STATUS_HINTS))
                        strbuf_addstr(sb, _(""  (use \""git pull\"" to update your local branch)\n""));
                }else{
                    strbuf_addf(sb, Q_(""Your branch and '%s' have diverged,\nand have %d and %d different commit each, respectively.\n"", ""Your branch and '%s' have diverged,\nand have %d and %d different commits each, respectively.\n"", ours + theirs), base, ours, theirs);
                    if (show_divergence_advice && advice_enabled(ADVICE_STATUS_HINTS))
                        strbuf_addstr(sb, _(""  (use \""git pull\"" if you want to integrate the remote branch with yours)\n""));
                }
",,
implicit_predicate,remote.c,2454,+,-,"if (stale){
    struct ref* ref = make_linked_ref(refname, &info->stale_refs_tail);
    oidcpy(&ref->new_oid, oid);
}
",,
implicit_predicate,remote.c,2458,+,-,"if (stale){
    struct ref* ref = make_linked_ref(refname, &info->stale_refs_tail);
    oidcpy(&ref->new_oid, oid);
}
",,
implicit_predicate,remote.c,2512,+,-,"if (unset){
    clear_cas_option(cas);
    return 0;
}
",,
implicit_predicate,remote.c,2516,+,-,"if (unset){
    clear_cas_option(cas);
    return 0;
}
",,
implicit_predicate,remote.c,2871,+,+,"colonsep ? "":"" : ""/""",40,"	strbuf_addf(&sb, ""%s%s%s"", remoteurl, colonsep ? "":"" : ""/"", url);"
implicit_predicate,remote.c,2875,+,-,"colonsep ? "":"" : ""/""",,
implicit_predicate,repack.c,154,+,-,"if (pack_is_retained(item)){
    pack_unmark_for_deletion(item);
}else
    if (!string_list_has_string(names, sha1)){
        pack_mark_for_deletion(item);
    }
",,
implicit_predicate,repack.c,295,+,-,"if (delta_base_offset)
    strvec_push(&cmd->args, ""--delta-base-offset"");
",,
implicit_predicate,repack.c,685,-,+,,33,"	fprintf(data->f->fp, ""%s%s\n"", data->preferred ? ""+"" : """","
implicit_predicate,repack.c,739,+,-,<!!!>,,
implicit_predicate,repack.c,764,+,-,"if (pack_is_marked_for_deletion(item))
    continue;
",,
implicit_predicate,repack.c,784,+,-,"if (pack_is_marked_for_deletion(item))
    continue;
",,
implicit_predicate,repack.c,811,+,-,"if (show_progress)
    strvec_push(&cmd.args, ""--progress"");
else
    strvec_push(&cmd.args, ""--no-progress"");
",,
implicit_predicate,repack.c,816,+,-,"if (write_bitmaps)
    strvec_push(&cmd.args, ""--bitmap"");
",,
implicit_predicate,repack.c,837,+,-,"if (has_pack_ext(data, "".mtimes""))
    continue;
",,
implicit_predicate,repack.c,859,+,-,"if (ret)
    return ret;
",,
implicit_predicate,repack.c,917,+,-,"if (local){
    item = string_list_append(names, line.buf);
    item->util = populate_pack_exts(line.buf);
}
",,
implicit_predicate,repack.c,955,+,-,"if (ret)
    return ret;
",,
implicit_predicate,repack.c,971,+,+,"pack_kept_objects ? """" : ""^""",10,"	caret = pack_kept_objects ? """" : ""^"";"
implicit_predicate,repack.c,1073,+,-,"if (ret)
    return ret;
",,
implicit_predicate,repack.c,1213,+,-,"if (pack_everything & PACK_CRUFT)
    pack_everything |= ALL_INTO_ONE;
",,
implicit_predicate,repack.c,1261,+,-,"if (geometry.split_factor){
    if (pack_everything)
        die(_(""options '%s' and '%s' cannot be used together""), ""--geometric"", ""-A/-a"");

    init_pack_geometry(&geometry, &existing, &po_args);
    split_pack_geometry(&geometry);
}
",,
implicit_predicate,repack.c,1262,+,-,"if (pack_everything)
    die(_(""options '%s' and '%s' cannot be used together""), ""--geometric"", ""-A/-a"");
",,
implicit_predicate,repack.c,1302,+,-,"if (use_delta_islands)
    strvec_push(&cmd.args, ""--delta-islands"");
",,
implicit_predicate,repack.c,1305,+,-,<!!!>,,
implicit_predicate,repack.c,1319,+,-,"if (pack_everything & LOOSEN_UNREACHABLE){
    strvec_push(&cmd.args, ""--unpack-unreachable"");
}else
    if (keep_unreachable){
        strvec_push(&cmd.args, ""--keep-unreachable"");
        strvec_push(&cmd.args, ""--pack-loose-unreachable"");
    }
",,
implicit_predicate,repack.c,1322,+,-,"if (keep_unreachable){
    strvec_push(&cmd.args, ""--keep-unreachable"");
    strvec_push(&cmd.args, ""--pack-loose-unreachable"");
}
",,
implicit_predicate,repack.c,1327,+,-,"if (geometry.split_factor){
    strvec_push(&cmd.args, ""--stdin-packs"");
    strvec_push(&cmd.args, ""--unpacked"");
}else{
    strvec_push(&cmd.args, ""--unpacked"");
    strvec_push(&cmd.args, ""--incremental"");
}
",,
implicit_predicate,repack.c,1341,+,-,"if (geometry.split_factor)
    cmd.in = -1;
else
    cmd.no_stdin = 1;
",,
implicit_predicate,repack.c,1347,+,-,"if (ret)
    goto cleanup;
",,
implicit_predicate,repack.c,1350,+,-,"if (geometry.split_factor){
    FILE* in = xfdopen(cmd.in, ""w"");
    for (i = 0;i < geometry.split;i++)
        fprintf(in, ""%s\n"", pack_basename(geometry.pack[i]));
    for (i = geometry.split;i < geometry.pack_nr;i++)
        fprintf(in, ""^%s\n"", pack_basename(geometry.pack[i]));
    fclose(in);
}
",,
implicit_predicate,repack.c,1365,+,-,"if (ret)
    goto cleanup;
",,
implicit_predicate,repack.c,1371,+,-,"if (pack_everything & PACK_CRUFT){
    const char* pack_prefix = find_pack_prefix(packdir, packtmp);
    if (!cruft_po_args.window)
        cruft_po_args.window = po_args.window;

    if (!cruft_po_args.window_memory)
        cruft_po_args.window_memory = po_args.window_memory;

    if (!cruft_po_args.depth)
        cruft_po_args.depth = po_args.depth;

    if (!cruft_po_args.threads)
        cruft_po_args.threads = po_args.threads;

    if (!cruft_po_args.max_pack_size)
        cruft_po_args.max_pack_size = po_args.max_pack_size;

    cruft_po_args.local = po_args.local;
    cruft_po_args.quiet = po_args.quiet;
    ret = write_cruft_pack(&cruft_po_args, packtmp, pack_prefix, cruft_expiration, &names, &existing);
    if (ret)
        goto cleanup;

    if (delete_redundant && expire_to){
        ret = write_cruft_pack(&cruft_po_args, expire_to, pack_prefix, NULL, &names, &existing);
        if (ret)
            goto cleanup;
    }
}
",,
implicit_predicate,repack.c,1391,+,-,"if (ret)
    goto cleanup;
",,
implicit_predicate,repack.c,1422,+,-,"if (ret)
    goto cleanup;
",,
implicit_predicate,repack.c,1436,+,-,"if (ret)
    goto cleanup;
",,
implicit_predicate,repack.c,1481,+,-,"if (write_midx){
    struct string_list include = STRING_LIST_INIT_NODUP;
    midx_included_packs(&include, &existing, &names, &geometry);
    ret = write_midx_included_packs(&include, &geometry, &names, refs_snapshot ? get_tempfile_path(refs_snapshot) : NULL, show_progress, write_bitmaps > 0);
    if (!ret && write_bitmaps)
        remove_redundant_bitmaps(&include, packdir);

    string_list_clear(&include, 0);
    if (ret)
        goto cleanup;
}
",,
implicit_predicate,repack.c,1486,-,+,,7,"						refs_snapshot ? get_tempfile_path(refs_snapshot) : NULL,"
implicit_predicate,repack.c,1494,+,-,"if (ret)
    goto cleanup;
",,
implicit_predicate,repack.c,1500,+,-,"if (delete_redundant){
    int opts = 0;
    remove_redundant_existing_packs(&existing);
    if (geometry.split_factor)
        geometry_remove_redundant_packs(&geometry, &names, &existing);

    if (show_progress)
        opts |= PRUNE_PACKED_VERBOSE;

    prune_packed_objects(opts);
    if (!keep_unreachable && (!(pack_everything & LOOSEN_UNREACHABLE) || unpack_unreachable) && is_repository_shallow(the_repository))
        prune_shallow (PRUNE_QUICK);
}
",,
implicit_predicate,repack.c,1504,+,-,"if (geometry.split_factor)
    geometry_remove_redundant_packs(&geometry, &names, &existing);
",,
implicit_predicate,repack.c,1507,+,-,"if (show_progress)
    opts |= PRUNE_PACKED_VERBOSE;
",,
implicit_predicate,repack.c,1518,+,-,"if (run_update_server_info)
    update_server_info(0);
",,
implicit_predicate,replace-object.c,19,-,+,,21,	const char *hash = slash ? slash + 1 : refname;
implicit_predicate,replace.c,138,+,-,"if (fn(full_hex, ref.buf, &oid))
    had_error = 1;
",,
implicit_predicate,replace.c,196,+,-,"if (check_ref_valid(object, &prev, &ref, force)){
    strbuf_release(&ref);
    return -1;
}
",,
implicit_predicate,replace.c,245,+,-,"if (raw)
    strvec_push(&cmd.args, type_name(type));
else
    strvec_push(&cmd.args, ""-p"");
",,
implicit_predicate,replace.c,340,+,-,"if (check_ref_valid(&old_oid, &prev, &ref, force)){
    strbuf_release(&ref);
    return -1;
}
",,
implicit_predicate,replace.c,484,+,-,"if (check_mergetags(commit, argc, argv)){
    strbuf_release(&buf);
    return -1;
}
",,
implicit_predicate,replace.c,498,+,-,"if (gentle){
    warning(_(""graft for '%s' unnecessary""), oid_to_hex(&commit->object.oid));
    return 0;
}
",,
implicit_predicate,replace.c,577,+,+,argc ? MODE_REPLACE : MODE_LIST,13,		cmdmode = argc ? MODE_REPLACE : MODE_LIST;
implicit_predicate,replay.c,132,+,-,"if (can_uniquely_dwim)
    strset_add(&ref_info->negative_refs, fullname);
",,
implicit_predicate,replay.c,139,+,-,"if (can_uniquely_dwim)
    strset_add(&ref_info->positive_refs, fullname);
",,
implicit_predicate,replay.c,193,+,-,<!!!>,,
implicit_predicate,replay.c,444,+,+,ret ? 0 : 1,9,
implicit_predicate,repo-settings.c,43,+,-,"if (experimental){
    r->settings.fetch_negotiation_algorithm = FETCH_NEGOTIATION_SKIPPING;
    r->settings.pack_use_bitmap_boundary_traversal = 1;
    r->settings.pack_use_multi_pack_reuse = 1;
}
",,
implicit_predicate,repo-settings.c,48,+,-,"if (manyfiles){
    r->settings.index_version = 4;
    r->settings.index_skip_hash = 1;
    r->settings.core_untracked_cache = UNTRACKED_CACHE_WRITE;
}
",,
implicit_predicate,repo-settings.c,97,+,+,v ? UNTRACKED_CACHE_WRITE : UNTRACKED_CACHE_REMOVE,39,"			r->settings.core_untracked_cache = v ?
				UNTRACKED_CACHE_WRITE : UNTRACKED_CACHE_REMOVE;"
implicit_predicate,repository.c,90,-,+,,25,	repo->gitdir = xstrdup(gitfile ? gitfile : root);
implicit_predicate,repository.c,121,+,+,algo ? &hash_algos[algo] : NULL,27,	repo->compat_hash_algo = algo ? &hash_algos[algo] : NULL;
implicit_predicate,repository.c,146,+,-,algo ? &hash_algos[algo] : NULL,,
implicit_predicate,repository.c,202,+,-,"if (repo_init_gitdir(repo, gitdir))
    goto error;
",,
implicit_predicate,repository.c,227,+,-,"if (repo_init_gitdir(repo, gitdir))
    goto error;
",,
implicit_predicate,repository.c,268,-,+,,10,"					    superproject->submodule_prefix ?
					    superproject->submodule_prefix :
					    """", path);"
implicit_predicate,rerere.c,343,+,-,"while (marker_size--)
    if (*buf++ != marker_char)
        return 0;
",,
implicit_predicate,rerere.c,396,-,+,,35,"				the_hash_algo->update_fn(ctx, one.buf ?
							 one.buf : """","
implicit_predicate,rerere.c,399,-,+,,35,"				the_hash_algo->update_fn(ctx, two.buf ?
							 two.buf : """","
implicit_predicate,rerere.c,441,-,+,,8,							hash ? &ctx : NULL);
implicit_predicate,rerere.c,488,+,-,"if (io.io.wrerror)
    error(_(""there were errors while writing '%s' (%s)""), path, strerror(io.io.wrerror));
",,
implicit_predicate,rerere.c,499,+,-,"if (io.io.wrerror)
    return -1;
",,
implicit_predicate,rerere.c,671,+,-,"if (ret)
    goto out;
",,
implicit_predicate,rerere.c,769,+,-,"if (merge(istate, &vid, path))
    continue;
",,
implicit_predicate,rerere.c,779,+,-,"if (rerere_autoupdate)
    string_list_insert(update, path);
else
    fprintf_ln(stderr, _(""Resolved '%s' using previous resolution.""), path);
",,
implicit_predicate,rerere.c,1062,+,-,"if (cleanly_resolved)
    break;
",,
implicit_predicate,rerere.c,1141,-,+,,9,"	return stat(rerere_path(id, ""preimage""), &st) ? (time_t) 0 : st.st_mtime;"
implicit_predicate,rerere.c,1148,-,+,,9,"	return stat(rerere_path(id, ""postimage""), &st) ? (time_t) 0 : st.st_mtime;"
implicit_predicate,rerere.c,1226,+,-,"if (now_empty)
    string_list_append(&to_remove, e->d_name);
",,
implicit_predicate,reset.c,37,-,+,,29,"		strbuf_addf(&msg, ""%s: "", reflog_action ? reflog_action :
							  default_reflog_action);"
implicit_predicate,reset.c,42,+,-,"if (update_orig_head){
    if (!repo_get_oid(the_repository, ""ORIG_HEAD"", &oid_old_orig))
        old_orig = &oid_old_orig;

    if (head){
        if (!reflog_orig_head){
            strbuf_addstr(&msg, ""updating ORIG_HEAD"");
            reflog_orig_head = msg.buf;
        }
        refs_update_ref(get_main_ref_store(the_repository), reflog_orig_head, ""ORIG_HEAD"", orig_head ? orig_head : head, old_orig, 0, UPDATE_REFS_MSG_ON_ERR);
    }else
        if (old_orig)
            refs_delete_ref(get_main_ref_store(the_repository), NULL, ""ORIG_HEAD"", old_orig, 0);
}
",,
implicit_predicate,reset.c,52,-,+,,6,"					orig_head ? orig_head : head,"
implicit_predicate,reset.c,67,+,+,detach_head ? REF_NO_DEREF : 0,11,"				      detach_head ? REF_NO_DEREF : 0,"
implicit_predicate,reset.c,71,-,+,,11,"				      reflog_branch ? reflog_branch : reflog_head,"
implicit_predicate,reset.c,81,-,+,,19,"			    oid_to_hex(head ? head : null_oid()),"
implicit_predicate,reset.c,126,+,-,"if (refs_only)
    return update_refs(opts, oid, head);
",,
implicit_predicate,reset.c,129,+,+,"reset_hard ? ""reset"" : ""checkout""",11,"	action = reset_hard ? ""reset"" : ""checkout"";"
implicit_predicate,reset.c,134,+,+,reset_hard ? oneway_merge : twoway_merge,24,	unpack_tree_opts.fn = reset_hard ? oneway_merge : twoway_merge;
implicit_predicate,reset.c,140,+,-,"if (reset_hard)
    unpack_tree_opts.reset = UNPACK_RESET_PROTECT_UNTRACKED;
",,
implicit_predicate,reset.c,183,+,-,"while (nr)
    free((void*)desc[--nr].buffer);
",,
implicit_predicate,reset.c,294,+,+,patch_mode ? PATHSPEC_PREFIX_ORIGIN : 0,11,"		       (patch_mode ? PATHSPEC_PREFIX_ORIGIN : 0),"
implicit_predicate,reset.c,381,+,-,"if (patch_mode)
    die(_(""options '%s' and '%s' cannot be used together""), ""--pathspec-from-file"", ""--patch"");
",,
implicit_predicate,reset.c,390,+,-,"if (pathspec_file_nul){
    die(_(""the option '%s' requires '%s'""), ""--pathspec-file-nul"", ""--pathspec-from-file"");
}
",,
implicit_predicate,reset.c,396,+,-,"if (unborn){
    oidcpy(&oid, the_hash_algo->empty_tree);
}else
    if (!pathspec.nr && !patch_mode){
        struct commit* commit;
        if (repo_get_oid_committish(the_repository, rev, &oid))
            die(_(""Failed to resolve '%s' as a valid revision.""), rev);

        commit = lookup_commit_reference(the_repository, &oid);
        if (!commit)
            die(_(""Could not parse object '%s'.""), rev);

        oidcpy(&oid, &commit->object.oid);
    }else{
        struct tree* tree;
        if (repo_get_oid_treeish(the_repository, rev, &oid))
            die(_(""Failed to resolve '%s' as a valid tree.""), rev);

        tree = parse_tree_indirect(&oid);
        if (!tree)
            die(_(""Could not parse object '%s'.""), rev);

        oidcpy(&oid, &tree->object.oid);
    }
",,
implicit_predicate,reset.c,417,+,-,"if (patch_mode){
    if (reset_type != NONE)
        die(_(""options '%s' and '%s' cannot be used together""), ""--patch"", ""--{hard,mixed,soft}"");

    trace2_cmd_mode(""patch-interactive"");
    update_ref_status = !!run_add_p(the_repository, ADD_P_RESET, rev, &pathspec);
    goto cleanup;
}
",,
implicit_predicate,reset.c,471,+,+,quiet ? REFRESH_QUIET : REFRESH_IN_PORCELAIN,16,			int flags = quiet ? REFRESH_QUIET : REFRESH_IN_PORCELAIN;
implicit_predicate,reset.c,472,+,-,"if (read_from_tree(&pathspec, &oid, intent_to_add)){
    update_ref_status = 1;
    goto cleanup;
}
",,
implicit_predicate,reset.c,502,+,-,"if (err)
    die(_(""Could not reset index file to revision '%s'.""), rev);
",,
implicit_predicate,resolve-undo.c,66,+,-,"while (size){
    struct string_list_item* lost;
    struct resolve_undo_info* ui;
    len = strlen(data) + 1;
    if (size <= len)
        goto error;

    lost = string_list_insert(resolve_undo, data);
    if (!lost->util)
        lost->util = xcalloc(1, sizeof (*ui));

    ui = lost->util;
    size -= len;
    data += len;
    for (i = 0;i < 3;i++){
        ui->mode[i] = strtoul(data, &endptr, 8);
        if (!endptr || endptr == data || *endptr)
            goto error;

        len = (endptr + 1) - (char*)data;
        if (size <= len)
            goto error;

        size -= len;
        data += len;
    }
    for (i = 0;i < 3;i++){
        if (!ui->mode[i])
            continue;

        if (size < rawsz)
            goto error;

        oidread(&ui->oid[i], (const unsigned char*)data);
        size -= rawsz;
        data += rawsz;
    }
}
",,
implicit_predicate,rev-list.c,156,+,-,"if (show_disk_usage)
    total_disk_usage += get_object_disk_usage(&commit->object);
",,
implicit_predicate,rev-list.c,289,+,-,"if (show_disk_usage)
    total_disk_usage += get_object_disk_usage(obj);
",,
implicit_predicate,rev-list.c,306,+,-,"if (arg_show_object_names)
    show_object_with_name(stdout, obj, name);
else
    printf(""%s\n"", oid_to_hex(&obj->oid));
",,
implicit_predicate,rev-list.c,387,+,-,"if (human_readable)
    strbuf_humanise_bytes(&sb, size);
else
    strbuf_addf(&sb, ""%"", (uintmax_t)size);
",,
implicit_predicate,rev-list.c,464,-,+,,6,"				 revs->tree_objects ? &tree_count : NULL,"
implicit_predicate,rev-list.c,465,-,+,,6,"				 revs->blob_objects ? &blob_count : NULL,"
implicit_predicate,rev-list.c,466,-,+,,6,				 revs->tag_objects ? &tag_count : NULL);
implicit_predicate,rev-list.c,574,+,-,"if (parse_missing_action_value(arg))
    break;
",,
implicit_predicate,rev-list.c,719,+,-,"if (bisect_list)
    revs.limited = 1;
",,
implicit_predicate,rev-list.c,725,+,-,"if (use_bitmap_index){
    if (!try_bitmap_count(&revs, filter_provided_objects))
        goto cleanup;

    if (!try_bitmap_disk_usage(&revs, filter_provided_objects))
        goto cleanup;

    if (!try_bitmap_traversal(&revs, filter_provided_objects))
        goto cleanup;
}
",,
implicit_predicate,rev-list.c,739,+,-,"if (bisect_list){
    int reaches, all;
    unsigned bisect_flags = 0;
    if (bisect_find_all)
        bisect_flags |= FIND_BISECTION_ALL;

    if (revs.first_parent_only)
        bisect_flags |= FIND_BISECTION_FIRST_PARENT_ONLY;

    find_bisection(&revs.commits, &reaches, &all, bisect_flags);
    if (bisect_show_vars){
        ret = show_bisect_vars(&info, reaches, all);
        goto cleanup;
    }
}
",,
implicit_predicate,rev-list.c,743,+,-,"if (bisect_find_all)
    bisect_flags |= FIND_BISECTION_ALL;
",,
implicit_predicate,rev-list.c,751,+,-,"if (bisect_show_vars){
    ret = show_bisect_vars(&info, reaches, all);
    goto cleanup;
}
",,
implicit_predicate,rev-list.c,757,+,-,"if (filter_provided_objects){
    struct commit_list* c;
    for (i = 0;i < revs.pending.nr;i++){
        struct object_array_entry* pending = revs.pending.objects + i;
        pending->item->flags |= NOT_USER_GIVEN;
    }
    for (c = revs.commits;c;c = c->next)
        c->item->object.flags |= NOT_USER_GIVEN;
}
",,
implicit_predicate,rev-list.c,767,+,-,"if (arg_print_omitted)
    oidset_init(&omitted_objects, DEFAULT_OIDSET_SIZE);
",,
implicit_predicate,rev-list.c,778,+,+,arg_print_omitted ? &omitted_objects : NULL,4,		(arg_print_omitted ? &omitted_objects : NULL));
implicit_predicate,rev-list.c,780,+,-,"if (arg_print_omitted){
    struct oidset_iter iter;
    struct object_id* oid;
    oidset_iter_init(&omitted_objects, &iter);
    while ((oid = oidset_iter_next(&iter)))
        printf(""~%s\n"", oid_to_hex(oid));
    oidset_clear(&omitted_objects);
}
",,
implicit_predicate,rev-list.c,810,+,-,"if (show_disk_usage)
    print_disk_usage(total_disk_usage);
",,
implicit_predicate,rev-parse.c,112,+,-,"if (output_sq){
    int sq = '\'', ch;
    putchar(sq);
    while ((ch = *arg++)){
        if (ch == sq)
            fputs(""'\\'"", stdout);

        putchar(ch);
    }
    putchar(sq);
    putchar(' ');
}else
    puts(arg);
",,
implicit_predicate,rev-parse.c,116,+,-,"while ((ch = *arg++)){
    if (ch == sq)
        fputs(""'\\'"", stdout);

    putchar(ch);
}
",,
implicit_predicate,rev-parse.c,161,+,-,"if (abbrev_ref){
    char* old = full;
    full = refs_shorten_unambiguous_ref(get_main_ref_store(the_repository), full, abbrev_ref_strict);
    free(old);
}
",,
implicit_predicate,rev-parse.c,179,+,-,"if (abbrev)
    show_with_type(type, repo_find_unique_abbrev(the_repository, oid, abbrev));
else
    show_with_type(type, oid_to_hex(oid));
",,
implicit_predicate,rev-parse.c,191,+,+,"if (filter & (is_rev_argument(arg) ? DO_REVS : DO_NOREV)){
    show(arg);
    return 1;
}
",16,	if (filter & (is_rev_argument(arg) ? DO_REVS : DO_NOREV)) {
implicit_predicate,rev-parse.c,252,+,-,"if (output_prefix){
    const char* prefix = startup_info->prefix;
    char* fname = prefix_filename(prefix, arg);
    show(fname);
    free(fname);
}else
    show(arg);
",,
implicit_predicate,rev-parse.c,300,+,+,symmetric ? NORMAL : REVERSED,12,"		show_rev(symmetric ? NORMAL : REVERSED, &start_oid, start);"
implicit_predicate,rev-parse.c,301,+,-,"if (symmetric){
    struct commit_list* exclude = NULL;
    struct commit *a, *b;
    a = lookup_commit_reference(the_repository, &start_oid);
    b = lookup_commit_reference(the_repository, &end_oid);
    if (!a || !b){
        *dotdot = '.';
        return 0;
    }
    if (repo_get_merge_bases(the_repository, a, b, &exclude) < 0)
        exit(128);

    while (exclude){
        struct commit* commit = pop_commit(&exclude);
        show_rev(REVERSED, &commit->object.oid, NULL);
    }
}
",,
implicit_predicate,rev-parse.c,337,+,-,"if (dotdot[2])
    return 0;
",,
implicit_predicate,rev-parse.c,341,+,-,"if (dotdot[2])
    return 0;
",,
implicit_predicate,rev-parse.c,347,+,-,"if (dotdot[2]){
    char* end;
    exclude_parent = strtoul(dotdot + 2, &end, 10);
    if (*end != '\0' || !exclude_parent)
        return 0;
}
",,
implicit_predicate,rev-parse.c,369,+,-,"if (include_rev)
    show_rev(NORMAL, &oid, arg);
",,
implicit_predicate,rev-parse.c,379,+,-,"if (symbolic)
    name = xstrfmt(""%s^%d"", arg, parent_number);
",,
implicit_predicate,rev-parse.c,381,+,+,include_parents ? NORMAL : REVERSED,12,"		show_rev(include_parents ? NORMAL : REVERSED,"
implicit_predicate,rev-parse.c,393,+,-,"if (unset)
    strbuf_addf(parsed, "" --no-%s"", o->long_name);
else
    if (o->short_name && (o->long_name == NULL || !stuck_long))
        strbuf_addf(parsed, "" -%c"", o->short_name);
    else
        strbuf_addf(parsed, "" --%s"", o->long_name);
",,
implicit_predicate,rev-parse.c,543,+,+,keep_dashdash ? PARSE_OPT_KEEP_DASHDASH : 0,5,			(keep_dashdash ? PARSE_OPT_KEEP_DASHDASH : 0) |
implicit_predicate,rev-parse.c,544,+,+,stop_at_non_option ? PARSE_OPT_STOP_AT_NON_OPTION : 0,5,			(stop_at_non_option ? PARSE_OPT_STOP_AT_NON_OPTION : 0) |
implicit_predicate,rev-parse.c,558,+,-,"if (argc)
    sq_quote_argv(&buf, argv);
",,
implicit_predicate,rev-parse.c,568,+,-,"if (quiet)
    exit(1);
else
    die(_(""Needed a single revision""));
",,
implicit_predicate,rev-parse.c,724,+,-,"if (as_is){
    if (show_file(arg, output_prefix) && as_is < 2)
        verify_filename(prefix, arg, 0);

    continue;
}
",,
implicit_predicate,rev-parse.c,763,+,-,"if (filter & (DO_FLAGS | DO_REVS))
    show_file(arg, 0);
",,
implicit_predicate,rev-parse.c,793,+,-,"if (opt_with_value(arg, ""--path-format"", &arg)){
    if (!arg)
        die(_(""--path-format requires an argument""));

    if (!strcmp(arg, ""absolute"")){
        format = FORMAT_CANONICAL;
    }else
        if (!strcmp(arg, ""relative"")){
            format = FORMAT_RELATIVE;
        }else{
            die(_(""unknown argument to --path-format: %s""), arg);
        }

    continue;
}
",,
implicit_predicate,rev-parse.c,845,+,-,"if (opt_with_value(arg, ""--output-object-format"", &arg)){
    if (!arg)
        die(_(""no object format specified""));

    if (!strcmp(arg, the_hash_algo->name) || !strcmp(arg, ""storage"")){
        flags |= GET_OID_HASH_ANY;
        output_algo = the_hash_algo;
        continue;
    }else
        if (compat && !strcmp(arg, compat->name)){
            flags |= GET_OID_HASH_ANY;
            output_algo = compat;
            continue;
        }else
            die(_(""unsupported object format: %s""), arg);
}
",,
implicit_predicate,rev-parse.c,861,+,-,"if (opt_with_value(arg, ""--short"", &arg)){
    filter &= ~(DO_FLAGS | DO_NOREV);
    verify = 1;
    abbrev = DEFAULT_ABBREV;
    if (!arg)
        continue;

    abbrev = strtoul(arg, NULL, 10);
    if (abbrev < MINIMUM_ABBREV)
        abbrev = MINIMUM_ABBREV;
    else
        if (hexsz <= abbrev)
            abbrev = hexsz;

    continue;
}
",,
implicit_predicate,rev-parse.c,890,+,-,"if (opt_with_value(arg, ""--abbrev-ref"", &arg)){
    abbrev_ref = 1;
    abbrev_ref_strict = warn_ambiguous_refs;
    if (arg){
        if (!strcmp(arg, ""strict""))
            abbrev_ref_strict = 1;
        else
            if (!strcmp(arg, ""loose""))
                abbrev_ref_strict = 0;
            else
                die(_(""unknown mode for --abbrev-ref: %s""), arg);
    }
    continue;
}
",,
implicit_predicate,rev-parse.c,926,+,-,"if (opt_with_value(arg, ""--branches"", &arg)){
    if (ref_excludes.hidden_refs_configured)
        return error(_(""options '%s' and '%s' cannot be used together""), ""--exclude-hidden"", ""--branches"");

    handle_ref_opt(arg, ""refs/heads/"");
    continue;
}
",,
implicit_predicate,rev-parse.c,933,+,-,"if (opt_with_value(arg, ""--tags"", &arg)){
    if (ref_excludes.hidden_refs_configured)
        return error(_(""options '%s' and '%s' cannot be used together""), ""--exclude-hidden"", ""--tags"");

    handle_ref_opt(arg, ""refs/tags/"");
    continue;
}
",,
implicit_predicate,rev-parse.c,944,+,-,"if (opt_with_value(arg, ""--remotes"", &arg)){
    if (ref_excludes.hidden_refs_configured)
        return error(_(""options '%s' and '%s' cannot be used together""), ""--exclude-hidden"", ""--remotes"");

    handle_ref_opt(arg, ""refs/remotes/"");
    continue;
}
",,
implicit_predicate,rev-parse.c,1040,-,+,,20,"				printf(""%s\n"", is_inside_git_dir() ? ""true""
						: ""false"");"
implicit_predicate,rev-parse.c,1045,-,+,,20,"				printf(""%s\n"", is_inside_work_tree() ? ""true""
						: ""false"");"
implicit_predicate,rev-parse.c,1050,-,+,,20,"				printf(""%s\n"", is_bare_repository() ? ""true""
						: ""false"");"
implicit_predicate,rev-parse.c,1056,-,+,,7,"						is_repository_shallow(the_repository) ? ""true""
						: ""false"");"
implicit_predicate,rev-parse.c,1086,+,-,"if (opt_with_value(arg, ""--show-object-format"", &arg)){
    const char* val = arg ? arg : ""storage"";
    if (strcmp(val, ""storage"") && strcmp(val, ""input"") && strcmp(val, ""output""))
        die(_(""unknown mode for --show-object-format: %s""), arg);

    puts(the_hash_algo->name);
    continue;
}
",,
implicit_predicate,rev-parse.c,1087,-,+,,23,"				const char *val = arg ? arg : ""storage"";"
implicit_predicate,rev-parse.c,1103,+,-,"if (filter & (DO_FLAGS | DO_REVS))
    show_file(arg, 0);
",,
implicit_predicate,rev-parse.c,1113,+,-,"if (try_difference(arg))
    continue;
",,
implicit_predicate,rev-parse.c,1115,+,-,"if (try_parent_shorthands(arg))
    continue;
",,
implicit_predicate,rev-parse.c,1128,+,-,"if (verify)
    revs_count++;
else
    show_rev(type, &oid, name);
",,
implicit_predicate,rev-parse.c,1134,+,-,"if (verify)
    die_no_single_rev(quiet);
",,
implicit_predicate,rev-parse.c,1136,+,-,"if (has_dashdash)
    die(_(""bad revision '%s'""), arg);
",,
implicit_predicate,rev-parse.c,1144,+,-,"if (verify){
    if (revs_count == 1){
        show_rev(type, &oid, name);
        return 0;
    }else
        if (revs_count == 0 && show_default())
            return 0;

    die_no_single_rev(quiet);
}else
    show_default();
",,
implicit_predicate,revert.c,77,+,-,"if (unset){
    replay->mainline = 0;
    return 0;
}
",,
implicit_predicate,revert.c,181,+,-,"if (cmd){
    char* this_operation;
    if (cmd == 'q')
        this_operation = ""--quit"";
    else
        if (cmd == 'c')
            this_operation = ""--continue"";
        else
            if (cmd == 's')
                this_operation = ""--skip"";
            else{
                assert(cmd == 'a');
                this_operation = ""--abort"";
            }

    verify_opt_compatible(me, this_operation, ""--no-commit"", opts->no_commit, ""--signoff"", opts->signoff, ""--mainline"", opts->mainline, ""--strategy"", opts->strategy ? 1 : 0, ""--strategy-option"", opts->xopts.nr ? 1 : 0, ""-x"", opts->record_origin, ""--ff"", opts->allow_ff, ""--rerere-autoupdate"", opts->allow_rerere_auto == RERERE_AUTOUPDATE, ""--no-rerere-autoupdate"", opts->allow_rerere_auto == RERERE_NOAUTOUPDATE, ""--keep-redundant-commits"", opts->keep_redundant_commits, ""--empty"", empty_opt != EMPTY_COMMIT_UNSPECIFIED, NULL);
}
",,
implicit_predicate,revert.c,198,-,+,,19,"				""--strategy"", opts->strategy ? 1 : 0,"
implicit_predicate,revert.c,199,-,+,,26,"				""--strategy-option"", opts->xopts.nr ? 1 : 0,"
implicit_predicate,revert.c,222,+,-,"if (cmd){
    opts->revs = NULL;
}else{
    struct setup_revision_opt s_r_opt;
    opts->revs = xmalloc(sizeof (*opts->revs));
    repo_init_revisions(the_repository, opts->revs, NULL);
    opts->revs->no_walk = 1;
    opts->revs->unsorted_input = 1;
    if (argc < 2)
        usage_with_options(usage_str, options);

    if (!strcmp(argv[1], ""-""))
        argv[1] = ""@{-1}"";

    memset(&s_r_opt, 0, sizeof (s_r_opt));
    s_r_opt.assume_dashdash = 1;
    argc = setup_revisions(argc, argv, opts->revs, &s_r_opt);
}
",,
implicit_predicate,revision.c,273,-,+,,9,	return stack->nr ? stack->items[--stack->nr] : NULL;
implicit_predicate,revision.c,344,-,+,,9,				    buf.buf[0] ? buf.buf: name);
implicit_predicate,revision.c,383,-,+,,7,"					 revs->verify_objects ? 0 :
					 PARSE_OBJECT_SKIP_HASH_CHECK |
					 PARSE_OBJECT_DISCARD_TREE);"
implicit_predicate,revision.c,592,+,-,"if (relevant_commit(commit)){
    if (relevant)
        return NULL;

    relevant = commit;
}
",,
implicit_predicate,revision.c,791,+,-,"if (result)
    count_bloom_filter_maybe++;
else
    count_bloom_filter_definitely_not++;
",,
implicit_predicate,revision.c,895,+,-,"if (rev_same_tree_as_empty(revs, commit))
    commit->object.flags |= TREESAME;
else
    commit->object.flags &= ~TREESAME;
",,
implicit_predicate,revision.c,950,+,+,"if (relevant_parents ? relevant_change : irrelevant_change)
    commit->object.flags &= ~TREESAME;
else
    commit->object.flags |= TREESAME;
",7,		if (relevant_parents ? relevant_change : irrelevant_change)
implicit_predicate,revision.c,991,+,-,"if (rev_same_tree_as_empty(revs, commit))
    commit->object.flags |= TREESAME;
",,
implicit_predicate,revision.c,1007,+,-,"if (relevant_commit(p))
    relevant_parents++;
",,
implicit_predicate,revision.c,1090,+,-,"if (relevant_commit(p))
    relevant_change = 1;
else
    irrelevant_change = 1;
",,
implicit_predicate,revision.c,1113,+,+,relevant_parents ? !relevant_change : !irrelevant_change,6,	if (relevant_parents ? !relevant_change : !irrelevant_change)
implicit_predicate,revision.c,1264,-,+,,16,	cherry_flag = revs->cherry_mark ? PATCHSAME : SHOWN;
implicit_predicate,revision.c,1365,+,-,"do{
    made_progress = 0;
    for (p = rlist;p;p = p->next){
        struct commit* c = p->item;
        struct commit_list* parents;
        if (c->object.flags & (TMP_MARK | UNINTERESTING))
            continue;

        for (parents = c->parents;parents;parents = parents->next){
            if (!(parents->item->object.flags & TMP_MARK))
                continue;

            c->object.flags |= TMP_MARK;
            made_progress = 1;
            break;
        }
    }
} while (made_progress);
",,
implicit_predicate,revision.c,1474,+,-,"if (slop)
    continue;
",,
implicit_predicate,revision.c,1507,+,-,"if (limiting_can_increase_treesame(revs)){
    struct commit_list* list = NULL;
    for (list = newlist;list;list = list->next){
        struct commit* c = list->item;
        if (c->object.flags & (UNINTERESTING | TREESAME))
            continue;

        update_treesame(revs, c);
    }
}
",,
implicit_predicate,revision.c,1763,-,+,,29,"		strbuf_addf(path, ""%s%s"", baselen ? ""/"" : """", sub->name);"
implicit_predicate,revision.c,1904,+,-,"while (1){
    it = get_reference(revs, arg, &oid, 0);
    if (!it && revs->ignore_missing)
        return 0;

    if (it->type != OBJ_TAG)
        break;

    if (!((struct tag*)it)->tagged)
        return 0;

    oidcpy(&oid, &((struct tag*)it)->tagged->oid);
}
",,
implicit_predicate,revision.c,2047,+,+,"symmetric ? ""Invalid symmetric difference expression %s"" : ""Invalid revision range %s""",6,"	die(symmetric
	    ? ""Invalid symmetric difference expression %s""
	    : ""Invalid revision range %s"", arg);"
implicit_predicate,revision.c,2165,-,+,,10,	flags = flags & UNINTERESTING ? flags | BOTTOM : flags & ~BOTTOM;
implicit_predicate,revision.c,2181,+,-,"if (add_parents_only(revs, arg, flags, 0))
    return 0;
",,
implicit_predicate,revision.c,2195,+,-,"if (mark[2]){
    if (strtol_i(mark + 2, 10, &exclude_parent) || exclude_parent < 1)
        return -1;
}
",,
implicit_predicate,revision.c,2221,-,+,,10,		return revs->ignore_missing ? 0 : -1;
implicit_predicate,revision.c,2910,+,-,"if (seen_dashdash)
    read_pathspec_from_stdin(&sb, prune);
",,
implicit_predicate,revision.c,2967,-,+,,15,	revarg_opt = opt ? opt->revarg_opt : 0;
implicit_predicate,revision.c,2968,+,-,"if (seen_dashdash)
    revarg_opt |= REVARG_CANNOT_BE_FILENAME;
",,
implicit_predicate,revision.c,3011,+,-,"if (handle_revision_arg(arg, revs, flags, revarg_opt)){
    int j;
    if (seen_dashdash || *arg == '^')
        die(""bad revision '%s'"", arg);

    for (j = i;j < argc;j++)
        verify_filename(revs->prefix, argv[j], j == i);
    strvec_pushv(&prune_data, argv + i);
    break;
}
",,
implicit_predicate,revision.c,3052,-,+,,15,		revs->def = opt ? opt->def : NULL;
implicit_predicate,revision.c,3081,+,-,"if (want_ancestry(revs))
    revs->limited = 1;
",,
implicit_predicate,revision.c,3309,+,-,"if (ts->treesame[n]){
    if (p->item->object.flags & TMP_MARK){
        if (!marked)
            marked = p->item;
    }else{
        if (!unmarked){
            unmarked = p->item;
            break;
        }
    }
}
",,
implicit_predicate,revision.c,3430,+,-,"if (cnt){
    tail = &commit_list_insert(commit, tail)->next;
    return tail;
}
",,
implicit_predicate,revision.c,3474,+,-,"if (marked)
    marked -= leave_one_treesame_to_parent(revs, commit);
",,
implicit_predicate,revision.c,3476,+,-,"if (marked)
    cnt = remove_marked_parents(revs, commit);
",,
implicit_predicate,revision.c,3679,+,-,"if (*pi)
    (*pi)++;
else
    *pi = 2;
",,
implicit_predicate,revision.c,4054,-,+,,9,"	return revs->reflog_info ?
		get_reflog_timestamp(revs->reflog_info) :
		commit->date;"
implicit_predicate,revision.c,4229,+,-,"while (1){
    struct commit* commit;
    if (revs->reflog_info)
        commit = next_reflog_entry(revs->reflog_info);
    else
        if (revs->topo_walk_info)
            commit = next_topo_commit(revs);
        else
            commit = pop_commit(&revs->commits);

    if (!commit)
        return NULL;

    if (revs->reflog_info)
        commit->object.flags &= ~(ADDED | SEEN | SHOWN);

    if (!revs->limited){
        if (revs->max_age != -1 && comparison_date(revs, commit) < revs->max_age)
            continue;

        if (revs->reflog_info)
            try_to_simplify_commit(revs, commit);
        else
            if (revs->topo_walk_info)
                expand_topo_walk(revs, commit);
            else
                if (process_parents(revs, commit, &revs->commits, NULL) < 0){
                    if (!revs->ignore_missing_links)
                        die(""Failed to traverse parents of commit %s"", oid_to_hex(&commit->object.oid));
                }
    }
    switch (simplify_commit(revs, commit)){
        case commit_ignore:
            continue;
        case commit_error:
            die(""Failed to simplify parents of commit %s"", oid_to_hex(&commit->object.oid));
        default:
            if (revs->track_linear)
                track_linear(revs, commit);

            return commit;
    }
}
",,
implicit_predicate,rm.c,208,+,-,"if (staged_changes)
    string_list_append(&files_cached, name);
",,
implicit_predicate,rm.c,210,+,-,"if (local_changes)
    string_list_append(&files_local, name);
",,
implicit_predicate,rm.c,287,+,-,"if (pathspec_file_nul){
    die(_(""the option '%s' requires '%s'""), ""--pathspec-file-nul"", ""--pathspec-from-file"");
}
",,
implicit_predicate,rm.c,336,+,-,"if (seen[i])
    seen_any = 1;
else
    if (ignore_unmatch)
        continue;
    else
        if (!include_sparse && matches_skip_worktree(&pathspec, i, &skip_worktree_seen))
            string_list_append(&only_match_skip_worktree, original);
        else
            die(_(""pathspec '%s' did not match any files""), original);
",,
implicit_predicate,rm.c,338,+,-,"if (ignore_unmatch)
    continue;
else
    if (!include_sparse && matches_skip_worktree(&pathspec, i, &skip_worktree_seen))
        string_list_append(&only_match_skip_worktree, original);
    else
        die(_(""pathspec '%s' did not match any files""), original);
",,
implicit_predicate,rm.c,348,-,+,,9,"				    *original ? original : ""."");"
implicit_predicate,rm.c,381,+,-,"if (check_local_mod(&oid, index_only))
    exit(1);
",,
implicit_predicate,rm.c,398,+,-,"if (show_only)
    return 0;
",,
implicit_predicate,rm.c,412,+,+,force ? REMOVE_DIR_PURGE_ORIGINAL_CWD : 0,14,		int flag = force ? REMOVE_DIR_PURGE_ORIGINAL_CWD : 0;
implicit_predicate,rm.c,415,+,-,"if (list.entry[i].is_submodule){
    strbuf_reset(&buf);
    strbuf_addstr(&buf, path);
    if (remove_dir_recursively(&buf, flag))
        die(_(""could not remove '%s'""), path);

    removed = 1;
    if (!remove_path_from_gitmodules(path))
        gitmodules_modified = 1;

    continue;
}
",,
implicit_predicate,rm.c,434,+,-,"if (gitmodules_modified)
    stage_updated_gitmodules(the_repository->index);
",,
implicit_predicate,run-command.c,197,+,-,"while (1){
    const char* end = strchrnul(p, ':');
    strbuf_reset(&buf);
    if (end != p){
        strbuf_add(&buf, p, end - p);
        strbuf_addch(&buf, '/');
    }
    strbuf_addstr(&buf, file);
    if (is_executable(buf.buf))
        return strbuf_detach(&buf, NULL);

    if (!*end)
        break;

    p = end + 1;
}
",,
implicit_predicate,run-command.c,269,+,+,exists_in_PATH(file) ? EACCES : ENOENT,11,		errno = exists_in_PATH(file) ? EACCES : ENOENT;
implicit_predicate,run-command.c,514,+,-,"CHECK_BUG(pthread_sigmask(SIG_SETMASK, &all, &as->old),
		""blocking all signals"");
",,
implicit_predicate,run-command.c,516,+,-,"CHECK_BUG(pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &as->cs),
		""disabling cancellation"");
",,
implicit_predicate,run-command.c,527,+,-,"CHECK_BUG(pthread_setcancelstate(as->cs, NULL),
		""re-enabling cancellation"");
",,
implicit_predicate,run-command.c,529,+,-,"CHECK_BUG(pthread_sigmask(SIG_SETMASK, &as->old, NULL),
		""restoring signal mask"");
",,
implicit_predicate,run-command.c,617,+,-,"if (printed_unset)
    strbuf_addch(dst, ';');
",,
implicit_predicate,run-command.c,674,+,-,"if (need_in){
    if (pipe(fdin) < 0){
        failed_errno = errno;
        if (cmd->out > 0)
            close(cmd->out);

        str = ""standard input"";
        goto fail_pipe;
    }
    cmd->in = fdin[1];
}
",,
implicit_predicate,run-command.c,688,+,-,"if (need_out){
    if (pipe(fdout) < 0){
        failed_errno = errno;
        if (need_in)
            close_pair(fdin);
        else
            if (cmd->in)
                close(cmd->in);

        str = ""standard output"";
        goto fail_pipe;
    }
    cmd->out = fdout[0];
}
",,
implicit_predicate,run-command.c,691,+,-,"if (need_in)
    close_pair(fdin);
else
    if (cmd->in)
        close(cmd->in);
",,
implicit_predicate,run-command.c,702,+,-,"if (need_err){
    if (pipe(fderr) < 0){
        failed_errno = errno;
        if (need_in)
            close_pair(fdin);
        else
            if (cmd->in)
                close(cmd->in);

        if (need_out)
            close_pair(fdout);
        else
            if (cmd->out)
                close(cmd->out);

        str = ""standard error"";
        fail_pipe:
        error(""cannot create %s pipe for %s: %s"", str, cmd->args.v[0], strerror(failed_errno));
        child_process_clear(cmd);
        errno = failed_errno;
        return -1;
    }
    cmd->err = fderr[0];
}
",,
implicit_predicate,run-command.c,705,+,-,"if (need_in)
    close_pair(fdin);
else
    if (cmd->in)
        close(cmd->in);
",,
implicit_predicate,run-command.c,709,+,-,"if (need_out)
    close_pair(fdout);
else
    if (cmd->out)
        close(cmd->out);
",,
implicit_predicate,run-command.c,787,+,-,"if (need_in){
    child_dup2(fdin[0], 0);
    child_close_pair(fdin);
}else
    if (cmd->in){
        child_dup2(cmd->in, 0);
        child_close(cmd->in);
    }
",,
implicit_predicate,run-command.c,797,+,-,"if (need_err){
    child_dup2(fderr[1], 2);
    child_close_pair(fderr);
}else
    if (cmd->err > 1){
        child_dup2(cmd->err, 2);
        child_close(cmd->err);
    }
",,
implicit_predicate,run-command.c,809,+,-,"if (need_out){
    child_dup2(fdout[1], 1);
    child_close_pair(fdout);
}else
    if (cmd->out > 1){
        child_dup2(cmd->out, 1);
        child_close(cmd->out);
    }
",,
implicit_predicate,run-command.c,939,+,-,"if (need_in)
    close_pair(fdin);
else
    if (cmd->in)
        close(cmd->in);
",,
implicit_predicate,run-command.c,943,+,-,"if (need_out)
    close_pair(fdout);
else
    if (cmd->out)
        close(cmd->out);
",,
implicit_predicate,run-command.c,947,+,-,"if (need_err)
    close_pair(fderr);
else
    if (cmd->err)
        close(cmd->err);
",,
implicit_predicate,run-command.c,956,+,-,"if (need_in)
    close(fdin[0]);
else
    if (cmd->in)
        close(cmd->in);
",,
implicit_predicate,run-command.c,961,+,-,"if (need_out)
    close(fdout[1]);
else
    if (cmd->out)
        close(cmd->out);
",,
implicit_predicate,run-command.c,966,+,-,"if (need_err)
    close(fderr[1]);
else
    if (cmd->err)
        close(cmd->err);
",,
implicit_predicate,run-command.c,1000,+,-,"if (code)
    return code;
",,
implicit_predicate,run-command.c,1123,+,-,"if (in_async())
    async_exit(141);
",,
implicit_predicate,run-command.c,1140,+,-,"if (need_in){
    if (pipe(fdin) < 0){
        if (async->out > 0)
            close(async->out);

        return error_errno(""cannot create pipe"");
    }
    async->in = fdin[1];
}
",,
implicit_predicate,run-command.c,1150,+,-,"if (need_out){
    if (pipe(fdout) < 0){
        if (need_in)
            close_pair(fdin);
        else
            if (async->in)
                close(async->in);

        return error_errno(""cannot create pipe"");
    }
    async->out = fdout[0];
}
",,
implicit_predicate,run-command.c,1152,+,-,"if (need_in)
    close_pair(fdin);
else
    if (async->in)
        close(async->in);
",,
implicit_predicate,run-command.c,1161,+,-,"if (need_in)
    proc_in = fdin[0];
else
    if (async->in)
        proc_in = async->in;
    else
        proc_in = -1;
",,
implicit_predicate,run-command.c,1168,+,-,"if (need_out)
    proc_out = fdout[1];
else
    if (async->out)
        proc_out = async->out;
    else
        proc_out = -1;
",,
implicit_predicate,run-command.c,1227,+,-,"if (err){
    error(_(""cannot create async thread: %s""), strerror(err));
    goto error;
}
",,
implicit_predicate,run-command.c,1236,+,-,"if (need_in)
    close_pair(fdin);
else
    if (async->in)
        close(async->in);
",,
implicit_predicate,run-command.c,1241,+,-,"if (need_out)
    close_pair(fdout);
else
    if (async->out)
        close(async->out);
",,
implicit_predicate,run-command.c,1384,+,-,"while (pump_io_round(slots, nr, pfd));

",,
implicit_predicate,run-command.c,1390,+,-,"if (slots[i].error){
    errno = slots[i].error;
    return -1;
}
",,
implicit_predicate,run-command.c,1596,-,+,,8,"				   opts->ungroup ? NULL : &pp->children[i].err,"
implicit_predicate,run-command.c,1613,-,+,,31,"			code = opts->start_failure(opts->ungroup ? NULL :
						   &pp->children[i].err,"
implicit_predicate,run-command.c,1624,+,-,"if (code)
    pp->shutdown = 1;
",,
implicit_predicate,run-command.c,1691,-,+,,37,"			code = opts->task_finished(code, opts->ungroup ? NULL :
						   &pp->children[i].err, opts->data,"
implicit_predicate,run-command.c,1697,+,-,"if (code)
    result = code;
",,
implicit_predicate,run-command.c,1759,+,-,"while (1){
    for (i = 0;i < spawn_cap && !pp.shutdown && pp.nr_processes < opts->processes;i++){
        code = pp_start_one(&pp, opts);
        if (!code)
            continue;

        if (code < 0){
            pp.shutdown = 1;
            kill_children(&pp, opts, -code);
        }
        break;
    }
    if (!pp.nr_processes)
        break;

    if (opts->ungroup){
        for (size_t i = 0;i < opts->processes;i++)
            pp.children[i].state = GIT_CP_WAIT_CLEANUP;
    }else{
        pp_buffer_stderr(&pp, opts, output_timeout);
        pp_output(&pp);
    }
    code = pp_collect_finished(&pp, opts);
    if (code){
        pp.shutdown = 1;
        if (code < 0)
            kill_children(&pp, opts, -code);
    }
}
",,
implicit_predicate,run-command.c,1783,+,-,"if (code){
    pp.shutdown = 1;
    if (code < 0)
        kill_children(&pp, opts, -code);
}
",,
implicit_predicate,run-command.c,1807,+,+,"quiet ? ""--quiet"" : ""--no-quiet""",28,"	strvec_push(&maint->args, quiet ? ""--quiet"" : ""--no-quiet"");"
implicit_predicate,run-command.c,1856,+,-,"if (ret){
    sbgr = SBGR_ERROR;
    goto done;
}
",,
implicit_predicate,sane-ctype.h,60,+,-,"if (is_lower)
    return (x & 0x20) != 0;
else
    return (x & 0x20) == 0;
",,
implicit_predicate,scalar.c,64,+,-,"if (enlistment_is_repo_parent)
    strbuf_addbuf(enlistment_root, &path);
else
    strbuf_addstr(enlistment_root, the_repository->worktree);
",,
implicit_predicate,scalar.c,176,+,-,"if (set_scalar_config(config + i, reconfigure))
    return error(_(""could not configure %s=%s""), config[i].key, config[i].value);
",,
implicit_predicate,scalar.c,181,+,-,"if (have_fsmonitor_support()){
    struct scalar_config fsmonitor = {""core.fsmonitor"", ""true""};
    if (set_scalar_config(&fsmonitor, reconfigure))
        return error(_(""could not configure %s=%s""), fsmonitor.key, fsmonitor.value);
}
",,
implicit_predicate,scalar.c,183,+,-,"if (set_scalar_config(&fsmonitor, reconfigure))
    return error(_(""could not configure %s=%s""), fsmonitor.key, fsmonitor.value);
",,
implicit_predicate,scalar.c,212,+,+,"enable ? ""start"" : ""unregister""",10,"		       enable ? ""start"" : ""unregister"","
implicit_predicate,scalar.c,213,+,+,"enable ? NULL : ""--force""",10,"		       enable ? NULL : ""--force"","
implicit_predicate,scalar.c,234,+,+,"add ? ""--add"" : ""--unset""",39,"	return run_git(""config"", ""--global"", add ? ""--add"" : ""--unset"","
implicit_predicate,scalar.c,235,+,+,"add ? ""--no-fixed-value"" : ""--fixed-value""",10,"		       add ? ""--no-fixed-value"" : ""--fixed-value"","
implicit_predicate,scalar.c,261,+,-,"if (add_or_remove_enlistment(1))
    return error(_(""could not add enlistment""));
",,
implicit_predicate,scalar.c,264,+,-,"if (set_recommended_config(0))
    return error(_(""could not set recommended config""));
",,
implicit_predicate,scalar.c,267,+,-,"if (toggle_maintenance(1))
    warning(_(""could not turn on maintenance""));
",,
implicit_predicate,scalar.c,281,+,-,"if (toggle_maintenance(0))
    res = error(_(""could not turn off maintenance""));
",,
implicit_predicate,scalar.c,284,+,-,"if (add_or_remove_enlistment(0))
    res = error(_(""could not remove enlistment""));
",,
implicit_predicate,scalar.c,370,+,-,"if (unregister_dir())
    return error(_(""failed to unregister repository""));
",,
implicit_predicate,scalar.c,463,+,-,"if (src)
    dir = xstrfmt(""%s/src"", enlistment);
else
    dir = xstrdup(enlistment);
",,
implicit_predicate,scalar.c,477,+,-,"if ((res = run_git(""-c"", buf.buf, ""init"", ""--"", dir, NULL)))
    goto cleanup;
",,
implicit_predicate,scalar.c,498,+,+,"single_branch ? branch : ""*""",10,"		       single_branch ? branch : ""*"","
implicit_predicate,scalar.c,499,+,+,"single_branch ? branch : ""*""",10,"		       single_branch ? branch : ""*"") ||"
implicit_predicate,scalar.c,510,+,-,"if (set_recommended_config(0))
    return error(_(""could not configure '%s'""), dir);
",,
implicit_predicate,scalar.c,513,+,-,"if ((res = run_git(""fetch"", ""--quiet"", show_progress ? ""--progress"" : ""--no-progress"", ""origin"", NULL))){
    warning(_(""partial clone failed; attempting full clone""));
    if (set_config(""remote.origin.promisor"") || set_config(""remote.origin.partialCloneFilter"")){
        res = error(_(""could not configure for full clone""));
        goto cleanup;
    }
    if ((res = run_git(""fetch"", ""--quiet"", show_progress ? ""--progress"" : ""--no-progress"", ""origin"", NULL)))
        goto cleanup;
}
",,
implicit_predicate,scalar.c,514,+,+,"show_progress ? ""--progress"" : ""--no-progress""",5,"				show_progress ? ""--progress"" : ""--no-progress"","
implicit_predicate,scalar.c,524,+,-,"if ((res = run_git(""fetch"", ""--quiet"", show_progress ? ""--progress"" : ""--no-progress"", ""origin"", NULL)))
    goto cleanup;
",,
implicit_predicate,scalar.c,525,+,+,"show_progress ? ""--progress"" : ""--no-progress""",6,"					show_progress ? ""--progress"" : ""--no-progress"","
implicit_predicate,scalar.c,530,+,-,"if ((res = set_config(""branch.%s.remote=origin"", branch)))
    goto cleanup;
",,
implicit_predicate,scalar.c,532,+,-,"if ((res = set_config(""branch.%s.merge=refs/heads/%s"", branch, branch)))
    goto cleanup;
",,
implicit_predicate,scalar.c,539,+,-,"if (res)
    goto cleanup;
",,
implicit_predicate,scalar.c,682,+,-,"if (remove_deleted_enlistment(&buf))
    error(_(""could not remove stale scalar.repo '%s'""), dir);
else{
    warning(_(""removed stale scalar.repo '%s'""), dir);
    succeeded = 1;
}
",,
implicit_predicate,scalar.c,796,+,-,"if (register_dir())
    return -1;
",,
implicit_predicate,scalar.c,799,+,-,"if (run_git(""maintenance"", ""run"", ""--task"", tasks[i].task, NULL))
    return -1;
",,
implicit_predicate,send-pack.c,26,+,-,"if (unset){
    *(int*)(opt->value) = SEND_PACK_PUSH_CERT_NEVER;
    return 0;
}
",,
implicit_predicate,send-pack.c,53,+,-,"if (negative)
    putc('^', fh);
",,
implicit_predicate,send-pack.c,93,-,+,,11,	po.out = args->stateless_rpc ? -1 : fd;
implicit_predicate,send-pack.c,124,+,-,"while (1){
    ssize_t n = xread(po.out, buf, LARGE_PACKET_MAX);
    if (n <= 0)
        break;

    send_sideband(fd, -1, buf, n, LARGE_PACKET_MAX);
}
",,
implicit_predicate,send-pack.c,136,+,-,"if (rc){
    if (rc > 128 && rc != 141)
        error(""pack-objects died of signal %d"", rc - 128);

    return -1;
}
",,
implicit_predicate,send-pack.c,173,+,-,"while (1){
    struct object_id old_oid, new_oid;
    const char* head;
    const char* refname;
    char* p;
    if (packet_reader_read(reader) != PACKET_READ_NORMAL)
        break;

    head = reader->line;
    p = strchr(head, ' ');
    if (!p){
        error(""invalid status line from remote: %s"", reader->line);
        ret = -1;
        break;
    }
    *p++ = '\0';
    if (!strcmp(head, ""option"")){
        const char *key, *val;
        if (!hint || !(report || new_report)){
            if (!once++)
                error(""'option' without a matching 'ok/ng' directive"");

            ret = -1;
            continue;
        }
        if (new_report){
            if (!hint->report){
                CALLOC_ARRAY(hint->report, 1);
                report = hint->report;
            }else{
                report = hint->report;
                while (report->next)
                    report = report->next;
                CALLOC_ARRAY(report->next, 1);
                report = report->next;
            }
            new_report = 0;
        }
        key = p;
        p = strchr(key, ' ');
        if (p)
            *p++ = '\0';

        val = p;
        if (!strcmp(key, ""refname""))
            report->ref_name = xstrdup_or_null(val);
        else
            if (!strcmp(key, ""old-oid"") && val && !parse_oid_hex(val, &old_oid, &val))
                report->old_oid = oiddup(&old_oid);
            else
                if (!strcmp(key, ""new-oid"") && val && !parse_oid_hex(val, &new_oid, &val))
                    report->new_oid = oiddup(&new_oid);
                else
                    if (!strcmp(key, ""forced-update""))
                        report->forced_update = 1;

        continue;
    }
    report = NULL;
    new_report = 0;
    if (strcmp(head, ""ok"") && strcmp(head, ""ng"")){
        error(""invalid ref status from remote: %s"", head);
        ret = -1;
        break;
    }
    refname = p;
    p = strchr(refname, ' ');
    if (p)
        *p++ = '\0';

    if (hint)
        hint = find_ref_by_name(hint, refname);

    if (!hint)
        hint = find_ref_by_name(refs, refname);

    if (!hint){
        warning(""remote reported status on unknown ref: %s"", refname);
        continue;
    }
    if (hint->status != REF_STATUS_EXPECTING_REPORT && hint->status != REF_STATUS_OK && hint->status != REF_STATUS_REMOTE_REJECT){
        warning(""remote reported status on unexpected ref: %s"", refname);
        continue;
    }
    if (!strcmp(head, ""ng"")){
        hint->status = REF_STATUS_REMOTE_REJECT;
        if (p)
            hint->remote_status = xstrdup(p);
        else
            hint->remote_status = ""failed"";
    }else{
        hint->status = REF_STATUS_OK;
        hint->remote_status = xstrdup_or_null(p);
        new_report = 1;
    }
}
",,
implicit_predicate,send-pack.c,198,+,-,"if (new_report){
    if (!hint->report){
        CALLOC_ARRAY(hint->report, 1);
        report = hint->report;
    }else{
        report = hint->report;
        while (report->next)
            report = report->next;
        CALLOC_ARRAY(report->next, 1);
        report = report->next;
    }
    new_report = 0;
}
",,
implicit_predicate,send-pack.c,231,-,+,,22,	args.push_options = push_options.nr ? &push_options : NULL;
implicit_predicate,send-pack.c,234,+,-,"if (from_stdin){
    if (args.stateless_rpc){
        const char* buf;
        while ((buf = packet_read_line(0, NULL)))
            refspec_append(&rs, buf);
    }else{
        struct strbuf line = STRBUF_INIT;
        while (strbuf_getline(&line, stdin) != EOF)
            refspec_append(&rs, line.buf);
        strbuf_release(&line);
    }
}
",,
implicit_predicate,send-pack.c,273,-,+,,4,			args.verbose ? CONNECT_VERBOSE : 0);
implicit_predicate,send-pack.c,298,+,-,"if (send_all)
    flags |= MATCH_REFS_ALL;
",,
implicit_predicate,send-pack.c,318,+,-,"if (helper_status)
    print_helper_status(remote_refs);
",,
implicit_predicate,send-pack.c,442,+,-,"do{
    char hex_hash[GIT_MAX_HEXSZ + 1];
    int read_len = read_in_full(child.out, hex_hash, len);
    struct object_id oid;
    const char* end;
    if (!read_len)
        break;

    if (read_len != len)
        die(""invalid length read %d"", read_len);

    if (parse_oid_hex(hex_hash, &oid, &end) || *end != '\n')
        die(""invalid hash"");

    oid_array_append(commons, &oid);
} while (1);
",,
implicit_predicate,send-pack.c,504,+,-,"if (push_negotiate)
    get_commons_through_negotiation(args->url, remote_refs, &commons);
",,
implicit_predicate,send-pack.c,568,+,-,"if (use_sideband)
    strbuf_addstr(&cap_buf, "" side-band-64k"");
",,
implicit_predicate,send-pack.c,572,+,-,"if (use_atomic)
    strbuf_addstr(&cap_buf, "" atomic"");
",,
implicit_predicate,send-pack.c,574,+,-,"if (use_push_options)
    strbuf_addstr(&cap_buf, "" push-options"");
",,
implicit_predicate,send-pack.c,576,+,-,"if (object_format_supported)
    strbuf_addf(&cap_buf, "" object-format=%s"", the_hash_algo->name);
",,
implicit_predicate,send-pack.c,578,+,-,"if (agent_supported)
    strbuf_addf(&cap_buf, "" agent=%s"", git_user_agent_sanitized());
",,
implicit_predicate,send-pack.c,580,+,-,"if (advertise_sid)
    strbuf_addf(&cap_buf, "" session-id=%s"", trace2_session_id());
",,
implicit_predicate,send-pack.c,606,+,-,"if (use_atomic){
    strbuf_release(&req_buf);
    strbuf_release(&cap_buf);
    reject_atomic_push(remote_refs, args->send_mirror);
    error(""atomic push failed for ref %s. status: %d\n"", ref->name, ref->status);
    return args->porcelain ? 0 : -1;
}
",,
implicit_predicate,send-pack.c,612,-,+,,12,				return args->porcelain ? 0 : -1;
implicit_predicate,send-pack.c,657,+,-,<!!!>,,
implicit_predicate,send-pack.c,705,+,-,"if (status_report)
    receive_status(&reader, remote_refs);
",,
implicit_predicate,send-pack.c,708,+,-,"if (use_sideband){
    close(demux.out);
    finish_async(&demux);
}
",,
implicit_predicate,sequencer.c,304,-,+,,20,"		opts->gpg_sign = git_config_bool(k, v) ? xstrdup("""") : NULL;"
implicit_predicate,sequencer.c,341,+,-,"if (is_rebase_i(opts))
    return rebase_path();
",,
implicit_predicate,sequencer.c,348,+,-,"if (is_rebase_i(opts))
    return rebase_path_todo();
",,
implicit_predicate,sequencer.c,389,+,-,"if (found_sob_last)
    return 3;
",,
implicit_predicate,sequencer.c,391,+,-,"if (found_sob)
    return 2;
",,
implicit_predicate,sequencer.c,436,+,-,"while (*p){
    char* eol = strchr(p, '\n');
    if (eol)
        *eol = '\0';

    if (refs_delete_ref(get_main_ref_store(the_repository), ""(rebase) cleanup"", p, NULL, 0) < 0){
        warning(_(""could not delete '%s'""), p);
        ret = -1;
    }
    if (!eol)
        break;

    p = eol + 1;
}
",,
implicit_predicate,sequencer.c,522,+,-,"if (is_rebase_i(opts))
    msg = rebase_resolvemsg;
else
    msg = getenv(""GIT_CHERRY_PICK_HELP"");
",,
implicit_predicate,sequencer.c,539,+,-,"if (show_hint){
    if (opts->no_commit)
        advise_if_enabled(ADVICE_MERGE_CONFLICT, _(""after resolving the conflicts, mark the corrected paths\nwith 'git add <paths>' or 'git rm <paths>'""));
    else
        if (opts->action == REPLAY_PICK)
            advise_if_enabled(ADVICE_MERGE_CONFLICT, _(""After resolving the conflicts, mark them with\n\""git add/rm <pathspec>\"", then run\n\""git cherry-pick --continue\"".\nYou can instead skip this commit with \""git cherry-pick --skip\"".\nTo abort and get back to the state before \""git cherry-pick\"",\nrun \""git cherry-pick --abort\"".""));
        else
            if (opts->action == REPLAY_REVERT)
                advise_if_enabled(ADVICE_MERGE_CONFLICT, _(""After resolving the conflicts, mark them with\n\""git add/rm <pathspec>\"", then run\n\""git revert --continue\"".\nYou can instead skip this commit with \""git revert --skip\"".\nTo abort and get back to the state before \""git revert\"",\nrun \""git revert --abort\"".""));
            else
                BUG(""unexpected pick action in print_advice()"");
}
",,
implicit_predicate,sequencer.c,687,+,+,use_editor ? COMMIT_MSG_CLEANUP_ALL : COMMIT_MSG_CLEANUP_SPACE,10,"		return use_editor ? COMMIT_MSG_CLEANUP_ALL :
				    COMMIT_MSG_CLEANUP_SPACE;"
implicit_predicate,sequencer.c,696,+,+,use_editor ? COMMIT_MSG_CLEANUP_SCISSORS : COMMIT_MSG_CLEANUP_SPACE,10,"		return use_editor ? COMMIT_MSG_CLEANUP_SCISSORS :
				    COMMIT_MSG_CLEANUP_SPACE;"
implicit_predicate,sequencer.c,764,-,+,,15,"	o.ancestor = base ? base_label : ""(empty tree)"";"
implicit_predicate,sequencer.c,766,-,+,,14,"	o.branch2 = next ? next_label : ""(empty tree)"";"
implicit_predicate,sequencer.c,767,+,-,"if (is_rebase_i(opts))
    o.buffer_output = 2;
",,
implicit_predicate,sequencer.c,774,-,+,,14,"	next_tree = next ? repo_get_commit_tree(r, next) : empty_tree(r);"
implicit_predicate,sequencer.c,775,-,+,,14,"	base_tree = base ? repo_get_commit_tree(r, base) : empty_tree(r);"
implicit_predicate,sequencer.c,929,+,-,"while (*buf){
    struct string_list_item* item;
    char* np;
    char* cp = strchr(buf, '=');
    if (!cp){
        np = strchrnul(buf, '\n');
        return error(_(""no key present in '%.*s'""), (int)(np - buf), buf);
    }
    np = strchrnul(cp, '\n');
    *cp++ = '\0';
    item = string_list_append(list, buf);
    buf = np + (*np == '\n');
    *np = '\0';
    cp = sq_dequote(cp);
    if (!cp)
        return error(_(""unable to dequote value of '%s'""), item->string);

    item->util = xstrdup(cp);
}
",,
implicit_predicate,sequencer.c,1113,+,-,"if (rc)
    fputs(buf.buf, stderr);
",,
implicit_predicate,sequencer.c,1157,-,+,,9,"			     opts->ignore_date ?
			     """" :
			     author_date_from_env(&cmd.env));"
implicit_predicate,sequencer.c,1167,+,-,"if ((flags & AMEND_MSG))
    strvec_push(&cmd.args, ""--amend"");
",,
implicit_predicate,sequencer.c,1177,+,-,"if ((flags & CLEANUP_MSG))
    strvec_push(&cmd.args, ""--cleanup=strip"");
",,
implicit_predicate,sequencer.c,1179,+,-,"if ((flags & VERBATIM_MSG))
    strvec_push(&cmd.args, ""--cleanup=verbatim"");
",,
implicit_predicate,sequencer.c,1181,+,-,"if ((flags & EDIT_MSG))
    strvec_push(&cmd.args, ""-e"");
else
    if (!(flags & CLEANUP_MSG) && !opts->signoff && !opts->record_origin && !opts->explicit_cleanup)
        strvec_push(&cmd.args, ""--cleanup=verbatim"");
",,
implicit_predicate,sequencer.c,1188,+,-,"if ((flags & ALLOW_EMPTY))
    strvec_push(&cmd.args, ""--allow-empty"");
",,
implicit_predicate,sequencer.c,1300,-,+,,8,"				   old_head ? &old_head->object.oid : null_oid(),"
implicit_predicate,sequencer.c,1328,+,-,"if (code)
    return code;
",,
implicit_predicate,sequencer.c,1412,+,-,"if (config_exists)
    return _(implicit_ident_advice_config);
else
    return _(implicit_ident_advice_noconfig);
",,
implicit_predicate,sequencer.c,1490,-,+,,25,"	printf(""[%s%s "", head, (flags & SUMMARY_INITIAL_COMMIT) ?
						_("" (root-commit)"") : """");"
implicit_predicate,sequencer.c,1556,+,-,"if (parse_head(r, &current_head))
    return -1;
",,
implicit_predicate,sequencer.c,1559,+,-,"if (flags & AMEND_MSG){
    const char* exclude_gpgsig[] = {""gpgsig"", ""gpgsig-sha256"", NULL};
    const char* out_enc = get_commit_output_encoding();
    const char* message = repo_logmsg_reencode(r, current_head, NULL, out_enc);
    if (!msg){
        const char* orig_message = NULL;
        find_commit_subject(message, &orig_message);
        msg = &commit_msg;
        strbuf_addstr(msg, orig_message);
        hook_commit = ""HEAD"";
    }
    author = amend_author = get_author(message);
    repo_unuse_commit_buffer(r, current_head, message);
    if (!author){
        res = error(_(""unable to parse commit author""));
        goto out;
    }
    parents = copy_commit_list(current_head->parents);
    extra = read_commit_extra_headers(current_head, exclude_gpgsig);
}else
    if (current_head && (!(flags & CREATE_ROOT_COMMIT) || (flags & AMEND_MSG))){
        commit_list_insert(current_head, &parents);
    }
",,
implicit_predicate,sequencer.c,1595,+,-,"if (flags & AMEND_MSG){
    if (current_head->parents){
        first_parent = current_head->parents->item;
        if (repo_parse_commit(r, first_parent)){
            res = error(_(""could not parse HEAD commit""));
            goto out;
        }
    }else{
        first_parent = NULL;
    }
}
",,
implicit_predicate,sequencer.c,1606,-,+,,13,"		if (oideq(first_parent
			  ? get_commit_tree_oid(first_parent)
			  : the_hash_algo->empty_tree,"
implicit_predicate,sequencer.c,1617,+,-,"if (res)
    goto out;
",,
implicit_predicate,sequencer.c,1629,+,-,"if (flags & CLEANUP_MSG)
    cleanup = COMMIT_MSG_CLEANUP_ALL;
else
    if (flags & VERBATIM_MSG)
        cleanup = COMMIT_MSG_CLEANUP_NONE;
    else
        if ((opts->signoff || opts->record_origin) && !opts->explicit_cleanup)
            cleanup = COMMIT_MSG_CLEANUP_SPACE;
        else
            cleanup = opts->default_msg_cleanup;
",,
implicit_predicate,sequencer.c,1631,+,-,"if (flags & VERBATIM_MSG)
    cleanup = COMMIT_MSG_CLEANUP_NONE;
else
    if ((opts->signoff || opts->record_origin) && !opts->explicit_cleanup)
        cleanup = COMMIT_MSG_CLEANUP_SPACE;
    else
        cleanup = opts->default_msg_cleanup;
",,
implicit_predicate,sequencer.c,1673,-,+,,11,"				      opts->ignore_date ? NULL : date.buf,"
implicit_predicate,sequencer.c,1709,+,-,"if (flags & AMEND_MSG)
    commit_post_rewrite(r, current_head, oid);
",,
implicit_predicate,sequencer.c,1746,-,+,,26,"		res = try_to_commit(r, msg_file ? &sb : NULL,"
implicit_predicate,sequencer.c,1761,+,-,"if (write_rebase_head(oid))
    return -1;
",,
implicit_predicate,sequencer.c,1819,+,-,"if (originally_empty)
    return opts->allow_empty;
else
    if (opts->keep_redundant_commits)
        return 1;
    else
        if (opts->drop_redundant_commits)
            return 2;
        else
            return 0;
",,
implicit_predicate,sequencer.c,2114,-,+,,23,"		strbuf_addstr(&buf, is_fixup_flag(command, flag) ?
			      _(skip_first_commit_msg_str) :
			      _(first_commit_msg_str));"
implicit_predicate,sequencer.c,2152,-,+,,8,"			    ctx->current_fixups.len ? ""\n"" : """","
implicit_predicate,sequencer.c,2174,+,-,"while (*bol){
    eol = strchrnul(bol, '\n');
    fprintf(out, ""%.*s %s\n"", (int)(eol - bol), bol, oid_to_hex(&newoid));
    if (!*eol)
        break;

    bol = eol + 1;
}
",,
implicit_predicate,sequencer.c,2235,+,+,should_edit(opts) ? EDIT_MSG : 0,23,	unsigned int flags = should_edit(opts) ? EDIT_MSG : 0;
implicit_predicate,sequencer.c,2236,+,+,should_edit(opts) ? NULL : git_path_merge_msg(r),25,	const char *msg_file = should_edit(opts) ? NULL : git_path_merge_msg(r);
implicit_predicate,sequencer.c,2264,+,-,"if (unborn)
    oidcpy(&head, the_hash_algo->empty_tree);
",,
implicit_predicate,sequencer.c,2266,+,+,"unborn ? empty_tree_oid_hex() : ""HEAD""",29,"		if (index_differs_from(r, unborn ? empty_tree_oid_hex() : ""HEAD"","
implicit_predicate,sequencer.c,2308,+,-,"if (is_rebase_i(opts))
    write_author_script(msg.message);
",,
implicit_predicate,sequencer.c,2466,+,-,"if (res){
    error(command == TODO_REVERT ? _(""could not revert %s... %s"") : _(""could not apply %s... %s""), short_commit_name(r, commit), msg.subject);
    print_advice(r, res == 1, opts);
    repo_rerere(r, opts->allow_rerere_auto);
    goto leave;
}
",,
implicit_predicate,sequencer.c,2497,-,+,,6,					commit? &commit->object.oid : NULL);
implicit_predicate,sequencer.c,2734,-,+,,9,	return item->commit ? 0 : -1;
implicit_predicate,sequencer.c,2773,+,-,"for (i = 1;*p;i++, p = next_p){
    char* eol = strchrnul(p, '\n');
    next_p = *eol ? eol + 1 : eol;
    if (p != eol && eol[-1] == '\r')
        eol--;

    item = append_new_todo(todo_list);
    item->offset_in_buf = p - todo_list->buf.buf;
    if (parse_insn_line(r, item, buf, p, eol)){
        res = error(_(""invalid line %d: %.*s""), i, (int)(eol - p), p);
        item->command = TODO_COMMENT + 1;
        item->arg_offset = p - buf;
        item->arg_len = (int)(eol - p);
        item->commit = NULL;
    }
    if (item->command != TODO_COMMENT)
        todo_list->total_nr++;

    if (fixup_okay);

    else
        if (is_fixup(item->command))
            res = error(_(""cannot '%s' without a previous commit""), command_to_string(item->command));
        else
            if (!is_noop(item->command))
                fixup_okay = 1;
}
",,
implicit_predicate,sequencer.c,2776,+,+,*eol ? eol + 1 : eol,12,		next_p = *eol ? eol + 1 /* skip LF */ : eol;
implicit_predicate,sequencer.c,2783,+,-,"if (parse_insn_line(r, item, buf, p, eol)){
    res = error(_(""invalid line %d: %.*s""), i, (int)(eol - p), p);
    item->command = TODO_COMMENT + 1;
    item->arg_offset = p - buf;
    item->arg_len = (int)(eol - p);
    item->commit = NULL;
}
",,
implicit_predicate,sequencer.c,2795,+,-,"if (fixup_okay);

else
    if (is_fixup(item->command))
        res = error(_(""cannot '%s' without a previous commit""), command_to_string(item->command));
    else
        if (!is_noop(item->command))
            fixup_okay = 1;
",,
implicit_predicate,sequencer.c,2934,+,-,"if (res){
    if (is_rebase_i(opts))
        return error(_(""please fix this using 'git rebase --edit-todo'.""));

    return error(_(""unusable instruction sheet: '%s'""), todo_file);
}
",,
implicit_predicate,sequencer.c,2935,+,-,"if (is_rebase_i(opts))
    return error(_(""please fix this using 'git rebase --edit-todo'.""));
",,
implicit_predicate,sequencer.c,2959,+,-,"if (is_rebase_i(opts)){
    struct todo_list done = TODO_LIST_INIT;
    if (strbuf_read_file(&done.buf, rebase_path_done(), 0) > 0 && !todo_list_parse_insn_buffer(r, done.buf.buf, &done))
        todo_list->done_nr = count_commands(&done);
    else
        todo_list->done_nr = 0;

    todo_list->total_nr = todo_list->done_nr + count_commands(todo_list);
    todo_list_release(&done);
    todo_list_write_total_nr(todo_list);
}
",,
implicit_predicate,sequencer.c,3029,-,+,,4,"			git_config_bool_or_int(key, value, ctx->kvi, &error_flag) ?
				RERERE_AUTOUPDATE : RERERE_NOAUTOUPDATE;"
implicit_predicate,sequencer.c,3082,+,-,"if (is_rebase_i(opts)){
    struct strbuf buf = STRBUF_INIT;
    int ret = 0;
    if (read_oneliner(&buf, rebase_path_gpg_sign_opt(), READ_ONELINER_SKIP_IF_EMPTY)){
        if (!starts_with(buf.buf, ""-S""))
            strbuf_reset(&buf);
        else{
            free(opts->gpg_sign);
            opts->gpg_sign = xstrdup(buf.buf + 2);
        }
        strbuf_reset(&buf);
    }
    if (read_oneliner(&buf, rebase_path_allow_rerere_autoupdate(), READ_ONELINER_SKIP_IF_EMPTY)){
        if (!strcmp(buf.buf, ""--rerere-autoupdate""))
            opts->allow_rerere_auto = RERERE_AUTOUPDATE;
        else
            if (!strcmp(buf.buf, ""--no-rerere-autoupdate""))
                opts->allow_rerere_auto = RERERE_NOAUTOUPDATE;

        strbuf_reset(&buf);
    }
    if (file_exists (rebase_path_verbose()))
        opts->verbose = 1;

    if (file_exists (rebase_path_quiet()))
        opts->quiet = 1;

    if (file_exists (rebase_path_signoff())){
        opts->allow_ff = 0;
        opts->signoff = 1;
    }
    if (file_exists (rebase_path_cdate_is_adate())){
        opts->allow_ff = 0;
        opts->committer_date_is_author_date = 1;
    }
    if (file_exists (rebase_path_ignore_date())){
        opts->allow_ff = 0;
        opts->ignore_date = 1;
    }
    if (file_exists (rebase_path_reschedule_failed_exec()))
        opts->reschedule_failed_exec = 1;
    else
        if (file_exists (rebase_path_no_reschedule_failed_exec()))
            opts->reschedule_failed_exec = 0;

    if (file_exists (rebase_path_drop_redundant_commits()))
        opts->drop_redundant_commits = 1;

    if (file_exists (rebase_path_keep_redundant_commits()))
        opts->keep_redundant_commits = 1;

    read_strategy_opts(opts, &buf);
    strbuf_reset(&buf);
    if (read_oneliner(&ctx->current_fixups, rebase_path_current_fixups(), READ_ONELINER_SKIP_IF_EMPTY)){
        const char* p = ctx->current_fixups.buf;
        ctx->current_fixup_count = 1;
        while ((p = strchr(p, '\n'))){
            ctx->current_fixup_count++;
            p++;
        }
    }
    if (read_oneliner(&buf, rebase_path_squash_onto(), 0)){
        if (repo_get_oid_committish(the_repository, buf.buf, &opts->squash_onto) < 0){
            ret = error(_(""unusable squash-onto""));
            goto done_rebase_i;
        }
        opts->have_squash_onto = 1;
    }
    done_rebase_i:
    strbuf_release(&buf);
    return ret;
}
",,
implicit_predicate,sequencer.c,3247,+,-,"if (prepare_revs(opts))
    return -1;
",,
implicit_predicate,sequencer.c,3308,+,+,"advise_skip ? ""--skip | "" : """"",5,"				advise_skip ? ""--skip | "" : """");"
implicit_predicate,sequencer.c,3423,+,-,"if (reset_merge(&oid))
    goto fail;
",,
implicit_predicate,sequencer.c,3479,+,-,"if (skip_single_pick())
    return error(_(""failed to skip the commit""));
",,
implicit_predicate,sequencer.c,3549,-,+,,12,"						     opts->edit ? ""true"" : ""false"");"
implicit_predicate,sequencer.c,3687,+,-,"if (to_amend){
    if (intend_to_amend())
        return -1;

    fprintf(stderr, _(""You can amend the commit now, with\n\n  git commit --amend %s\n\nOnce you are satisfied with your changes, run\n\n  git rebase --continue\n""), gpg_sign_opt_quoted(opts));
}else
    if (exit_code){
        if (commit)
            fprintf_ln(stderr, _(""Could not apply %s... %.*s""), short_commit_name(r, commit), subject_len, subject);
        else
            fprintf_ln(stderr, _(""Could not merge %.*s""), subject_len, subject);
    }
",,
implicit_predicate,sequencer.c,3688,+,-,"if (intend_to_amend())
    return -1;
",,
implicit_predicate,sequencer.c,3700,+,-,"if (exit_code){
    if (commit)
        fprintf_ln(stderr, _(""Could not apply %s... %.*s""), short_commit_name(r, commit), subject_len, subject);
    else
        fprintf_ln(stderr, _(""Could not merge %.*s""), subject_len, subject);
}
",,
implicit_predicate,sequencer.c,3751,+,-,"if (status){
    warning(_(""execution failed: %s\n%sYou can fix the problem, and then run\n\n  git rebase --continue\n\n""), command_line, dirty ? _(""and made changes to the index and/or the working tree.\n"") : """");
    if (status == 127)
        status = 1;
}else
    if (dirty){
        warning(_(""execution succeeded: %s\nbut left changes to the index and/or the working tree.\nCommit or stash your changes, and then run\n\n  git rebase --continue\n\n""), command_line);
        status = 1;
    }
",,
implicit_predicate,sequencer.c,3758,+,+,"dirty ? _(""and made changes to the index and/or the working tree.\n"") : """"",4,"			dirty ? _(""and made changes to the index and/or the ""
				""working tree.\n"") : """");"
implicit_predicate,sequencer.c,3763,+,-,"if (dirty){
    warning(_(""execution succeeded: %s\nbut left changes to the index and/or the working tree.\nCommit or stash your changes, and then run\n\n  git rebase --continue\n\n""), command_line);
    status = 1;
}
",,
implicit_predicate,sequencer.c,3859,-,+,,12,"			xstrdup(opts->reflog_action ? opts->reflog_action
						    : action_name(opts));"
implicit_predicate,sequencer.c,4096,+,-,"if (can_fast_forward){
    struct commit_list* p = commit->parents->next;
    for (j = to_merge;j && p;j = j->next, p = p->next)
        if (!oideq(&j->item->object.oid, &p->item->object.oid)){
            can_fast_forward = 0;
            break;
        }
    if (j || p)
        can_fast_forward = 0;
}
",,
implicit_predicate,sequencer.c,4113,+,-,"if (can_fast_forward){
    rollback_lock_file(&lock);
    ret = fast_forward_to(r, &commit->object.oid, &head_commit->object.oid, 0, opts);
    if (flags & TODO_EDIT_MERGE_MSG)
        goto fast_forward_edit;

    goto leave_merge;
}
",,
implicit_predicate,sequencer.c,4117,+,-,"if (flags & TODO_EDIT_MERGE_MSG)
    goto fast_forward_edit;
",,
implicit_predicate,sequencer.c,4152,-,+,,9,"				    to_merge->next ? ""branches"" : ""branch"","
implicit_predicate,sequencer.c,4177,-,+,,10,"				     opts->ignore_date ?
				     """" :
				     author_date_from_env(&cmd.env));"
implicit_predicate,sequencer.c,4294,+,-,"if (ret)
    repo_rerere(r, opts->allow_rerere_auto);
else
    ret = !!run_git_commit(git_path_merge_msg(r), opts, run_commit_flags);
",,
implicit_predicate,sequencer.c,4460,+,-,"if (updated)
    write_update_refs_state(&update_refs);
",,
implicit_predicate,sequencer.c,4509,+,-,"if (quiet)
    continue;
",,
implicit_predicate,sequencer.c,4512,+,-,"if (loop_res)
    strbuf_addf(&error_msg, ""\t%s\n"", item->string);
else
    strbuf_addf(&update_msg, ""\t%s\n"", item->string);
",,
implicit_predicate,sequencer.c,4525,+,-,"if (res)
    fprintf(stderr, _(""Failed to update the following refs with %s:\n%s""), ""--update-refs"", error_msg.buf);
",,
implicit_predicate,sequencer.c,4636,+,-,"if (attempt_apply){
    child.git_cmd = 1;
    child.no_stdout = 1;
    child.no_stderr = 1;
    strvec_push(&child.args, ""stash"");
    strvec_push(&child.args, ""apply"");
    strvec_push(&child.args, stash_oid);
    ret = run_command(&child);
}
",,
implicit_predicate,sequencer.c,4666,+,+,"attempt_apply ? _(""Applying autostash resulted in conflicts."") : _(""Autostash exists; creating a new stash entry."")",5,"				attempt_apply ?
				_(""Applying autostash resulted in conflicts."") :
				_(""Autostash exists; creating a new stash entry.""));"
implicit_predicate,sequencer.c,4797,+,-,"if (read_populate_todo(r, todo_list, opts))
    return -1;
",,
implicit_predicate,sequencer.c,4827,+,-,"if (is_rebase_i(opts))
    ctx->reflog_message = reflog_message(opts, command_to_string(item->command), NULL);
",,
implicit_predicate,sequencer.c,4894,+,-,"if (read_and_refresh_cache(r, opts))
    return -1;
",,
implicit_predicate,sequencer.c,4907,+,-,"if (save_todo(todo_list, opts, reschedule))
    return -1;
",,
implicit_predicate,sequencer.c,4909,+,-,"if (is_rebase_i(opts)){
    if (item->command != TODO_COMMENT){
        FILE* f = fopen(rebase_path_msgnum(), ""w"");
        todo_list->done_nr++;
        if (f){
            fprintf(f, ""%d\n"", todo_list->done_nr);
            fclose(f);
        }
        if (!opts->quiet)
            fprintf(stderr, _(""Rebasing (%d/%d)%s""), todo_list->done_nr, todo_list->total_nr, opts->verbose ? ""\n"" : ""\r"");
    }
    unlink (rebase_path_author_script());
    unlink(git_path_merge_head(r));
    refs_delete_ref(get_main_ref_store(r), """", ""AUTO_MERGE"", NULL, REF_NO_DEREF);
    refs_delete_ref(get_main_ref_store(r), """", ""REBASE_HEAD"", NULL, REF_NO_DEREF);
    if (item->command == TODO_BREAK){
        if (!opts->verbose)
            term_clear_line();

        return stopped_at_head(r);
    }
}
",,
implicit_predicate,sequencer.c,4923,-,+,,7,"						opts->verbose ? ""\n"" : ""\r"");"
implicit_predicate,sequencer.c,4955,+,-,"if (res){
    if (opts->reschedule_failed_exec)
        reschedule = 1;
}
",,
implicit_predicate,sequencer.c,4987,+,-,"if (reschedule){
    advise(_(rescheduled_advice), get_item_line_length(todo_list, todo_list->current), get_item_line(todo_list, todo_list->current));
    if (save_todo(todo_list, opts, reschedule))
        return -1;

    if (item->commit)
        write_rebase_head(&item->commit->object.oid);
}else
    if (is_rebase_i(opts) && check_todo && !res && reread_todo_if_changed(r, todo_list, opts)){
        return -1;
    }
",,
implicit_predicate,sequencer.c,4992,+,-,"if (save_todo(todo_list, opts, reschedule))
    return -1;
",,
implicit_predicate,sequencer.c,5001,+,-,"if (res)
    return res;
",,
implicit_predicate,sequencer.c,5007,+,-,"if (is_rebase_i(opts)){
    struct strbuf head_ref = STRBUF_INIT, buf = STRBUF_INIT;
    struct stat st;
    if (read_oneliner(&head_ref, rebase_path_head_name(), 0) && starts_with(head_ref.buf, ""refs/"")){
        const char* msg;
        struct object_id head, orig;
        int res;
        if (repo_get_oid(r, ""HEAD"", &head)){
            res = error(_(""cannot read HEAD""));
            cleanup_head_ref:
            strbuf_release(&head_ref);
            strbuf_release(&buf);
            return res;
        }
        if (!read_oneliner(&buf, rebase_path_orig_head(), 0) || get_oid_hex(buf.buf, &orig)){
            res = error(_(""could not read orig-head""));
            goto cleanup_head_ref;
        }
        strbuf_reset(&buf);
        if (!read_oneliner(&buf, rebase_path_onto(), 0)){
            res = error(_(""could not read 'onto'""));
            goto cleanup_head_ref;
        }
        msg = reflog_message(opts, ""finish"", ""%s onto %s"", head_ref.buf, buf.buf);
        if (refs_update_ref(get_main_ref_store(the_repository), msg, head_ref.buf, &head, &orig, REF_NO_DEREF, UPDATE_REFS_MSG_ON_ERR)){
            res = error(_(""could not update %s""), head_ref.buf);
            goto cleanup_head_ref;
        }
        msg = reflog_message(opts, ""finish"", ""returning to %s"", head_ref.buf);
        if (refs_update_symref(get_main_ref_store(the_repository), ""HEAD"", head_ref.buf, msg)){
            res = error(_(""could not update HEAD to %s""), head_ref.buf);
            goto cleanup_head_ref;
        }
        strbuf_reset(&buf);
    }
    if (opts->verbose){
        struct rev_info log_tree_opt;
        struct object_id orig, head;
        memset(&log_tree_opt, 0, sizeof (log_tree_opt));
        repo_init_revisions(r, &log_tree_opt, NULL);
        log_tree_opt.diff = 1;
        log_tree_opt.diffopt.output_format = DIFF_FORMAT_DIFFSTAT;
        log_tree_opt.disable_stdin = 1;
        if (read_oneliner(&buf, rebase_path_orig_head(), 0) && !repo_get_oid(r, buf.buf, &orig) && !repo_get_oid(r, ""HEAD"", &head)){
            diff_tree_oid(&orig, &head, """", &log_tree_opt.diffopt);
            log_tree_diff_flush(&log_tree_opt);
        }
        release_revisions(&log_tree_opt);
    }
    flush_rewritten_pending();
    if (!stat(rebase_path_rewritten_list(), &st) && st.st_size > 0){
        struct child_process child = CHILD_PROCESS_INIT;
        struct run_hooks_opt hook_opt = RUN_HOOKS_OPT_INIT;
        child.in = open(rebase_path_rewritten_list(), O_RDONLY);
        child.git_cmd = 1;
        strvec_push(&child.args, ""notes"");
        strvec_push(&child.args, ""copy"");
        strvec_push(&child.args, ""--for-rewrite=rebase"");
        run_command(&child);
        hook_opt.path_to_stdin = rebase_path_rewritten_list();
        strvec_push(&hook_opt.args, ""rebase"");
        run_hooks_opt(""post-rewrite"", &hook_opt);
    }
    apply_autostash (rebase_path_autostash());
    if (!opts->quiet){
        if (!opts->verbose)
            term_clear_line();

        fprintf(stderr, _(""Successfully rebased and updated %s.\n""), head_ref.buf);
    }
    strbuf_release(&buf);
    strbuf_release(&head_ref);
    if (do_update_refs(r, opts->quiet))
        return -1;
}
",,
implicit_predicate,sequencer.c,5244,+,-,"if (parse_head(r, &commit))
    return error(_(""could not parse HEAD""));
",,
implicit_predicate,sequencer.c,5261,+,-,"if (res)
    return res;
",,
implicit_predicate,sequencer.c,5270,+,-,"if (is_clean){
    if (refs_ref_exists(get_main_ref_store(r), ""CHERRY_PICK_HEAD"") && refs_delete_ref(get_main_ref_store(r), """", ""CHERRY_PICK_HEAD"", NULL, REF_NO_DEREF))
        return error(_(""could not remove CHERRY_PICK_HEAD""));

    if (unlink(git_path_merge_msg(r)) && errno != ENOENT)
        return error_errno(_(""could not remove '%s'""), git_path_merge_msg(r));

    if (!final_fixup)
        return 0;
}
",,
implicit_predicate,sequencer.c,5283,+,+,final_fixup ? NULL : rebase_path_message(),21,"	if (run_git_commit(final_fixup ? NULL : rebase_path_message(),"
implicit_predicate,sequencer.c,5290,+,-,"if (final_fixup){
    unlink (rebase_path_fixup_msg());
    unlink (rebase_path_squash_msg());
}
",,
implicit_predicate,sequencer.c,5312,+,-,"if (read_and_refresh_cache(r, opts))
    return -1;
",,
implicit_predicate,sequencer.c,5315,+,-,"if (read_populate_opts(opts))
    return -1;
",,
implicit_predicate,sequencer.c,5317,+,-,"if (is_rebase_i(opts)){
    if ((res = read_populate_todo(r, &todo_list, opts)))
        goto release_todo_list;

    if (file_exists (rebase_path_dropped())){
        if ((res = todo_list_check_against_backup(r, &todo_list)))
            goto release_todo_list;

        unlink(rebase_path_dropped());
    }
    ctx->reflog_message = reflog_message(opts, ""continue"", NULL);
    if (commit_staged_changes(r, opts, &todo_list)){
        res = -1;
        goto release_todo_list;
    }
}else
    if (!file_exists(get_todo_path(opts)))
        return continue_single_pick(r, opts);
    else
        if ((res = read_populate_todo(r, &todo_list, opts)))
            goto release_todo_list;
",,
implicit_predicate,sequencer.c,5318,+,-,"if ((res = read_populate_todo(r, &todo_list, opts)))
    goto release_todo_list;
",,
implicit_predicate,sequencer.c,5329,+,-,"if (commit_staged_changes(r, opts, &todo_list)){
    res = -1;
    goto release_todo_list;
}
",,
implicit_predicate,sequencer.c,5335,+,-,"if ((res = read_populate_todo(r, &todo_list, opts)))
    goto release_todo_list;
",,
implicit_predicate,sequencer.c,5344,+,-,"if (res)
    goto release_todo_list;
",,
implicit_predicate,sequencer.c,5392,+,-,"if (read_and_refresh_cache(r, opts))
    return -1;
",,
implicit_predicate,sequencer.c,5450,+,-,"if (save_opts(opts))
    return -1;
",,
implicit_predicate,sequencer.c,5532,-,+,,9,"	return key ? strcmp(a->label, key) : strcmp(a->label, b->label);"
implicit_predicate,sequencer.c,5624,+,-,"if (*label & 0x80){
    const char* p = label;
    utf8_width(&p, NULL);
    if (p){
        if (buf->len + (p - label) > max_len)
            break;

        strbuf_add(buf, label, p - label);
        label = p - 1;
    }else{
        label_is_utf8 = 0;
        strbuf_addch(buf, *label);
    }
}else
    if (buf->len && buf->buf[buf->len - 1] != '-')
        strbuf_addch(buf, '-');
",,
implicit_predicate,sequencer.c,5704,+,+,"abbr ? ""p"" : ""pick""",25,"	const char *cmd_pick = abbr ? ""p"" : ""pick"","
implicit_predicate,sequencer.c,5705,+,+,"abbr ? ""l"" : ""label""",16,"		*cmd_label = abbr ? ""l"" : ""label"","
implicit_predicate,sequencer.c,5706,+,+,"abbr ? ""t"" : ""reset""",16,"		*cmd_reset = abbr ? ""t"" : ""reset"","
implicit_predicate,sequencer.c,5707,+,+,"abbr ? ""m"" : ""merge""",16,"		*cmd_merge = abbr ? ""m"" : ""merge"";"
implicit_predicate,sequencer.c,5757,-,+,,14,		to_merge = commit->parents ? commit->parents->next : NULL;
implicit_predicate,sequencer.c,5764,+,-,"if (is_empty)
    strbuf_addf(&buf, "" %s empty"", comment_line_str);
",,
implicit_predicate,sequencer.c,5814,+,-,"if (skipped_commit)
    advise_if_enabled(ADVICE_SKIPPED_CHERRY_PICKS, _(""use --reapply-cherry-picks to include skipped commits""));
",,
implicit_predicate,sequencer.c,5934,-,+,,21,"	const char *insn = flags & TODO_LIST_ABBREVIATE_CMDS ? ""p"" : ""pick"";"
implicit_predicate,sequencer.c,5972,+,-,"if (rebase_merges){
    ret = make_script_with_merges(&pp, &revs, out, flags);
    goto cleanup;
}
",,
implicit_predicate,sequencer.c,5992,+,-,"if (is_empty)
    strbuf_addf(out, "" %s empty"", comment_line_str);
",,
implicit_predicate,sequencer.c,5996,+,-,"if (skipped_commit)
    advise_if_enabled(ADVICE_SKIPPED_CHERRY_PICKS, _(""use --reapply-cherry-picks to include skipped commits""));
",,
implicit_predicate,sequencer.c,6062,+,-,"if (insert){
    ALLOC_GROW(items, nr + commands->nr, alloc);
    COPY_ARRAY(items + nr, base_items, commands->nr);
    nr += commands->nr;
}
",,
implicit_predicate,sequencer.c,6104,-,+,,22,"			const char *oid = flags & TODO_LIST_SHORTEN_IDS ?
					  short_commit_name(r, item->commit) :
					  oid_to_hex(&item->commit->object.oid);"
implicit_predicate,sequencer.c,6312,+,-,"if (res){
    free(ctx.items);
    return res;
}
",,
implicit_predicate,sequencer.c,6411,+,-,"if (checkout_onto(r, opts, onto_name, &oid, orig_head))
    goto cleanup;
",,
implicit_predicate,sequencer.c,6442,-,+,,9,"	return key ? strcmp(a->subject, key) : strcmp(a->subject, b->subject);"
implicit_predicate,sequencer.c,6512,+,-,<!!!>,,
implicit_predicate,sequencer.c,6576,+,-,"if (rearranged){
    ALLOC_ARRAY(items, todo_list->nr);
    for (i = 0;i < todo_list->nr;i++){
        enum todo_command command = todo_list->items[i].command;
        int cur = i;
        if (is_fixup(command))
            continue;

        while (cur >= 0){
            items[nr++] = todo_list->items[cur];
            cur = next[cur];
        }
    }
    assert(nr == todo_list->nr);
    todo_list->alloc = nr;
    FREE_AND_NULL(todo_list->items);
    todo_list->items = items;
}
",,
implicit_predicate,serve.c,172,+,-,"if (c->advertise(the_repository, &value)){
    strbuf_addstr(&capability, c->name);
    if (value.len){
        strbuf_addch(&capability, '=');
        strbuf_addbuf(&capability, &value);
    }
    strbuf_addch(&capability, '\n');
    packet_write(1, capability.buf, capability.len);
}
",,
implicit_predicate,serve.c,342,+,-,"if (stateless_rpc){
    process_request();
}else{
    for (;;)
        if (process_request())
            break;
}
",,
implicit_predicate,serve.c,346,+,-,"if (process_request())
    break;
",,
implicit_predicate,server-info.c,43,+,-,"if (uic_is_stale(uic)){
    ret = vfprintf(uic->cur_fp, fmt, ap);
}else{
    ssize_t r;
    struct strbuf* cur = &uic->cur_sb;
    struct strbuf* old = &uic->old_sb;
    strbuf_reset(cur);
    strbuf_vinsertf(cur, 0, fmt, ap);
    strbuf_reset(old);
    strbuf_grow(old, cur->len);
    r = fread(old->buf, 1, cur->len, uic->old_fp);
    if (r != cur->len || memcmp(old->buf, cur->buf, r))
        uic_mark_stale(uic);

    if (fwrite(cur->buf, 1, cur->len, uic->cur_fp) == cur->len)
        ret = 0;
}
",,
implicit_predicate,server-info.c,106,+,-,"if (ret)
    goto out;
",,
implicit_predicate,server-info.c,127,+,-,"if (uic_is_stale(&uic)){
    if (adjust_shared_perm(tmp) < 0)
        goto out;

    if (rename(tmp, path) < 0)
        goto out;
}else{
    unlink(tmp);
}
",,
implicit_predicate,server-info.c,138,+,-,"if (ret){
    error_errno(""unable to update %s"", path);
    if (uic.cur_fp)
        fclose(uic.cur_fp);
    else
        if (fd >= 0)
            close(fd);

    unlink(tmp);
}
",,
implicit_predicate,server-info.c,247,+,-,"if (parse_pack_def(arg, old_cnt++))
    goto out_stale;
",,
implicit_predicate,server-info.c,318,+,-,"if (stale)
    info[i]->old_num = -1;
",,
implicit_predicate,setup.c,77,+,-,"while (*path){
    path++;
    if (*path == '/'){
        *path = '\0';
        strbuf_realpath(&realpath, path0, 1);
        if (fspathcmp(realpath.buf, work_tree) == 0){
            memmove(path0, path + 1, len - (path - path0));
            strbuf_release(&realpath);
            return 0;
        }
        *path = '/';
    }
}
",,
implicit_predicate,setup.c,78,+,-,"while (*path){
    path++;
    if (*path == '/'){
        *path = '\0';
        strbuf_realpath(&realpath, path0, 1);
        if (fspathcmp(realpath.buf, work_tree) == 0){
            memmove(path0, path + 1, len - (path - path0));
            strbuf_release(&realpath);
            return 0;
        }
        *path = '/';
    }
}
",,
implicit_predicate,setup.c,127,+,-,"if (abspath_part_inside_repo(sanitized)){
    free(sanitized);
    return NULL;
}
",,
implicit_predicate,setup.c,128,+,-,"if (abspath_part_inside_repo(sanitized)){
    free(sanitized);
    return NULL;
}
",,
implicit_predicate,setup.c,132,+,+,"len ? prefix : """"",38,"		sanitized = xstrfmt(""%.*s%s"", len, len ? prefix : """", path);"
implicit_predicate,setup.c,133,+,-,"len ? prefix : """"",,
implicit_predicate,setup.c,158,-,+,,12,	int len = prefix ? strlen(prefix) : 0;
implicit_predicate,setup.c,239,+,-,"if (escaped){
    escaped = 0;
}else
    if (is_glob_special(*p)){
        if (*p == '\\')
            escaped = 1;
        else
            return 1;
    }
",,
implicit_predicate,setup.c,240,+,-,"if (escaped){
    escaped = 0;
}else
    if (is_glob_special(*p)){
        if (*p == '\\')
            escaped = 1;
        else
            return 1;
    }
",,
implicit_predicate,setup.c,432,+,-,"if (initialized)
    return;
",,
implicit_predicate,setup.c,435,+,-,"if (work_tree_config_is_bogus)
    die(_(""unable to set up work tree using invalid config""));
",,
implicit_predicate,setup.c,485,+,-,"if (initialized)
    return;
",,
implicit_predicate,setup.c,488,+,-,"if (work_tree_config_is_bogus)
    die(_(""unable to set up work tree using invalid config""));
",,
implicit_predicate,setup.c,929,+,-,"if (error_code)
    read_gitfile_error_die(error_code, path, dir);
",,
implicit_predicate,setup.c,933,+,+,error_code ? NULL : path,9,	return error_code ? NULL : path;
implicit_predicate,setup.c,964,+,-,"if (check_repository_format_gently(gitdirenv, repo_fmt, nongit_ok)){
    free(gitfile);
    return NULL;
}
",,
implicit_predicate,setup.c,982,+,-,"if (error_code)
    read_gitfile_error_die(error_code, path, dir);
",,
implicit_predicate,setup.c,986,+,-,error_code ? NULL : path,,
implicit_predicate,setup.c,1017,+,-,"if (check_repository_format_gently(gitdirenv, repo_fmt, nongit_ok)){
    free(gitfile);
    return NULL;
}
",,
implicit_predicate,setup.c,1040,+,-,"if (check_repository_format_gently(gitdir, repo_fmt, nongit_ok))
    return NULL;
",,
implicit_predicate,setup.c,1089,+,-,"if (check_repository_format_gently(""."", repo_fmt, nongit_ok))
    return NULL;
",,
implicit_predicate,setup.c,1093,+,-,"if (check_repository_format_gently(gitdir, repo_fmt, nongit_ok))
    return NULL;
",,
implicit_predicate,setup.c,1124,-,+,,5,"				prefix ? prefix : """","
implicit_predicate,setup.c,1125,-,+,,5,"				prefix ? ""/"" : """", path);"
implicit_predicate,setup.c,1142,+,-,"if (check_repository_format_gently(""."", repo_fmt, nongit_ok))
    return NULL;
",,
implicit_predicate,setup.c,1148,+,-,"if (*empty_entry_found){
    return 1;
}else{
    char* real_path = real_pathdup(ceil, 0);
    if (!real_path){
        return 0;
    }
    free(item->string);
    item->string = real_path;
    return 1;
}
",,
implicit_predicate,setup.c,1183,-,+,,30,"		    !fspathcmp(data->path, interpolated ? interpolated : value))"
implicit_predicate,setup.c,1201,+,-,"if (*empty_entry_found){
    return 1;
}else{
    char* real_path = real_pathdup(ceil, 0);
    if (!real_path){
        return 0;
    }
    free(item->string);
    item->string = real_path;
    return 1;
}
",,
implicit_predicate,setup.c,1205,-,+,,11,		.path = worktree ? worktree : gitdir
implicit_predicate,setup.c,1230,+,-,"if (ensure_valid_ownership(gitfile, worktree, gitdir, &report))
    return;
",,
implicit_predicate,setup.c,1234,-,+,,9,	path = gitfile ? gitfile : gitdir;
implicit_predicate,setup.c,1283,+,-,"if (ensure_valid_ownership(gitfile, worktree, gitdir, &report))
    return;
",,
implicit_predicate,setup.c,1380,+,-,"if (one_filesystem)
    current_device = get_device_or_die(dir->buf, NULL, 0);
",,
implicit_predicate,setup.c,1390,+,+,die_on_error ? NULL : &error_code,45,"		gitdirenv = read_gitfile_gently(dir->buf, die_on_error ?
						NULL : &error_code);"
implicit_predicate,setup.c,1414,-,+,,5,				gitdir_path ? gitdir_path : gitdirenv;
implicit_predicate,setup.c,1433,+,-,"if (one_filesystem)
    current_device = get_device_or_die(dir->buf, NULL, 0);
",,
implicit_predicate,setup.c,1443,+,-,die_on_error ? NULL : &error_code,,
implicit_predicate,setup.c,1707,-,+,,10,"		return git_config_bool(var, value) ? PERM_GROUP : PERM_UMASK;"
implicit_predicate,setup.c,1767,+,-,"if (is_git_directory(suspect))
    return suspect;
",,
implicit_predicate,setup.c,1820,+,-,"if (is_git_directory(suspect))
    return suspect;
",,
implicit_predicate,setup.c,1826,-,+,,17,			data->path = path ? path : xstrdup(value);
implicit_predicate,setup.c,1910,+,-,"if (exists)
    continue;
else
    if (S_ISLNK(st_template.st_mode)){
        struct strbuf lnk = STRBUF_INIT;
        if (strbuf_readlink(&lnk, template_path->buf, st_template.st_size) < 0)
            die_errno(_(""cannot readlink '%s'""), template_path->buf);

        if (symlink(lnk.buf, path->buf))
            die_errno(_(""cannot symlink '%s' '%s'""), lnk.buf, path->buf);

        strbuf_release(&lnk);
    }else
        if (S_ISREG(st_template.st_mode)){
            if (copy_file(path->buf, template_path->buf, st_template.st_mode))
                die_errno(_(""cannot copy '%s' to '%s'""), template_path->buf, path->buf);
        }else
            error(_(""ignoring template %s""), template_path->buf);
",,
implicit_predicate,setup.c,1963,+,-,"if (exists)
    continue;
else
    if (S_ISLNK(st_template.st_mode)){
        struct strbuf lnk = STRBUF_INIT;
        if (strbuf_readlink(&lnk, template_path->buf, st_template.st_size) < 0)
            die_errno(_(""cannot readlink '%s'""), template_path->buf);

        if (symlink(lnk.buf, path->buf))
            die_errno(_(""cannot symlink '%s' '%s'""), lnk.buf, path->buf);

        strbuf_release(&lnk);
    }else
        if (S_ISREG(st_template.st_mode)){
            if (copy_file(path->buf, template_path->buf, st_template.st_mode))
                die_errno(_(""cannot copy '%s' to '%s'""), template_path->buf, path->buf);
        }else
            error(_(""ignoring template %s""), template_path->buf);
",,
implicit_predicate,setup.c,2025,+,-,"if (reinit)
    git_config_set_gently(""extensions.objectformat"", NULL);
",,
implicit_predicate,setup.c,2078,+,-,"if (reinit)
    git_config_set_gently(""extensions.objectformat"", NULL);
",,
implicit_predicate,setup.c,2141,+,+,"filemode ? ""true"" : ""false""",34,"	git_config_set(""core.filemode"", filemode ? ""true"" : ""false"");"
implicit_predicate,setup.c,2150,+,-,"if (needs_work_tree_config(original_git_dir, work_tree))
    git_config_set(""core.worktree"", work_tree);
",,
implicit_predicate,setup.c,2197,+,-,"filemode ? ""true"" : ""false""",,
implicit_predicate,setup.c,2206,+,-,"if (needs_work_tree_config(original_git_dir, work_tree))
    git_config_set(""core.worktree"", work_tree);
",,
implicit_predicate,setup.c,2344,+,-,"if (reinit)
    printf(get_shared_repository() ? _(""Reinitialized existing shared Git repository in %s%s\n"") : _(""Reinitialized existing Git repository in %s%s\n""), git_dir, len && git_dir[len - 1] != '/' ? ""/"" : """");
else
    printf(get_shared_repository() ? _(""Initialized empty shared Git repository in %s%s\n"") : _(""Initialized empty Git repository in %s%s\n""), git_dir, len && git_dir[len - 1] != '/' ? ""/"" : """");
",,
implicit_predicate,setup.c,2345,-,+,,11,"			printf(get_shared_repository()
			       ? _(""Reinitialized existing shared Git repository in %s%s\n"")
			       : _(""Reinitialized existing Git repository in %s%s\n""),"
implicit_predicate,setup.c,2350,-,+,,11,"			printf(get_shared_repository()
			       ? _(""Initialized empty shared Git repository in %s%s\n"")
			       : _(""Initialized empty Git repository in %s%s\n""),"
implicit_predicate,setup.c,2403,+,-,"if (reinit)
    printf(get_shared_repository() ? _(""Reinitialized existing shared Git repository in %s%s\n"") : _(""Reinitialized existing Git repository in %s%s\n""), git_dir, len && git_dir[len - 1] != '/' ? ""/"" : """");
else
    printf(get_shared_repository() ? _(""Initialized empty shared Git repository in %s%s\n"") : _(""Initialized empty Git repository in %s%s\n""), git_dir, len && git_dir[len - 1] != '/' ? ""/"" : """");
",,
implicit_predicate,sh-i18n--envsubst.c,162,+,-,"if (valid)
    callback(variable_start, variable_end - variable_start);
",,
implicit_predicate,sh-i18n--envsubst.c,360,+,-,"if (opening_brace){
    if (c == '}'){
        closing_brace = 1;
        valid = 1;
    }else{
        valid = 0;
        do_ungetc(c);
    }
}else{
    valid = 1;
    do_ungetc(c);
}
",,
implicit_predicate,sh-i18n--envsubst.c,379,+,-,"if (valid){
    if (buflen >= bufmax){
        bufmax = 2 * bufmax + 10;
        buffer = xrealloc(buffer, bufmax);
    }
    buffer[buflen] = '\0';
    if (!all_variables && !sorted_string_list_member(&variables_set, buffer))
        valid = 0;
}
",,
implicit_predicate,sh-i18n--envsubst.c,395,+,-,"if (valid){
    const char* env_value = getenv(buffer);
    if (env_value)
        fputs(env_value, stdout);
}else{
    putchar('$');
    if (opening_brace)
        putchar('{');

    fwrite(buffer, buflen, 1, stdout);
    if (closing_brace)
        putchar('}');
}
",,
implicit_predicate,sh-i18n--envsubst.c,409,+,-,"if (opening_brace)
    putchar('{');
",,
implicit_predicate,sh-i18n--envsubst.c,412,+,-,"if (closing_brace)
    putchar('}');
",,
implicit_predicate,sh-i18n--envsubst.c,420,+,-,"if (opening_brace)
    putchar('{');
",,
implicit_predicate,sha1.c,77,+,-,"T_0_15( 0, A, B, C, D, E);
",,
implicit_predicate,sha1.c,78,+,-,"T_0_15( 1, E, A, B, C, D);
",,
implicit_predicate,sha1.c,79,+,-,"T_0_15( 2, D, E, A, B, C);
",,
implicit_predicate,sha1.c,80,+,-,"T_0_15( 3, C, D, E, A, B);
",,
implicit_predicate,sha1.c,81,+,-,"T_0_15( 4, B, C, D, E, A);
",,
implicit_predicate,sha1.c,82,+,-,"T_0_15( 5, A, B, C, D, E);
",,
implicit_predicate,sha1.c,83,+,-,"T_0_15( 6, E, A, B, C, D);
",,
implicit_predicate,sha1.c,84,+,-,"T_0_15( 7, D, E, A, B, C);
",,
implicit_predicate,sha1.c,85,+,-,"T_0_15( 8, C, D, E, A, B);
",,
implicit_predicate,sha1.c,86,+,-,"T_0_15( 9, B, C, D, E, A);
",,
implicit_predicate,sha1.c,87,+,-,"T_0_15(10, A, B, C, D, E);
",,
implicit_predicate,sha1.c,88,+,-,"T_0_15(11, E, A, B, C, D);
",,
implicit_predicate,sha1.c,89,+,-,"T_0_15(12, D, E, A, B, C);
",,
implicit_predicate,sha1.c,90,+,-,"T_0_15(13, C, D, E, A, B);
",,
implicit_predicate,sha1.c,91,+,-,"T_0_15(14, B, C, D, E, A);
",,
implicit_predicate,sha1.c,92,+,-,"T_0_15(15, A, B, C, D, E);
",,
implicit_predicate,sha1.c,95,+,-,"T_16_19(16, E, A, B, C, D);
",,
implicit_predicate,sha1.c,96,+,-,"T_16_19(17, D, E, A, B, C);
",,
implicit_predicate,sha1.c,97,+,-,"T_16_19(18, C, D, E, A, B);
",,
implicit_predicate,sha1.c,98,+,-,"T_16_19(19, B, C, D, E, A);
",,
implicit_predicate,sha1.c,101,+,-,"T_20_39(20, A, B, C, D, E);
",,
implicit_predicate,sha1.c,102,+,-,"T_20_39(21, E, A, B, C, D);
",,
implicit_predicate,sha1.c,103,+,-,"T_20_39(22, D, E, A, B, C);
",,
implicit_predicate,sha1.c,104,+,-,"T_20_39(23, C, D, E, A, B);
",,
implicit_predicate,sha1.c,105,+,-,"T_20_39(24, B, C, D, E, A);
",,
implicit_predicate,sha1.c,106,+,-,"T_20_39(25, A, B, C, D, E);
",,
implicit_predicate,sha1.c,107,+,-,"T_20_39(26, E, A, B, C, D);
",,
implicit_predicate,sha1.c,108,+,-,"T_20_39(27, D, E, A, B, C);
",,
implicit_predicate,sha1.c,109,+,-,"T_20_39(28, C, D, E, A, B);
",,
implicit_predicate,sha1.c,110,+,-,"T_20_39(29, B, C, D, E, A);
",,
implicit_predicate,sha1.c,111,+,-,"T_20_39(30, A, B, C, D, E);
",,
implicit_predicate,sha1.c,112,+,-,"T_20_39(31, E, A, B, C, D);
",,
implicit_predicate,sha1.c,113,+,-,"T_20_39(32, D, E, A, B, C);
",,
implicit_predicate,sha1.c,114,+,-,"T_20_39(33, C, D, E, A, B);
",,
implicit_predicate,sha1.c,115,+,-,"T_20_39(34, B, C, D, E, A);
",,
implicit_predicate,sha1.c,116,+,-,"T_20_39(35, A, B, C, D, E);
",,
implicit_predicate,sha1.c,117,+,-,"T_20_39(36, E, A, B, C, D);
",,
implicit_predicate,sha1.c,118,+,-,"T_20_39(37, D, E, A, B, C);
",,
implicit_predicate,sha1.c,119,+,-,"T_20_39(38, C, D, E, A, B);
",,
implicit_predicate,sha1.c,120,+,-,"T_20_39(39, B, C, D, E, A);
",,
implicit_predicate,sha1.c,123,+,-,"T_40_59(40, A, B, C, D, E);
",,
implicit_predicate,sha1.c,124,+,-,"T_40_59(41, E, A, B, C, D);
",,
implicit_predicate,sha1.c,125,+,-,"T_40_59(42, D, E, A, B, C);
",,
implicit_predicate,sha1.c,126,+,-,"T_40_59(43, C, D, E, A, B);
",,
implicit_predicate,sha1.c,127,+,-,"T_40_59(44, B, C, D, E, A);
",,
implicit_predicate,sha1.c,128,+,-,"T_40_59(45, A, B, C, D, E);
",,
implicit_predicate,sha1.c,129,+,-,"T_40_59(46, E, A, B, C, D);
",,
implicit_predicate,sha1.c,130,+,-,"T_40_59(47, D, E, A, B, C);
",,
implicit_predicate,sha1.c,131,+,-,"T_40_59(48, C, D, E, A, B);
",,
implicit_predicate,sha1.c,132,+,-,"T_40_59(49, B, C, D, E, A);
",,
implicit_predicate,sha1.c,133,+,-,"T_40_59(50, A, B, C, D, E);
",,
implicit_predicate,sha1.c,134,+,-,"T_40_59(51, E, A, B, C, D);
",,
implicit_predicate,sha1.c,135,+,-,"T_40_59(52, D, E, A, B, C);
",,
implicit_predicate,sha1.c,136,+,-,"T_40_59(53, C, D, E, A, B);
",,
implicit_predicate,sha1.c,137,+,-,"T_40_59(54, B, C, D, E, A);
",,
implicit_predicate,sha1.c,138,+,-,"T_40_59(55, A, B, C, D, E);
",,
implicit_predicate,sha1.c,139,+,-,"T_40_59(56, E, A, B, C, D);
",,
implicit_predicate,sha1.c,140,+,-,"T_40_59(57, D, E, A, B, C);
",,
implicit_predicate,sha1.c,141,+,-,"T_40_59(58, C, D, E, A, B);
",,
implicit_predicate,sha1.c,142,+,-,"T_40_59(59, B, C, D, E, A);
",,
implicit_predicate,sha1.c,145,+,-,"T_60_79(60, A, B, C, D, E);
",,
implicit_predicate,sha1.c,146,+,-,"T_60_79(61, E, A, B, C, D);
",,
implicit_predicate,sha1.c,147,+,-,"T_60_79(62, D, E, A, B, C);
",,
implicit_predicate,sha1.c,148,+,-,"T_60_79(63, C, D, E, A, B);
",,
implicit_predicate,sha1.c,149,+,-,"T_60_79(64, B, C, D, E, A);
",,
implicit_predicate,sha1.c,150,+,-,"T_60_79(65, A, B, C, D, E);
",,
implicit_predicate,sha1.c,151,+,-,"T_60_79(66, E, A, B, C, D);
",,
implicit_predicate,sha1.c,152,+,-,"T_60_79(67, D, E, A, B, C);
",,
implicit_predicate,sha1.c,153,+,-,"T_60_79(68, C, D, E, A, B);
",,
implicit_predicate,sha1.c,154,+,-,"T_60_79(69, B, C, D, E, A);
",,
implicit_predicate,sha1.c,155,+,-,"T_60_79(70, A, B, C, D, E);
",,
implicit_predicate,sha1.c,156,+,-,"T_60_79(71, E, A, B, C, D);
",,
implicit_predicate,sha1.c,157,+,-,"T_60_79(72, D, E, A, B, C);
",,
implicit_predicate,sha1.c,158,+,-,"T_60_79(73, C, D, E, A, B);
",,
implicit_predicate,sha1.c,159,+,-,"T_60_79(74, B, C, D, E, A);
",,
implicit_predicate,sha1.c,160,+,-,"T_60_79(75, A, B, C, D, E);
",,
implicit_predicate,sha1.c,161,+,-,"T_60_79(76, E, A, B, C, D);
",,
implicit_predicate,sha1.c,162,+,-,"T_60_79(77, D, E, A, B, C);
",,
implicit_predicate,sha1.c,163,+,-,"T_60_79(78, C, D, E, A, B);
",,
implicit_predicate,sha1.c,164,+,-,"T_60_79(79, B, C, D, E, A);
",,
implicit_predicate,sha1.c,192,+,-,"if (lenW){
    unsigned int left = 64 - lenW;
    if (len < left)
        left = len;

    memcpy(lenW + (char*)ctx->W, data, left);
    lenW = (lenW + left) & 63;
    len -= left;
    data = ((const char*)data + left);
    if (lenW)
        return;

    blk_SHA1_Block(ctx, ctx->W);
}
",,
implicit_predicate,sha1.c,200,+,-,"if (lenW)
    return;
",,
implicit_predicate,sha1.c,1785,+,-,"if (safehash)
    ctx->safe_hash = 1;
else
    ctx->safe_hash = 0;
",,
implicit_predicate,sha1.c,1794,+,-,"if (ubc_check)
    ctx->ubc_check = 1;
else
    ctx->ubc_check = 0;
",,
implicit_predicate,sha1.c,1802,+,-,"if (detect_coll)
    ctx->detect_coll = 1;
else
    ctx->detect_coll = 0;
",,
implicit_predicate,sha1.c,1810,+,-,"if (reduced_round_coll)
    ctx->reduced_round_coll = 1;
else
    ctx->reduced_round_coll = 0;
",,
implicit_predicate,sha256.c,158,+,-,"if (len_buf){
    unsigned int left = 64 - len_buf;
    if (len < left)
        left = len;

    memcpy(len_buf + ctx->buf, data, left);
    len_buf = (len_buf + left) & 63;
    len -= left;
    data = ((const char*)data + left);
    if (len_buf)
        return;

    blk_SHA256_Transform(ctx, ctx->buf);
}
",,
implicit_predicate,sha256.c,166,+,-,"if (len_buf)
    return;
",,
implicit_predicate,shallow.c,308,+,-,"if (data->flags & QUICK){
    if (!repo_has_object_file(the_repository, &graft->oid))
        return 0;
}else
    if (data->flags & SEEN_ONLY){
        struct commit* c = lookup_commit(the_repository, &graft->oid);
        if (!c || !(c->object.flags & SEEN)){
            if (data->flags & VERBOSE)
                printf(""Removing %s from .git/shallow\n"", oid_to_hex(&c->object.oid));

            return 0;
        }
    }
",,
implicit_predicate,shallow.c,311,+,-,"if (data->flags & SEEN_ONLY){
    struct commit* c = lookup_commit(the_repository, &graft->oid);
    if (!c || !(c->object.flags & SEEN)){
        if (data->flags & VERBOSE)
            printf(""Removing %s from .git/shallow\n"", oid_to_hex(&c->object.oid));

        return 0;
    }
}
",,
implicit_predicate,shallow.c,314,+,-,"if (data->flags & VERBOSE)
    printf(""Removing %s from .git/shallow\n"", oid_to_hex(&c->object.oid));
",,
implicit_predicate,shallow.c,321,+,-,"if (data->use_pack_protocol)
    packet_buf_write(data->out, ""shallow %s"", hex);
else{
    strbuf_addstr(data->out, hex);
    strbuf_addch(data->out, '\n');
}
",,
implicit_predicate,shallow.c,362,+,-,"if (write_shallow_commits(&sb, 0, extra)){
    temp = xmks_tempfile(git_path(""shallow_XXXXXX""));
    if (write_in_full(temp->fd, sb.buf, sb.len) < 0 || close_tempfile_gently(temp) < 0)
        die_errno(""failed to write to %s"", get_tempfile_path(temp));

    strbuf_release(&sb);
    return get_tempfile_path(temp);
}
",,
implicit_predicate,shallow.c,390,+,-,"if (write_shallow_commits(&sb, 0, extra)){
    if (write_in_full(fd, sb.buf, sb.len) < 0)
        die_errno(""failed to write to %s"", get_lock_file_path(&shallow_lock->lock));

    *alternate_shallow_file = get_lock_file_path(&shallow_lock->lock);
}else
    *alternate_shallow_file = """";
",,
implicit_predicate,shell.c,129,+,-,"if (is_valid_cmd_name(prog)){
    struct child_process cmd = CHILD_PROCESS_INIT;
    full_cmd = make_cmd(prog);
    argv[0] = full_cmd;
    cmd.silent_exec_failure = 1;
    strvec_pushv(&cmd.args, argv);
    code = run_command(&cmd);
    if (code == -1 && errno == ENOENT){
        fprintf(stderr, ""unrecognized command '%s'\n"", prog);
    }
    free(full_cmd);
}else{
    fprintf(stderr, ""invalid command format '%s'\n"", prog);
}
",,
implicit_predicate,shell.c,218,+,-,"if (is_valid_cmd_name(user_argv[0])){
    prog = make_cmd(user_argv[0]);
    user_argv[0] = prog;
    execv(user_argv[0], (char*const *)user_argv);
}
",,
implicit_predicate,shortlog.c,258,-,+,,16,"	oneline_str = oneline.len ? oneline.buf : ""<none>"";"
implicit_predicate,shortlog.c,289,+,+,*endp ? endp + 1 : endp,9,	*arg = *endp ? endp + 1 : endp;
implicit_predicate,shortlog.c,303,+,-,"if (unset)
    return 0;
",,
implicit_predicate,shortlog.c,329,+,-,"if (unset){
    log->groups = 0;
    string_list_clear(&log->trailers, 0);
    string_list_clear(&log->format, 0);
}else
    if (!strcasecmp(arg, ""author""))
        log->groups |= SHORTLOG_GROUP_AUTHOR;
    else
        if (!strcasecmp(arg, ""committer""))
            log->groups |= SHORTLOG_GROUP_COMMITTER;
        else
            if (skip_prefix(arg, ""trailer:"", &field)){
                log->groups |= SHORTLOG_GROUP_TRAILER;
                string_list_append(&log->trailers, field);
            }else
                if (skip_prefix(arg, ""format:"", &field)){
                    log->groups |= SHORTLOG_GROUP_FORMAT;
                    string_list_append(&log->format, field);
                }else
                    if (strchr(arg, '%')){
                        log->groups |= SHORTLOG_GROUP_FORMAT;
                        string_list_append(&log->format, arg);
                    }else{
                        return error(_(""unknown group type: %s""), arg);
                    }
",,
implicit_predicate,shortlog.c,373,-,+,,8,"				   log->email ? ""%aN <%aE>"" : ""%aN"");"
implicit_predicate,shortlog.c,376,-,+,,8,"				   log->email ? ""%cN <%cE>"" : ""%cN"");"
implicit_predicate,show-branch.c,162,+,-,"do{
    i = 0;
    for (cl = list;cl;cl = cl->next){
        i += name_first_parent_chain(cl->item);
    }
} while (i);
",,
implicit_predicate,show-branch.c,170,+,-,"do{
    i = 0;
    for (cl = list;cl;cl = cl->next){
        struct commit_list* parents;
        struct commit_name* n;
        int nth;
        c = cl->item;
        if (!commit_to_name(c))
            continue;

        n = commit_to_name(c);
        parents = c->parents;
        nth = 0;
        while (parents){
            struct commit* p = parents->item;
            struct strbuf newname = STRBUF_INIT;
            parents = parents->next;
            nth++;
            if (commit_to_name(p))
                continue;

            switch (n->generation){
                case 0:
                    strbuf_addstr(&newname, n->head_name);
                    break;
                case 1:
                    strbuf_addf(&newname, ""%s^"", n->head_name);
                    break;
                default:
                    strbuf_addf(&newname, ""%s~%d"", n->head_name, n->generation);
                    break;
            }
            if (nth == 1)
                strbuf_addch(&newname, '^');
            else
                strbuf_addf(&newname, ""^%d"", nth);

            name_commit(p, strbuf_detach(&newname, NULL), 0);
            i++;
            name_first_parent_chain(p);
        }
    }
} while (i);
",,
implicit_predicate,show-branch.c,311,+,-,"if (name->generation){
    if (name->generation == 1)
        printf(""^"");
    else
        printf(""~%d"", name->generation);
}
",,
implicit_predicate,show-branch.c,348,+,-,"while (1){
    int va, vb;
    a = find_digit_prefix(a, &va);
    b = find_digit_prefix(b, &vb);
    if (va != vb)
        return va - vb;

    while (1){
        int ca = *a;
        int cb = *b;
        if ('0' <= ca && ca <= '9')
            ca = 0;

        if ('0' <= cb && cb <= '9')
            cb = 0;

        if (ca != cb)
            return ca - cb;

        if (!ca)
            break;

        a++;
        b++;
    }
    if (!*a && !*b)
        return 0;
}
",,
implicit_predicate,show-branch.c,356,+,-,"while (1){
    int ca = *a;
    int cb = *b;
    if ('0' <= ca && ca <= '9')
        ca = 0;

    if ('0' <= cb && cb <= '9')
        cb = 0;

    if (ca != cb)
        return ca - cb;

    if (!ca)
        break;

    a++;
    b++;
}
",,
implicit_predicate,show-branch.c,479,+,-,"if (head){
    int orig_cnt = ref_name_cnt;
    refs_for_each_ref(get_main_ref_store(the_repository), append_head_ref, NULL);
    sort_ref_range(orig_cnt, ref_name_cnt);
}
",,
implicit_predicate,show-branch.c,486,+,-,"if (remotes){
    int orig_cnt = ref_name_cnt;
    refs_for_each_ref(get_main_ref_store(the_repository), append_remote_ref, NULL);
    sort_ref_range(orig_cnt, ref_name_cnt);
}
",,
implicit_predicate,show-branch.c,605,+,-,"if (flag & (1u << (i + REV_SHIFT)))
    count++;
",,
implicit_predicate,show-branch.c,626,+,-,"if (*ep)
    return error(""unrecognized reflog param '%s'"", arg);
else
    *base = NULL;
",,
implicit_predicate,show-branch.c,708,+,-,"if (all_heads)
    all_remotes = 1;
",,
implicit_predicate,show-branch.c,737,+,-,"if (reflog){
    struct object_id oid;
    char* ref;
    int base = 0;
    unsigned int flags = 0;
    if (ac == 0){
        static const char* fake_av[2];
        fake_av[0] = refs_resolve_refdup(get_main_ref_store(the_repository), ""HEAD"", RESOLVE_REF_READING, &oid, NULL);
        fake_av[1] = NULL;
        av = fake_av;
        ac = 1;
        if (!*av)
            die(_(""no branches given, and HEAD is not valid""));
    }
    if (ac != 1)
        die(_(""--reflog option needs one branch name""));

    if (MAX_REVS < reflog)
        die(Q_(""only %d entry can be shown at one time."", ""only %d entries can be shown at one time."", MAX_REVS), MAX_REVS);

    if (!repo_dwim_ref(the_repository, *av, strlen(*av), &oid, &ref, 0))
        die(_(""no such ref %s""), *av);

    if (reflog_base){
        char* ep;
        base = strtoul(reflog_base, &ep, 10);
        if (*ep){
            timestamp_t at;
            at = approxidate(reflog_base);
            read_ref_at(get_main_ref_store(the_repository), ref, flags, at, -1, &oid, NULL, NULL, NULL, &base);
        }
    }
    for (i = 0;i < reflog;i++){
        char* logmsg;
        char* nth_desc;
        const char* msg;
        char* end;
        timestamp_t timestamp;
        int tz;
        if (read_ref_at(get_main_ref_store(the_repository), ref, flags, 0, base + i, &oid, &logmsg, &timestamp, &tz, NULL)){
            reflog = i;
            break;
        }
        end = strchr(logmsg, '\n');
        if (end)
            *end = '\0';

        msg = (*logmsg == '\0') ? ""(none)"" : logmsg;
        reflog_msg[i] = xstrfmt(""(%s) %s"", show_date(timestamp, tz, DATE_MODE(RELATIVE)), msg);
        free(logmsg);
        nth_desc = xstrfmt(""%s@{%d}"", *av, base + i);
        append_ref(nth_desc, &oid, 1);
        free(nth_desc);
    }
    free(ref);
}else{
    while (0 < ac){
        append_one_rev(*av);
        ac--;
        av++;
    }
    if (all_heads + all_remotes)
        snarf_refs(all_heads, all_remotes);
}
",,
implicit_predicate,show-branch.c,772,+,-,"if (*ep){
    timestamp_t at;
    at = approxidate(reflog_base);
    read_ref_at(get_main_ref_store(the_repository), ref, flags, at, -1, &oid, NULL, NULL, NULL, &base);
}
",,
implicit_predicate,show-branch.c,819,+,-,"if (all_heads + all_remotes)
    snarf_refs(all_heads, all_remotes);
",,
implicit_predicate,show-branch.c,833,+,-,"if (rev_is_head(head, ref_name[i]))
    has_head++;
",,
implicit_predicate,show-branch.c,882,+,-,"if (merge_base)
    return show_merge_base(seen, num_rev);
",,
implicit_predicate,show-branch.c,885,+,-,"if (independent)
    return show_independent(rev, num_rev, rev_mask);
",,
implicit_predicate,show-branch.c,896,+,+,is_head ? '*' : ' ',12,"				       is_head ? '*' : ' ', ref_name[i]);"
implicit_predicate,show-branch.c,902,+,+,is_head ? '*' : '!',12,"				       is_head ? '*' : '!',"
implicit_predicate,show-branch.c,913,+,-,"if (is_head)
    head_at = i;
",,
implicit_predicate,show-branch.c,956,+,-,"if (is_merge)
    mark = '-';
else
    if (i == head_at)
        mark = '*';
    else
        mark = '+';
",,
implicit_predicate,show-ref.c,130,-,+,,19,	int patternlen = opts->pattern ? strlen(opts->pattern) : 0;
implicit_predicate,show-ref.c,328,+,-,"if (exclude_existing_opts.enabled)
    return cmd_show_ref__exclude_existing(&exclude_existing_opts);
else
    if (verify)
        return cmd_show_ref__verify(&show_one_opts, argv);
    else
        if (exists)
            return cmd_show_ref__exists(argv);
        else
            return cmd_show_ref__patterns(&patterns_opts, &show_one_opts, argv);
",,
implicit_predicate,show-ref.c,330,+,-,"if (verify)
    return cmd_show_ref__verify(&show_one_opts, argv);
else
    if (exists)
        return cmd_show_ref__exists(argv);
    else
        return cmd_show_ref__patterns(&patterns_opts, &show_one_opts, argv);
",,
implicit_predicate,show-ref.c,332,+,-,"if (exists)
    return cmd_show_ref__exists(argv);
else
    return cmd_show_ref__patterns(&patterns_opts, &show_one_opts, argv);
",,
implicit_predicate,sideband.c,144,-,+,,8,"			    scratch->len ? ""\n"" : """", me);"
implicit_predicate,sideband.c,156,-,+,,9,"				    scratch->len ? ""\n"" : """", me);"
implicit_predicate,sideband.c,170,+,-,"if (die_on_error)
    die(_(""remote error: %s""), buf + 1);
",,
implicit_predicate,sideband.c,172,-,+,,32,"		strbuf_addf(scratch, ""%s%s"", scratch->len ? ""\n"" : """","
implicit_predicate,sideband.c,230,-,+,,27,"			strbuf_addstr(scratch, scratch->len ?
				    """" : DISPLAY_PREFIX);"
implicit_predicate,sideband.c,240,-,+,,8,"			    scratch->len ? ""\n"" : """", me, band);"
implicit_predicate,skipping.c,161,-,+,,31,"		uint16_t new_original_ttl = entry->ttl
			? entry->original_ttl : entry->original_ttl * 3 / 2 + 1;"
implicit_predicate,skipping.c,163,-,+,,22,"		uint16_t new_ttl = entry->ttl
			? entry->ttl - 1 : new_original_ttl;"
implicit_predicate,skipping.c,263,+,-,"if (marked)
    refs_for_each_ref(get_main_ref_store(the_repository), clear_marks, NULL);
",,
implicit_predicate,sparse-checkout.c,198,+,-,"if (was_full)
    ensure_full_index(r->index);
",,
implicit_predicate,sparse-checkout.c,253,+,-,"while (*p){
    if (is_glob_special(*p))
        strbuf_addch(&final, '\\');

    strbuf_addch(&final, *p);
    p++;
}
",,
implicit_predicate,sparse-checkout.c,334,+,-,"if (result){
    rollback_lock_file(&lk);
    clear_pattern_list(pl);
    update_working_directory (NULL);
    return result;
}
",,
implicit_predicate,sparse-checkout.c,372,-,+,,10,"					    mode ? ""true"" : ""false"") ||"
implicit_predicate,sparse-checkout.c,463,+,-,"if (update_modes(&init_opts.cone_mode, &init_opts.sparse_index))
    return 1;
",,
implicit_predicate,sparse-checkout.c,616,+,+,use_stdin ? stdin : NULL,5,				use_stdin ? stdin : NULL);
implicit_predicate,sparse-checkout.c,653,+,+,use_stdin ? stdin : NULL,42,"	add_patterns_from_input(pl, argc, argv, use_stdin ? stdin : NULL);"
implicit_predicate,sparse-checkout.c,673,+,+,use_stdin ? stdin : NULL,6,					use_stdin ? stdin : NULL);
implicit_predicate,sparse-checkout.c,712,+,-,"if (skip_checks)
    return;
",,
implicit_predicate,sparse-checkout.c,824,+,-,"if (update_modes(&set_opts.cone_mode, &set_opts.sparse_index))
    return 1;
",,
implicit_predicate,sparse-checkout.c,876,+,-,"if (update_modes(&reapply_opts.cone_mode, &reapply_opts.sparse_index))
    return 1;
",,
implicit_predicate,sparse-checkout.c,926,+,-,"if (update_working_directory(&pl))
    die(_(""error while refreshing working directory""));
",,
implicit_predicate,sparse-checkout.c,949,+,+,null_terminated ? 0 : '\n',24,	int line_terminator = null_terminated ? 0 : '\n';
implicit_predicate,sparse-checkout.c,950,+,+,null_terminated ? strbuf_getline_nul : strbuf_getline,33,"	strbuf_getline_fn getline_fn = null_terminated ? strbuf_getline_nul
		: strbuf_getline;"
implicit_predicate,sparse-index.c,64,+,-,"if (can_convert){
    struct cache_entry* se;
    se = construct_sparse_dir_entry(istate, ct_path, ct);
    istate->cache[num_converted++] = se;
    return 1;
}
",,
implicit_predicate,sparse-index.c,113,+,+,"enable ? ""true"" : ""false""",9,"						  enable ? ""true"" : ""false"");"
implicit_predicate,sparse-index.c,190,+,-,"if (index_has_unmerged_entries(istate))
    return 0;
",,
implicit_predicate,sparse-index.c,337,-,+,,14,"	tr_region = pl ? ""expand_index"" : ""ensure_full_index"";"
implicit_predicate,sparse-index.c,349,-,+,,23,	full->sparse_index = pl ? INDEX_PARTIALLY_SPARSE : INDEX_EXPANDED;
implicit_predicate,sparse-index.c,404,-,+,,25,	istate->sparse_index = pl ? INDEX_PARTIALLY_SPARSE : INDEX_EXPANDED;
implicit_predicate,sparse-index.c,436,+,-,"if (is_sparse_index_allowed(istate, 0))
    convert_to_sparse(istate, 0);
else
    ensure_full_index(istate);
",,
implicit_predicate,sparse-index.c,513,+,-,"if (restarted)
    BUG(""ensure-full-index did not fully flatten?"");
",,
implicit_predicate,sparse-index.c,524,+,-,"if (path_count[0])
    trace2_data_intmax(""index"", istate->repo, ""sparse_path_count"", path_count[0]);
",,
implicit_predicate,sparse-index.c,527,+,-,"if (restarted)
    trace2_data_intmax(""index"", istate->repo, ""sparse_path_count_full"", path_count[1]);
",,
implicit_predicate,sparse-index.c,547,+,-,"if (in_expand_to_path)
    return;
",,
implicit_predicate,split-index.c,346,+,-,"if (compare_ce_content(ce, base))
    ce->ce_flags |= CE_UPDATE_IN_BASE;
",,
implicit_predicate,stack.c,328,+,-,"while (1){
    struct timeval now;
    err = gettimeofday(&now, NULL);
    if (err < 0)
        goto out;

    tries++;
    if (tries > 3 && tv_cmp(&now, &deadline) >= 0)
        goto out;

    fd = open(st->list_file, O_RDONLY);
    if (fd < 0){
        if (errno != ENOENT){
            err = REFTABLE_IO_ERROR;
            goto out;
        }
        REFTABLE_CALLOC_ARRAY(names, 1);
    }else{
        err = fd_read_lines(fd, &names);
        if (err < 0)
            goto out;
    }
    err = reftable_stack_reload_once(st, names, reuse_open);
    if (!err)
        break;

    if (err != REFTABLE_NOT_EXIST_ERROR)
        goto out;

    err = read_lines(st->list_file, &names_after);
    if (err < 0)
        goto out;

    if (names_equal(names_after, names)){
        err = REFTABLE_NOT_EXIST_ERROR;
        goto out;
    }
    free_names(names);
    names = NULL;
    free_names(names_after);
    names_after = NULL;
    close(fd);
    fd = -1;
    delay = delay + (delay * rand()) / RAND_MAX + 1;
    sleep_millisec(delay);
}
",,
implicit_predicate,stack.c,345,+,-,"while (1){
    struct timeval now;
    err = gettimeofday(&now, NULL);
    if (err < 0)
        goto out;

    tries++;
    if (tries > 3 && tv_cmp(&now, &deadline) >= 0)
        goto out;

    fd = open(st->list_file, O_RDONLY);
    if (fd < 0){
        if (errno != ENOENT){
            err = REFTABLE_IO_ERROR;
            goto out;
        }
        REFTABLE_CALLOC_ARRAY(names, 1);
    }else{
        err = fd_read_lines(fd, &names);
        if (err < 0)
            goto out;
    }
    err = reftable_stack_reload_once(st, names, reuse_open);
    if (!err)
        break;

    if (err != REFTABLE_NOT_EXIST_ERROR)
        goto out;

    err = read_lines(st->list_file, &names_after);
    if (err < 0)
        goto out;

    if (names_equal(names_after, names)){
        err = REFTABLE_NOT_EXIST_ERROR;
        goto out;
    }
    free_names(names);
    names = NULL;
    free_names(names_after);
    names_after = NULL;
    close(fd);
    fd = -1;
    delay = delay + (delay * rand()) / RAND_MAX + 1;
    sleep_millisec(delay);
}
",,
implicit_predicate,stack.c,598,+,-,"if (err){
    reftable_addition_close(add);
}
",,
implicit_predicate,stack.c,615,+,-,"if (err){
    reftable_addition_close(add);
}
",,
implicit_predicate,stack.c,678,+,-,"if (err)
    goto done;
",,
implicit_predicate,stack.c,695,+,-,"if (err)
    goto done;
",,
implicit_predicate,stack.c,708,+,-,"if (err){
    reftable_free(*dest);
    *dest = NULL;
}
",,
implicit_predicate,stack.c,725,+,-,"if (err){
    reftable_free(*dest);
    *dest = NULL;
}
",,
implicit_predicate,stack.c,917,+,-,"while (1){
    err = reftable_iterator_next_ref(&it, &ref);
    if (err > 0){
        err = 0;
        break;
    }
    if (err < 0)
        goto done;

    if (first == 0 && reftable_ref_record_is_deletion(&ref)){
        continue;
    }
    err = reftable_writer_add_ref(wr, &ref);
    if (err < 0)
        goto done;

    entries++;
}
",,
implicit_predicate,stack.c,935,+,-,"while (1){
    err = reftable_iterator_next_ref(&it, &ref);
    if (err > 0){
        err = 0;
        break;
    }
    if (err < 0)
        goto done;

    if (first == 0 && reftable_ref_record_is_deletion(&ref)){
        continue;
    }
    err = reftable_writer_add_ref(wr, &ref);
    if (err < 0)
        goto done;

    entries++;
}
",,
implicit_predicate,stack.c,941,+,-,"while (1){
    err = reftable_iterator_next_log(&it, &log);
    if (err > 0){
        err = 0;
        break;
    }
    if (err < 0)
        goto done;

    if (first == 0 && reftable_log_record_is_deletion(&log)){
        continue;
    }
    if (config && config->min_update_index > 0 && log.update_index < config->min_update_index){
        continue;
    }
    if (config && config->time > 0 && log.value.update.time < config->time){
        continue;
    }
    err = reftable_writer_add_log(wr, &log);
    if (err < 0)
        goto done;

    entries++;
}
",,
implicit_predicate,stack.c,960,+,-,"while (1){
    err = reftable_iterator_next_log(&it, &log);
    if (err > 0){
        err = 0;
        break;
    }
    if (err < 0)
        goto done;

    if (first == 0 && reftable_log_record_is_deletion(&log)){
        continue;
    }
    if (config && config->min_update_index > 0 && log.update_index < config->min_update_index){
        continue;
    }
    if (config && config->time > 0 && log.value.update.time < config->time){
        continue;
    }
    err = reftable_writer_add_log(wr, &log);
    if (err < 0)
        goto done;

    entries++;
}
",,
implicit_predicate,stack.c,1026,+,-,"if (err)
    goto done;
",,
implicit_predicate,stack.c,1045,+,-,"if (err)
    goto done;
",,
implicit_predicate,stack.c,1194,-,+,,36,"	return stack_compact_range(st, 0, st->merged->stack_len ?
			st->merged->stack_len - 1 : 0, config);"
implicit_predicate,stack.c,1331,+,-,"if (err)
    goto done;
",,
implicit_predicate,stack.c,1335,+,-,"if (err)
    goto done;
",,
implicit_predicate,stack.c,1345,+,-,"if (err){
    reftable_log_record_release(log);
}
",,
implicit_predicate,stack.c,1357,+,-,"if (err)
    goto done;
",,
implicit_predicate,stack.c,1361,+,-,"if (err)
    goto done;
",,
implicit_predicate,stack.c,1371,+,-,"if (err){
    reftable_log_record_release(log);
}
",,
implicit_predicate,stack.c,1405,+,-,"if (found)
    continue;
",,
implicit_predicate,stack.c,1431,+,-,"if (found)
    continue;
",,
implicit_predicate,stack_test.c,68,-,+,,4,"		 tmp ? tmp : ""/tmp"", linenumber);"
implicit_predicate,stash.c,260,+,-,"if (argc)
    return error(_(""git stash clear with arguments is unimplemented""));
",,
implicit_predicate,stash.c,293,+,+,reset ? UNPACK_RESET_PROTECT_UNTRACKED : 0,15,	opts.reset = reset ? UNPACK_RESET_PROTECT_UNTRACKED : 0;
implicit_predicate,stash.c,295,+,-,"if (update)
    opts.preserve_ignored = 0;
",,
implicit_predicate,stash.c,546,+,-,"if (index){
    if (oideq(&info->b_tree, &info->i_tree) || oideq(&c_tree, &info->i_tree)){
        has_index = 0;
    }else{
        struct strbuf out = STRBUF_INIT;
        if (diff_tree_binary(&out, &info->w_commit)){
            strbuf_release(&out);
            return error(_(""could not generate diff %s^!.""), oid_to_hex(&info->w_commit));
        }
        ret = apply_cached(&out);
        strbuf_release(&out);
        if (ret)
            return error(_(""conflicts in index. Try without --index.""));

        discard_index(the_repository->index);
        repo_read_index (the_repository);
        if (write_index_as_tree(&index_tree, the_repository->index, get_index_file(), 0, NULL))
            return error(_(""could not save index tree""));

        reset_head();
        discard_index(the_repository->index);
        repo_read_index(the_repository);
    }
}
",,
implicit_predicate,stash.c,553,+,-,"if (diff_tree_binary(&out, &info->w_commit)){
    strbuf_release(&out);
    return error(_(""could not generate diff %s^!.""), oid_to_hex(&info->w_commit));
}
",,
implicit_predicate,stash.c,561,+,-,"if (ret)
    return error(_(""conflicts in index. Try without --index.""));
",,
implicit_predicate,stash.c,586,+,-,"if (quiet)
    o.verbosity = 0;
",,
implicit_predicate,stash.c,612,+,-,"if (ret){
    repo_rerere(the_repository, 0);
    if (index)
        fprintf_ln(stderr, _(""Index was not unstashed.""));

    goto restore_untracked;
}
",,
implicit_predicate,stash.c,615,+,-,"if (index)
    fprintf_ln(stderr, _(""Index was not unstashed.""));
",,
implicit_predicate,stash.c,621,+,-,"if (has_index){
    if (reset_tree(&index_tree, 0, 0))
        ret = -1;
}else{
    unstage_changes_unless_new(&c_tree);
}
",,
implicit_predicate,stash.c,622,+,-,"if (reset_tree(&index_tree, 0, 0))
    ret = -1;
",,
implicit_predicate,stash.c,669,+,-,"if (get_stash_info(&info, argc, argv))
    goto cleanup;
",,
implicit_predicate,stash.c,707,+,-,"if (reflog_is_empty(ref_stash))
    do_clear_stash();
",,
implicit_predicate,stash.c,740,+,-,"if (get_stash_info_assert(&info, argc, argv))
    goto cleanup;
",,
implicit_predicate,stash.c,765,+,-,"if (get_stash_info_assert(&info, argc, argv))
    goto cleanup;
",,
implicit_predicate,stash.c,768,+,-,"if ((ret = do_apply_stash(prefix, &info, index, quiet)))
    printf_ln(_(""The stash entry is kept in case you need it again.""));
else
    ret = do_drop_stash(&info, quiet);
",,
implicit_predicate,stash.c,799,+,-,"if (get_stash_info(&info, argc - 1, argv + 1))
    goto cleanup;
",,
implicit_predicate,stash.c,902,+,+,show_include_untracked ? UNTRACKED_INCLUDE : UNTRACKED_NONE,21,	} show_untracked = show_include_untracked ? UNTRACKED_INCLUDE : UNTRACKED_NONE;
implicit_predicate,stash.c,938,+,-,"if (show_stat)
    rev.diffopt.output_format = DIFF_FORMAT_DIFFSTAT;
",,
implicit_predicate,stash.c,941,+,-,"if (show_patch)
    rev.diffopt.output_format |= DIFF_FORMAT_PATCH;
",,
implicit_predicate,stash.c,965,+,-,"if (info.has_u)
    diff_root_tree_oid(&info.u_tree, """", &rev.diffopt);
",,
implicit_predicate,stash.c,969,+,-,"if (info.has_u)
    diff_include_untracked(&info, &rev.diffopt);
else
    diff_tree_oid(&info.b_commit, &info.w_commit, """", &rev.diffopt);
",,
implicit_predicate,stash.c,982,+,-,"if (do_usage)
    usage_with_options(git_stash_show_usage, options);
",,
implicit_predicate,stash.c,1004,+,+,quiet ? UPDATE_REFS_QUIET_ON_ERR : UPDATE_REFS_MSG_ON_ERR,8,"			    quiet ? UPDATE_REFS_QUIET_ON_ERR :
			    UPDATE_REFS_MSG_ON_ERR)) {"
implicit_predicate,stash.c,1041,+,+,quiet ? GET_OID_QUIETLY : 0,15,"				 argv[0], quiet ? GET_OID_QUIETLY : 0, &obj,"
implicit_predicate,stash.c,1145,+,-,"if (check_changes_tracked_files(ps))
    ret = 1;
",,
implicit_predicate,stash.c,1301,+,-,"if (reset_tree(&info->i_tree, 0, 0)){
    ret = -1;
    goto done;
}
",,
implicit_predicate,stash.c,1411,+,-,"if (include_untracked){
    if (save_untracked_files(info, &msg, untracked_files)){
        if (!quiet)
            fprintf_ln(stderr, _(""Cannot save the untracked files""));

        ret = -1;
        goto done;
    }
    untracked_commit_option = 1;
}
",,
implicit_predicate,stash.c,1412,+,-,"if (save_untracked_files(info, &msg, untracked_files)){
    if (!quiet)
        fprintf_ln(stderr, _(""Cannot save the untracked files""));

    ret = -1;
    goto done;
}
",,
implicit_predicate,stash.c,1421,+,-,"if (patch_mode){
    ret = stash_patch(info, ps, patch, quiet);
    if (ret < 0){
        if (!quiet)
            fprintf_ln(stderr, _(""Cannot save the current worktree state""));

        goto done;
    }else
        if (ret > 0){
            goto done;
        }
}else
    if (only_staged){
        ret = stash_staged(info, patch, quiet);
        if (ret < 0){
            if (!quiet)
                fprintf_ln(stderr, _(""Cannot save the current staged state""));

            goto done;
        }else
            if (ret > 0){
                goto done;
            }
    }else{
        if (stash_working_tree(info, ps)){
            if (!quiet)
                fprintf_ln(stderr, _(""Cannot save the current worktree state""));

            ret = -1;
            goto done;
        }
    }
",,
implicit_predicate,stash.c,1431,+,-,"if (only_staged){
    ret = stash_staged(info, patch, quiet);
    if (ret < 0){
        if (!quiet)
            fprintf_ln(stderr, _(""Cannot save the current staged state""));

        goto done;
    }else
        if (ret > 0){
            goto done;
        }
}else{
    if (stash_working_tree(info, ps)){
        if (!quiet)
            fprintf_ln(stderr, _(""Cannot save the current worktree state""));

        ret = -1;
        goto done;
    }
}
",,
implicit_predicate,stash.c,1442,+,-,"if (stash_working_tree(info, ps)){
    if (!quiet)
        fprintf_ln(stderr, _(""Cannot save the current worktree state""));

    ret = -1;
    goto done;
}
",,
implicit_predicate,stash.c,1461,+,-,"if (untracked_commit_option)
    commit_list_insert(lookup_commit(the_repository, &info->u_commit), &parents);
",,
implicit_predicate,stash.c,1529,+,-,"if (patch_mode)
    only_staged = 0;
",,
implicit_predicate,stash.c,1580,+,-,"if (do_create_stash(ps, &stash_msg_buf, include_untracked, patch_mode, only_staged, &info, &patch, quiet)){
    ret = -1;
    goto done;
}
",,
implicit_predicate,stash.c,1753,+,-,"if (argc){
    force_assume = !strcmp(argv[0], ""-p"");
    argc = parse_options(argc, argv, prefix, options, push_assumed ? git_stash_usage : git_stash_push_usage, PARSE_OPT_KEEP_DASHDASH);
}
",,
implicit_predicate,stash.c,1756,+,+,push_assumed ? git_stash_usage : git_stash_push_usage,10,"				     push_assumed ? git_stash_usage :
				     git_stash_push_usage,"
implicit_predicate,stash.c,1761,+,-,"if (argc){
    if (!strcmp(argv[0], ""--"")){
        argc--;
        argv++;
    }else
        if (push_assumed && !force_assume){
            die(""subcommand wasn't specified; 'push' can't be assumed due to unexpected token '%s'"", argv[0]);
        }
}
",,
implicit_predicate,stash.c,1775,+,-,"if (patch_mode)
    die(_(""options '%s' and '%s' cannot be used together""), ""--pathspec-from-file"", ""--patch"");
",,
implicit_predicate,stash.c,1778,+,-,"if (only_staged)
    die(_(""options '%s' and '%s' cannot be used together""), ""--pathspec-from-file"", ""--staged"");
",,
implicit_predicate,stash.c,1787,+,-,"if (pathspec_file_nul){
    die(_(""the option '%s' requires '%s'""), ""--pathspec-file-nul"", ""--pathspec-from-file"");
}
",,
implicit_predicate,stash.c,1834,+,-,"if (argc)
    stash_msg = strbuf_join_argv(&stash_msg_buf, argc, argv, ' ');
",,
implicit_predicate,strbuf.c,110,+,-,"if (new_buf)
    sb->buf = NULL;
",,
implicit_predicate,strbuf.c,113,+,-,"if (new_buf)
    sb->buf[0] = '\0';
",,
implicit_predicate,strbuf.c,215,+,-,"if (sep_needed)
    strbuf_addstr(str, sep);
",,
implicit_predicate,strbuf.c,239,+,-,"if (cmp)
    return cmp;
",,
implicit_predicate,strbuf.c,330,+,-,"while (--argc){
    strbuf_addch(buf, delim);
    strbuf_addstr(buf, *(++argv));
}
",,
implicit_predicate,strbuf.c,360,-,+,,10,		next = next ? (next + 1) : (buf + size);
implicit_predicate,strbuf.c,390,+,-,"if (incomplete_line)
    sb->buf[--sb->len] = '\0';
",,
implicit_predicate,strbuf.c,515,-,+,,18,"	strbuf_grow(sb, hint ? hint : 8192);"
implicit_predicate,strbuf.c,542,-,+,,18,"	strbuf_grow(sb, hint ? hint : 8192);"
implicit_predicate,strbuf.c,553,-,+,,9,"	return sb->len ? fwrite(sb->buf, 1, sb->len, f) : 0;"
implicit_predicate,strbuf.c,741,+,-,"while (1){
    char ch;
    ssize_t len = xread(fd, &ch, 1);
    if (len <= 0)
        return EOF;

    strbuf_addch(sb, ch);
    if (ch == term)
        break;
}
",,
implicit_predicate,strbuf.c,961,+,-,"while (strbuf_expand_step(&munged_fmt, &fmt)){
    if (skip_prefix(fmt, ""%"", &fmt))
        strbuf_addstr(&munged_fmt, ""%%"");
    else
        if (skip_prefix(fmt, ""s"", &fmt))
            strbuf_addf(&munged_fmt, ""%"", (timestamp_t)tm_to_time_t(tm) - 3600 * (tz_offset / 100) - 60 * (tz_offset % 100));
        else
            if (skip_prefix(fmt, ""z"", &fmt))
                strbuf_addf(&munged_fmt, ""%+05d"", tz_offset);
            else
                if (suppress_tz_name && skip_prefix(fmt, ""Z"", &fmt));

                else
                    strbuf_addch(&munged_fmt, '%');
}
",,
implicit_predicate,strbuf.c,1045,-,+,,9,		len = eol ? eol - (sb->buf + i) + 1 : sb->len - i;
implicit_predicate,strbuf.c,1072,-,+,,20,
implicit_predicate,strbuf.h,145,-,+,,9,	return sb->alloc ? sb->alloc - sb->len - 1 : 0;
implicit_predicate,strbuf.h,166,-,+,,13,	if (len > (sb->alloc ? sb->alloc - 1 : 0))
implicit_predicate,streaming.c,124,+,-,"if (fs->input_finished){
    size_t to_receive = FILTER_BUFFER;
    if (stream_filter(fs->filter, NULL, NULL, fs->obuf, &to_receive))
        return -1;

    fs->o_end = FILTER_BUFFER - to_receive;
    if (!fs->o_end)
        break;

    continue;
}
",,
implicit_predicate,streaming.c,142,+,-,"if (fs->i_end)
    continue;
",,
implicit_predicate,streaming.c,470,+,-,"if (ret){
    free(st);
    return NULL;
}
",,
implicit_predicate,streaming.c,475,+,-,"if (st->open(st, r, real, type)){
    if (open_istream_incore(st, r, real, type)){
        free(st);
        return NULL;
    }
}
",,
implicit_predicate,string-list.c,22,-,+,,27,	compare_strings_fn cmp = list->cmp ? list->cmp : strcmp;
implicit_predicate,string-list.c,47,+,-,"if (exact_match)
    return -1 - index;
",,
implicit_predicate,string-list.c,54,-,+,,30,"	list->items[index].string = list->strdup_strings ?
		xstrdup(string) : (char *)string;"
implicit_predicate,string-list.c,78,+,-,"if (exact_match){
    if (list->strdup_strings)
        free(list->items[i].string);

    if (free_util)
        free(list->items[i].util);

    list->nr--;
    MOVE_ARRAY(list->items + i, list->items + i + 1, list->nr - i);
}
",,
implicit_predicate,string-list.c,81,+,-,"if (free_util)
    free(list->items[i].util);
",,
implicit_predicate,string-list.c,101,+,-,"if (exact_match)
    index = -1 - (negative_existing_index ? index : 0);
",,
implicit_predicate,string-list.c,102,+,+,negative_existing_index ? index : 0,17,		index = -1 - (negative_existing_index ? index : 0);
implicit_predicate,string-list.c,118,-,+,,28,		compare_strings_fn cmp = list->cmp ? list->cmp : strcmp;
implicit_predicate,string-list.c,123,+,-,"if (free_util)
    free(list->items[src].util);
",,
implicit_predicate,string-list.c,152,+,-,"if (free_util)
    free(list->items[src].util);
",,
implicit_predicate,string-list.c,177,+,-,"if (free_util){
    for (i = 0;i < list->nr;i++)
        free(list->items[i].util);
}
",,
implicit_predicate,string-list.c,230,-,+,,4,			list->strdup_strings ? xstrdup(string) : (char *)string);
implicit_predicate,string-list.c,252,-,+,,42,	struct string_list_sort_ctx sort_ctx = {list->cmp ? list->cmp : strcmp};
implicit_predicate,string-list.c,261,-,+,,27,	compare_strings_fn cmp = list->cmp ? list->cmp : strcmp;
implicit_predicate,string-list.c,279,+,-,"if (free_util)
    free(list->items[i].util);
",,
implicit_predicate,stripspace.c,49,+,-,"if (argc)
    usage_with_options(stripspace_usage, options);
",,
implicit_predicate,strmap.c,61,+,-,"if (free_values)
    free(e->value);
",,
implicit_predicate,strmap.c,131,-,+,,9,	return entry ? entry->value : NULL;
implicit_predicate,strmap.c,147,+,-,"if (free_value)
    free(ret->value);
",,
implicit_predicate,sub-process.c,97,+,-,"if (err){
    error(""cannot fork to run subprocess '%s'"", cmd);
    return err;
}
",,
implicit_predicate,sub-process.c,105,+,-,"if (err){
    error(""initialization for subprocess '%s' failed"", cmd);
    subprocess_stop(hashmap, entry);
    return err;
}
",,
implicit_predicate,sub-process.c,130,+,-,"for (i = 0;versions[i];i++){
    if (packet_write_fmt_gently(process->in, ""version=%d\n"", versions[i]))
        return error(""Could not write requested version"");
}
",,
implicit_predicate,sub-process.c,152,+,-,"for (i = 0;versions[i];i++){
    if (versions[i] == *chosen_version)
        break;
}
",,
implicit_predicate,submodule--helper.c,93,+,-,"if (code)
    exit(code);
",,
implicit_predicate,submodule--helper.c,262,+,-,"for (i = count_slashes(path);i;i--)
    strbuf_addstr(&sb, ""../"");
",,
implicit_predicate,submodule--helper.c,372,+,-,"if (info->recursive){
    struct child_process cpr = CHILD_PROCESS_INIT;
    cpr.git_cmd = 1;
    cpr.dir = path;
    prepare_submodule_repo_env(&cpr.env);
    strvec_pushl(&cpr.args, ""submodule--helper"", ""foreach"", ""--recursive"", NULL);
    strvec_pushl(&cpr.args, ""--super-prefix"", NULL);
    strvec_pushf(&cpr.args, ""%s/"", displaypath);
    if (info->quiet)
        strvec_push(&cpr.args, ""--quiet"");

    strvec_push(&cpr.args, ""--"");
    strvec_pushv(&cpr.args, info->argv);
    if (run_command(&cpr))
        die(_(""run_command returned non-zero status while recursing in the nested submodules of %s\n.""), displaypath);
}
",,
implicit_predicate,submodule--helper.c,384,+,-,"if (info->quiet)
    strvec_push(&cpr.args, ""--quiet"");
",,
implicit_predicate,submodule--helper.c,575,+,-,"if (quiet)
    info.flags |= OPT_QUIET;
",,
implicit_predicate,submodule--helper.c,597,+,-,"if (flags & OPT_QUIET)
    return;
",,
implicit_predicate,submodule--helper.c,697,+,-,"if (flags & OPT_RECURSIVE){
    struct child_process cpr = CHILD_PROCESS_INIT;
    cpr.git_cmd = 1;
    cpr.dir = path;
    prepare_submodule_repo_env(&cpr.env);
    strvec_pushl(&cpr.args, ""submodule--helper"", ""status"", ""--recursive"", NULL);
    strvec_push(&cpr.args, ""--super-prefix"");
    strvec_pushf(&cpr.args, ""%s/"", displaypath);
    if (flags & OPT_CACHED)
        strvec_push(&cpr.args, ""--cached"");

    if (flags & OPT_QUIET)
        strvec_push(&cpr.args, ""--quiet"");

    if (run_command(&cpr))
        die(_(""failed to recurse into submodule '%s'""), path);
}
",,
implicit_predicate,submodule--helper.c,709,+,-,"if (flags & OPT_CACHED)
    strvec_push(&cpr.args, ""--cached"");
",,
implicit_predicate,submodule--helper.c,712,+,-,"if (flags & OPT_QUIET)
    strvec_push(&cpr.args, ""--quiet"");
",,
implicit_predicate,submodule--helper.c,760,+,-,"if (quiet)
    info.flags |= OPT_QUIET;
",,
implicit_predicate,submodule--helper.c,920,+,-,"if (p->mod_dst)
    warning(_(""unexpected mode %o\n""), p->mod_dst);
",,
implicit_predicate,submodule--helper.c,1009,+,+,missing_src ? oid_to_hex(&p->oid_src) : oid_to_hex(&p->oid_dst),23,"					    displaypath, missing_src ?
					    oid_to_hex(&p->oid_src) :
					    oid_to_hex(&p->oid_dst));"
implicit_predicate,submodule--helper.c,1016,-,+,,32,"	print_submodule_summary(info, errmsg.len ? errmsg.buf : NULL,"
implicit_predicate,submodule--helper.c,1055,+,-,"if (ignore_all)
    continue;
",,
implicit_predicate,submodule--helper.c,1114,+,-,"if (info->cached)
    strvec_push(&diff_args, ""--cached"");
",,
implicit_predicate,submodule--helper.c,1120,+,-,"if (info->argc)
    strvec_pushv(&diff_args, info->argv);
",,
implicit_predicate,submodule--helper.c,1147,+,+,info->cached ? DIFF_INDEX_CACHED : 0,24,"		run_diff_index(&rev, info->cached ? DIFF_INDEX_CACHED : 0);"
implicit_predicate,submodule--helper.c,1190,+,+,"argc ? argv[0] : ""HEAD""",36,"	if (!repo_get_oid(the_repository, argc ? argv[0] : ""HEAD"", &head_oid)) {"
implicit_predicate,submodule--helper.c,1191,+,-,"if (argc){
    argv++;
    argc--;
}
",,
implicit_predicate,submodule--helper.c,1198,+,-,"if (argc){
    argv++;
    argc--;
}
",,
implicit_predicate,submodule--helper.c,1207,+,-,"if (files){
    if (cached)
        die(_(""options '%s' and '%s' cannot be used together""), ""--cached"", ""--files"");

    diff_cmd = DIFF_FILES;
}
",,
implicit_predicate,submodule--helper.c,1208,+,-,"if (cached)
    die(_(""options '%s' and '%s' cannot be used together""), ""--cached"", ""--files"");
",,
implicit_predicate,submodule--helper.c,1285,+,-,"if (code)
    exit(code);
",,
implicit_predicate,submodule--helper.c,1298,+,-,"if (flags & OPT_RECURSIVE){
    struct child_process cpr = CHILD_PROCESS_INIT;
    cpr.git_cmd = 1;
    cpr.dir = path;
    prepare_submodule_repo_env(&cpr.env);
    strvec_pushl(&cpr.args, ""submodule--helper"", ""sync"", ""--recursive"", NULL);
    strvec_push(&cpr.args, ""--super-prefix"");
    strvec_pushf(&cpr.args, ""%s/"", displaypath);
    if (flags & OPT_QUIET)
        strvec_push(&cpr.args, ""--quiet"");

    if (run_command(&cpr))
        die(_(""failed to recurse into submodule '%s'""), path);
}
",,
implicit_predicate,submodule--helper.c,1311,+,-,"if (flags & OPT_QUIET)
    strvec_push(&cpr.args, ""--quiet"");
",,
implicit_predicate,submodule--helper.c,1363,+,-,"if (quiet)
    info.flags |= OPT_QUIET;
",,
implicit_predicate,submodule--helper.c,1365,+,-,"if (recursive)
    info.flags |= OPT_RECURSIVE;
",,
implicit_predicate,submodule--helper.c,1518,+,-,"if (quiet)
    info.flags |= OPT_QUIET;
",,
implicit_predicate,submodule--helper.c,1520,+,-,"if (force)
    info.flags |= OPT_FORCE;
",,
implicit_predicate,submodule--helper.c,1754,-,+,,26,"			strvec_push(&cp.args, clone_data->single_branch ?
				    ""--single-branch"" :
				    ""--no-single-branch"");"
implicit_predicate,submodule--helper.c,2151,-,+,,29,"		strvec_push(&child->args, suc->update_data->single_branch ?
					      ""--single-branch"" :
					      ""--no-single-branch"");"
implicit_predicate,submodule--helper.c,2158,+,-,"if (need_free_url)
    free((void*)url);
",,
implicit_predicate,submodule--helper.c,2175,+,-,"if (prepare_to_clone_next_submodule(ce, child, suc, err)){
    int* p = xmalloc(sizeof (*p));
    *p = suc->current;
    *idx_task_cb = p;
    suc->current++;
    return 1;
}
",,
implicit_predicate,submodule--helper.c,2300,+,-,"if (quiet)
    strvec_push(&cp.args, ""--quiet"");
",,
implicit_predicate,submodule--helper.c,2302,+,-,"if (depth)
    strvec_pushf(&cp.args, ""--depth=%d"", depth);
",,
implicit_predicate,submodule--helper.c,2325,+,-,"if (subforce)
    strvec_push(&cp.args, ""-f"");
",,
implicit_predicate,submodule--helper.c,2579,-,+,,21,"		strvec_push(args, update_data->single_branch ?
				    ""--single-branch"" :
				    ""--no-single-branch"");"
implicit_predicate,submodule--helper.c,2596,+,-,"if (ret)
    return ret;
",,
implicit_predicate,submodule--helper.c,2599,+,-,"if (update_data->just_cloned)
    oidcpy(&update_data->suboid, null_oid());
else
    if (resolve_gitlink_ref(update_data->sm_path, ""HEAD"", &update_data->suboid))
        return die_message(_(""Unable to find current revision in submodule path '%s'""), update_data->displaypath);
",,
implicit_predicate,submodule--helper.c,2605,+,-,"if (update_data->remote){
    char* remote_name;
    const char* branch;
    char* remote_ref;
    int code;
    code = get_default_remote_submodule(update_data->sm_path, &remote_name);
    if (code)
        return code;

    code = remote_submodule_branch(update_data->sm_path, &branch);
    if (code)
        return code;

    remote_ref = xstrfmt(""refs/remotes/%s/%s"", remote_name, branch);
    free(remote_name);
    if (!update_data->nofetch){
        if (fetch_in_submodule(update_data->sm_path, update_data->depth, 0, NULL))
            return die_message(_(""Unable to fetch in submodule path '%s'""), update_data->sm_path);
    }
    if (resolve_gitlink_ref(update_data->sm_path, remote_ref, &update_data->oid))
        return die_message(_(""Unable to find %s revision in submodule path '%s'""), remote_ref, update_data->sm_path);

    free(remote_ref);
}
",,
implicit_predicate,submodule--helper.c,2612,+,-,"if (code)
    return code;
",,
implicit_predicate,submodule--helper.c,2615,+,-,"if (code)
    return code;
",,
implicit_predicate,submodule--helper.c,2637,+,-,"if (ret)
    return ret;
",,
implicit_predicate,submodule--helper.c,2641,+,-,"if (update_data->recursive){
    struct child_process cp = CHILD_PROCESS_INIT;
    struct update_data next = *update_data;
    next.prefix = NULL;
    oidcpy(&next.oid, null_oid());
    oidcpy(&next.suboid, null_oid());
    cp.dir = update_data->sm_path;
    cp.git_cmd = 1;
    prepare_submodule_repo_env(&cp.env);
    update_data_to_args(&next, &cp.args);
    ret = run_command(&cp);
    if (ret)
        die_message(_(""Failed to recurse into submodule path '%s'""), update_data->displaypath);

    return ret;
}
",,
implicit_predicate,submodule--helper.c,2655,+,-,"if (ret)
    die_message(_(""Failed to recurse into submodule path '%s'""), update_data->displaypath);
",,
implicit_predicate,submodule--helper.c,2691,+,-,"if (suc.quickstop){
    ret = 1;
    goto cleanup;
}
",,
implicit_predicate,submodule--helper.c,2714,+,-,"if (code)
    goto fail;
",,
implicit_predicate,submodule--helper.c,2801,+,-,"if (opt.require_init)
    opt.init = 1;
",,
implicit_predicate,submodule--helper.c,2823,+,-,"if (opt.init){
    struct module_list list = MODULE_LIST_INIT;
    struct init_cb info = INIT_CB_INIT;
    if (module_list_compute(argv, opt.prefix, &pathspec2, &list) < 0){
        module_list_release(&list);
        ret = 1;
        goto cleanup;
    }
    if (!argc && !git_config_get(""submodule.active""))
        module_list_active(&list);

    info.prefix = opt.prefix;
    info.super_prefix = opt.super_prefix;
    if (opt.quiet)
        info.flags |= OPT_QUIET;

    for_each_listed_submodule(&list, init_submodule_cb, &info);
    module_list_release(&list);
}
",,
implicit_predicate,submodule--helper.c,2843,+,-,"if (opt.quiet)
    info.flags |= OPT_QUIET;
",,
implicit_predicate,submodule--helper.c,3002,+,+,quiet ? OPT_QUIET : 0,43,"		sync_submodule(sub->path, prefix, NULL, quiet ? OPT_QUIET : 0);"
implicit_predicate,submodule--helper.c,3208,+,-,"if (clone_submodule(&clone_data, &reference))
    goto cleanup;
",,
implicit_predicate,submodule--helper.c,3262,+,-,"if (add_data->force)
    strvec_push(&add_submod.args, ""--force"");
",,
implicit_predicate,submodule--helper.c,3274,+,-,"if (config_submodule_in_gitmodules(add_data->sm_name, ""branch"", add_data->branch))
    die(_(""Failed to register submodule '%s'""), add_data->sm_path);
",,
implicit_predicate,submodule--helper.c,3337,+,-,"if (ps_matched[0]){
    if (!force)
        die(_(""'%s' already exists in the index""), path);

    if (!S_ISGITLINK(the_repository->index->cache[i]->ce_mode))
        die(_(""'%s' already exists in the index and is not a submodule""), path);

    break;
}
",,
implicit_predicate,submodule--helper.c,3472,+,-,"if (add_submodule(&add_data))
    goto cleanup;
",,
implicit_predicate,submodule-config.c,264,+,-,"while (1){
    if (starts_with_dot_dot_slash(url)){
        result++;
        url += strlen(""../"");
        continue;
    }
    if (starts_with_dot_slash(url)){
        url += strlen(""./"");
        continue;
    }
    *out = url;
    return result;
}
",,
implicit_predicate,submodule-config.c,265,+,-,"if (starts_with_dot_dot_slash(url)){
    result++;
    url += strlen(""../"");
    continue;
}
",,
implicit_predicate,submodule-config.c,270,+,-,"if (starts_with_dot_slash(url)){
    url += strlen(""./"");
    continue;
}
",,
implicit_predicate,submodule-config.c,337,+,-,"if (has_nl)
    return -1;
",,
implicit_predicate,submodule-config.c,352,+,-,"if (url_to_curl_url(url, &curl_url)){
    int ret = 0;
    char* normalized = url_normalize(curl_url, NULL);
    if (normalized){
        char* decoded = url_decode(normalized);
        if (strchr(decoded, '\n'))
            ret = -1;

        free(normalized);
        free(decoded);
    }else{
        ret = -1;
    }
    return ret;
}
",,
implicit_predicate,submodule-config.c,440,+,-,"if (die_on_error)
    die(""bad %s argument: %s"", opt, arg);
else
    return RECURSE_SUBMODULES_ERROR;
",,
implicit_predicate,submodule-config.c,473,+,-,"if (unset){
    *v = RECURSE_SUBMODULES_OFF;
}else{
    if (arg)
        *v = parse_fetch_recurse_submodules_arg(opt->long_name, arg);
    else
        *v = RECURSE_SUBMODULES_ON;
}
",,
implicit_predicate,submodule-config.c,493,+,-,"if (die_on_error)
    die(""bad %s argument: %s"", opt, arg);
",,
implicit_predicate,submodule-config.c,510,+,-,"if (die_on_error)
    die(""bad %s argument: %s"", opt, arg);
else
    return RECURSE_SUBMODULES_ERROR;
",,
implicit_predicate,submodule-config.c,527,+,-,"if (die_on_error)
    die(""bad %s argument: %s"", opt, arg);
else
    return RECURSE_SUBMODULES_ERROR;
",,
implicit_predicate,submodule-config.c,858,+,-,"if (gitmodule_oid_from_commit(commit_oid, &oid, &rev)){
    git_config_from_blob_oid(gitmodules_cb, rev.buf, the_repository, &oid, the_repository, CONFIG_SCOPE_UNKNOWN);
}
",,
implicit_predicate,submodule.c,189,+,-,"if (ret){
    string_list_clear(&added_submodule_odb_paths, 0);
    trace2_data_intmax(""submodule"", the_repository, ""register_all_submodule_odb_as_alternates/registered"", ret);
    if (git_env_bool(""GIT_TEST_FATAL_REGISTER_SUBMODULE_ODB"", 0))
        BUG(""register_all_submodule_odb_as_alternates() called"");
}
",,
implicit_predicate,submodule.c,190,+,-,"if (ret){
    string_list_clear(&added_submodule_odb_paths, 0);
    trace2_data_intmax(""submodule"", the_repository, ""register_all_submodule_odb_as_alternates/registered"", ret);
    if (git_env_bool(""GIT_TEST_FATAL_REGISTER_SUBMODULE_ODB"", 0))
        BUG(""register_all_submodule_odb_as_alternates() called"");
}
",,
implicit_predicate,submodule.c,226,-,+,,11,"		int v = git_config_bool(var, value) ?
			RECURSE_SUBMODULES_ON : RECURSE_SUBMODULES_OFF;"
implicit_predicate,submodule.c,236,+,-,"if (unset){
    config_update_recurse_submodules = RECURSE_SUBMODULES_OFF;
    return 0;
}
",,
implicit_predicate,submodule.c,237,+,-,"if (unset){
    config_update_recurse_submodules = RECURSE_SUBMODULES_OFF;
    return 0;
}
",,
implicit_predicate,submodule.c,621,+,+,"fast_backward ? "" (rewind)"" : """"",29,"		strbuf_addf(&sb, ""%s:\n"", fast_backward ? "" (rewind)"" : """");"
implicit_predicate,submodule.c,622,+,-,"fast_backward ? "" (rewind)"" : """"",,
implicit_predicate,submodule.c,649,+,-,"if (prepare_submodule_diff_summary(sub, &rev, path, left, right, merge_bases)){
    diff_emit_submodule_error(o, ""(revision walker failed)\n"");
    goto out;
}
",,
implicit_predicate,submodule.c,650,+,-,"if (prepare_submodule_diff_summary(sub, &rev, path, left, right, merge_bases)){
    diff_emit_submodule_error(o, ""(revision walker failed)\n"");
    goto out;
}
",,
implicit_predicate,submodule.c,1023,+,-,"if (has_commit.result){
    struct child_process cp = CHILD_PROCESS_INIT;
    struct strbuf out = STRBUF_INIT;
    strvec_pushl(&cp.args, ""rev-list"", ""-n"", ""1"", NULL);
    oid_array_for_each_unique(commits, append_oid_to_argv, &cp.args);
    strvec_pushl(&cp.args, ""--not"", ""--all"", NULL);
    prepare_submodule_repo_env(&cp.env);
    cp.git_cmd = 1;
    cp.no_stdin = 1;
    cp.dir = path;
    if (capture_command(&cp, &out, GIT_MAX_HEXSZ + 1) || out.len)
        has_commit.result = 0;

    strbuf_release(&out);
}
",,
implicit_predicate,submodule.c,1024,+,-,"if (has_commit.result){
    struct child_process cp = CHILD_PROCESS_INIT;
    struct strbuf out = STRBUF_INIT;
    strvec_pushl(&cp.args, ""rev-list"", ""-n"", ""1"", NULL);
    oid_array_for_each_unique(commits, append_oid_to_argv, &cp.args);
    strvec_pushl(&cp.args, ""--not"", ""--all"", NULL);
    prepare_submodule_repo_env(&cp.env);
    cp.git_cmd = 1;
    cp.no_stdin = 1;
    cp.dir = path;
    if (capture_command(&cp, &out, GIT_MAX_HEXSZ + 1) || out.len)
        has_commit.result = 0;

    strbuf_release(&out);
}
",,
implicit_predicate,submodule.c,1127,+,-,"if (submodule_needs_pushing(r, path, &cs_data->new_commits))
    string_list_insert(needs_pushing, path);
",,
implicit_predicate,submodule.c,1128,+,-,"if (submodule_needs_pushing(r, path, &cs_data->new_commits))
    string_list_insert(needs_pushing, path);
",,
implicit_predicate,submodule.c,1155,+,-,"if (dry_run)
    strvec_push(&cp.args, ""--dry-run"");
",,
implicit_predicate,submodule.c,1156,+,-,"if (dry_run)
    strvec_push(&cp.args, ""--dry-run"");
",,
implicit_predicate,submodule.c,1498,+,-,"if (p->free_sub)
    free((void*)p->sub);
",,
implicit_predicate,submodule.c,1499,+,-,"if (p->free_sub)
    free((void*)p->sub);
",,
implicit_predicate,submodule.c,1727,+,-,"if (spf->oid_fetch_tasks_nr){
    struct fetch_task* task = spf->oid_fetch_tasks[spf->oid_fetch_tasks_nr - 1];
    spf->oid_fetch_tasks_nr--;
    child_process_init(cp);
    prepare_submodule_repo_env_in_gitdir(&cp->env);
    cp->git_cmd = 1;
    cp->dir = task->repo->gitdir;
    strvec_init(&cp->args);
    strvec_pushv(&cp->args, spf->args.v);
    strvec_push(&cp->args, ""on-demand"");
    strvec_pushf(&cp->args, ""--submodule-prefix=%s%s/"", spf->prefix, task->sub->path);
    strvec_push(&cp->args, ""origin"");
    oid_array_for_each_unique(task->commits, append_oid_to_argv, &cp->args);
    *task_cb = task;
    return 1;
}
",,
implicit_predicate,submodule.c,1728,+,-,"if (spf->oid_fetch_tasks_nr){
    struct fetch_task* task = spf->oid_fetch_tasks[spf->oid_fetch_tasks_nr - 1];
    spf->oid_fetch_tasks_nr--;
    child_process_init(cp);
    prepare_submodule_repo_env_in_gitdir(&cp->env);
    cp->git_cmd = 1;
    cp->dir = task->repo->gitdir;
    strvec_init(&cp->args);
    strvec_pushv(&cp->args, spf->args.v);
    strvec_push(&cp->args, ""on-demand"");
    strvec_pushf(&cp->args, ""--submodule-prefix=%s%s/"", spf->prefix, task->sub->path);
    strvec_push(&cp->args, ""origin"");
    oid_array_for_each_unique(task->commits, append_oid_to_argv, &cp->args);
    *task_cb = task;
    return 1;
}
",,
implicit_predicate,submodule.c,1912,+,-,"if (ignore_untracked)
    strvec_push(&cp.args, ""-uno"");
",,
implicit_predicate,submodule.c,1913,+,-,"if (ignore_untracked)
    strvec_push(&cp.args, ""-uno"");
",,
implicit_predicate,submodule.c,2119,-,+,,9,"		     (super_prefix ? super_prefix : """"), path);"
implicit_predicate,submodule.c,2164,+,-,"if (submodule_has_dirty_index(sub))
    return error(_(""submodule '%s' has dirty index""), path);
",,
implicit_predicate,submodule.c,2165,+,-,"if (submodule_has_dirty_index(sub))
    return error(_(""submodule '%s' has dirty index""), path);
",,
implicit_predicate,submodule.c,2218,-,+,,9,"		     (super_prefix ? super_prefix : """"), path);"
implicit_predicate,submodule.c,2231,-,+,,25,"		strvec_push(&cp.args, old_head ? old_head : empty_tree_oid_hex());"
implicit_predicate,submodule.c,2233,-,+,,24,"	strvec_push(&cp.args, new_head ? new_head : empty_tree_oid_hex());"
implicit_predicate,submodule.c,2294,+,-,"for (;*p;p++){
    if (is_dir_sep(*p)){
        char c = *p;
        *p = '\0';
        if (is_git_directory(git_dir))
            ret = -1;

        *p = c;
        if (ret < 0)
            return error(_(""submodule git dir '%s' is inside git dir '%.*s'""), git_dir, (int)(p - git_dir), git_dir);
    }
}
",,
implicit_predicate,submodule.c,2295,+,-,"for (;*p;p++){
    if (is_dir_sep(*p)){
        char c = *p;
        *p = '\0';
        if (is_git_directory(git_dir))
            ret = -1;

        *p = c;
        if (ret < 0)
            return error(_(""submodule git dir '%s' is inside git dir '%.*s'""), git_dir, (int)(p - git_dir), git_dir);
    }
}
",,
implicit_predicate,submodule.c,2330,+,-,"if (ret)
    error(_(""expected '%.*s' in submodule path '%s' not to be a symbolic link""), i, p, p);
",,
implicit_predicate,submodule.c,2331,+,-,"if (ret)
    error(_(""expected '%.*s' in submodule path '%s' not to be a symbolic link""), i, p, p);
",,
implicit_predicate,submodule.c,2380,-,+,,3,"		super_prefix ? super_prefix : """", path,"
implicit_predicate,submodule.c,2405,-,+,,49,"	strvec_pushf(&cp.args, ""--super-prefix=%s%s/"", super_prefix ?
		     super_prefix : """", path);"
implicit_predicate,submodule.c,2554,+,-,"if (code)
    die(_(""ls-tree returned unexpected return code %d""), code);
",,
implicit_predicate,submodule.c,2555,+,-,"if (code)
    die(_(""ls-tree returned unexpected return code %d""), code);
",,
implicit_predicate,symbolic-ref.c,20,+,+,recurse ? 0 : RESOLVE_REF_NO_RECURSE,19,	resolve_flags = (recurse ? 0 : RESOLVE_REF_NO_RECURSE);
implicit_predicate,symbolic-ref.c,32,+,-,"if (print){
    char* to_free = NULL;
    if (shorten)
        refname = to_free = refs_shorten_unambiguous_ref(get_main_ref_store(the_repository), refname, 0);

    puts(refname);
    free(to_free);
}
",,
implicit_predicate,symbolic-ref.c,34,+,-,"if (shorten)
    refname = to_free = refs_shorten_unambiguous_ref(get_main_ref_store(the_repository), refname, 0);
",,
implicit_predicate,symlinks.c,144,+,-,"if (ret){
    *ret_flags = FL_LSTATERR;
    saved_errno = errno;
    if (errno == ENOENT)
        *ret_flags |= FL_NOENT;
}else
    if (S_ISDIR(st.st_mode)){
        last_slash_dir = last_slash;
        continue;
    }else
        if (S_ISLNK(st.st_mode)){
            *ret_flags = FL_SYMLINK;
        }else{
            *ret_flags = FL_ERR;
        }
",,
implicit_predicate,symlinks.c,188,+,-,"if (saved_errno)
    errno = saved_errno;
",,
implicit_predicate,symlinks.c,240,+,-,"if (flags & FL_NOENT)
    return 0;
else
    if (flags & FL_DIR)
        return -1;
",,
implicit_predicate,symlinks.c,242,+,-,"if (flags & FL_DIR)
    return -1;
",,
implicit_predicate,t-ctype.c,37,+,-,"TEST_CHAR_CLASS(isspace, "" \n\r\t"");
",,
implicit_predicate,t-ctype.c,38,+,-,"TEST_CHAR_CLASS(isdigit, DIGIT);
",,
implicit_predicate,t-ctype.c,39,+,-,"TEST_CHAR_CLASS(isalpha, LOWER UPPER);
",,
implicit_predicate,t-ctype.c,40,+,-,"TEST_CHAR_CLASS(isalnum, LOWER UPPER DIGIT);
",,
implicit_predicate,t-ctype.c,41,+,-,"TEST_CHAR_CLASS(is_glob_special, ""*?[\\"");
",,
implicit_predicate,t-ctype.c,42,+,-,"TEST_CHAR_CLASS(is_regex_special, ""$()*+.?[\\^{|"");
",,
implicit_predicate,t-ctype.c,43,+,-,"TEST_CHAR_CLASS(is_pathspec_magic, ""!\""#%&',-/:;<=>@_`~"");
",,
implicit_predicate,t-ctype.c,44,+,-,"TEST_CHAR_CLASS(isascii, ASCII);
",,
implicit_predicate,t-ctype.c,45,+,-,"TEST_CHAR_CLASS(islower, LOWER);
",,
implicit_predicate,t-ctype.c,46,+,-,"TEST_CHAR_CLASS(isupper, UPPER);
",,
implicit_predicate,t-ctype.c,47,+,-,"TEST_CHAR_CLASS(iscntrl, CNTRL);
",,
implicit_predicate,t-ctype.c,48,+,-,"TEST_CHAR_CLASS(ispunct, PUNCT);
",,
implicit_predicate,t-ctype.c,49,+,-,"TEST_CHAR_CLASS(isxdigit, DIGIT ""abcdefABCDEF"");
",,
implicit_predicate,t-ctype.c,50,+,-,"TEST_CHAR_CLASS(isprint, LOWER UPPER DIGIT PUNCT "" "");
",,
implicit_predicate,t-prio-queue.c,19,-,+,,9,	return v ? *v : MISSING;
implicit_predicate,tag.c,97,+,-,"if (fn(*p, ref.buf, &oid, cb_data))
    had_error = 1;
",,
implicit_predicate,tag.c,350,+,-,"if (should_edit){
    if (launch_editor(path, buf, NULL)){
        fprintf(stderr, _(""Please supply the message using either -m or -F option.\n""));
        exit(1);
    }
}else
    if (trailer_args->nr){
        strbuf_reset(buf);
        if (strbuf_read_file(buf, path, 0) < 0)
            die_errno(_(""failed to read '%s'""), path);
    }
",,
implicit_predicate,tag.c,563,+,+,cmdmode ? 0 : config_sign_tag > 0,14,		opt.sign = cmdmode ? 0 : config_sign_tag > 0;
implicit_predicate,tag.c,626,+,-,"if (msg.given)
    strbuf_addbuf(&buf, &(msg.buf));
else{
    if (!strcmp(msgfile, ""-"")){
        if (strbuf_read(&buf, 0, 1024) < 0)
            die_errno(_(""cannot read '%s'""), msgfile);
    }else{
        if (strbuf_read_file(&buf, msgfile, 1024) < 0)
            die_errno(_(""could not open or read '%s'""), msgfile);
    }
}
",,
implicit_predicate,tag.c,649,+,-,"if (strbuf_check_tag_ref(&ref, tag))
    die(_(""'%s' is not a valid tag name.""), tag);
",,
implicit_predicate,tag.c,671,+,-,"if (create_tag_object){
    if (force_sign_annotate && !annotate)
        opt.sign = 1;

    path = git_pathdup(""TAG_EDITMSG"");
    create_tag(&object, object_ref, tag, &buf, &opt, &prev, &object, &trailer_args, path);
}
",,
implicit_predicate,tag.c,684,+,+,create_reflog ? REF_FORCE_CREATE_REFLOG : 0,8,"				   create_reflog ? REF_FORCE_CREATE_REFLOG : 0,"
implicit_predicate,tempfile.c,57,+,-,"if (in_signal_handler)
    return rmdir(tempfile->directory);
else
    return rmdir_or_warn(tempfile->directory);
",,
implicit_predicate,tempfile.c,80,+,-,"if (in_signal_handler)
    unlink(p->filename.buf);
else
    unlink_or_warn(p->filename.buf);
",,
implicit_predicate,tempfile.c,321,+,+,err ? -1 : 0,9,	return err ? -1 : 0;
implicit_predicate,tempfile.c,341,+,-,"if (close_tempfile_gently(tempfile)){
    delete_tempfile(tempfile_p);
    return -1;
}
",,
implicit_predicate,tempfile.c,372,+,+,err ? -1 : 0,9,
implicit_predicate,terminal.c,148,-,+,,14,"		term_fd = ((flags & SAVE_TERM_STDIN)
			   ? 0
			   : open(""/dev/tty"", O_RDWR));"
implicit_predicate,terminal.c,489,-,+,,30,"	return strcmp(e1->sequence, keydata ? keydata : e2->sequence);"
implicit_predicate,test-cache-tree.c,45,+,-,"if (empty){
    cache_tree_free(&the_repository->index->cache_tree);
    the_repository->index->cache_tree = cache_tree();
}else
    if (invalidate_qty){
        float f_interval = (float)the_repository->index->cache_nr / invalidate_qty;
        int interval = f_interval < 1.0 ? 1 : (int)f_interval;
        for (i = 0;i < invalidate_qty && i * interval < the_repository->index->cache_nr;i++)
            cache_tree_invalidate_path(the_repository->index, the_repository->index->cache[i * interval]->name);
    }
",,
implicit_predicate,test-cache-tree.c,49,+,-,"if (invalidate_qty){
    float f_interval = (float)the_repository->index->cache_nr / invalidate_qty;
    int interval = f_interval < 1.0 ? 1 : (int)f_interval;
    for (i = 0;i < invalidate_qty && i * interval < the_repository->index->cache_nr;i++)
        cache_tree_invalidate_path(the_repository->index, the_repository->index->cache[i * interval]->name);
}
",,
implicit_predicate,test-chmtime.c,51,+,-,"if (*set_eq){
    timespec++;
    if (*timespec == '+'){
        *set_eq = 2;
        timespec++;
    }
}
",,
implicit_predicate,test-chmtime.c,59,+,-,"if (*test){
    return 0;
}
",,
implicit_predicate,test-chmtime.c,94,+,-,"if (timespec_arg(argv[i], &set_time, &set_eq)){
    ++i;
}else{
    if (get == 0 && verbose == 0){
        fprintf(stderr, ""Not a base-10 integer: %s\n"", argv[i] + 1);
        goto usage;
    }
}
",,
implicit_predicate,test-chmtime.c,127,+,+,set_eq ? set_time : sb.st_mtime + set_time,17,		utb.modtime = set_eq ? set_time : sb.st_mtime + set_time;
implicit_predicate,test-chmtime.c,130,+,-,<!!!>,,
implicit_predicate,test-chmtime.c,132,+,-,<!!!>,,
implicit_predicate,test-config.c,56,-,+,,23,"	printf(""value=%s\n"", value ? value : ""(null)"");"
implicit_predicate,test-config.c,58,-,+,,22,"	printf(""name=%s\n"", kvi->filename ? kvi->filename : """");"
implicit_predicate,test-csprng.c,17,+,-,"while (count){
    unsigned long chunk = count < sizeof (buf) ? count : sizeof (buf);
    if (csprng_bytes(buf, chunk) < 0){
        perror(""failed to read"");
        return 5;
    }
    if (fwrite(buf, chunk, 1, stdout) != chunk)
        return 1;

    count -= chunk;
}
",,
implicit_predicate,test-dump-fsmonitor.c,21,-,+,,10,"		printf((istate->cache[i]->ce_flags & CE_FSMONITOR_VALID) ? ""+"" : ""-"");"
implicit_predicate,test-env-helper.c,76,+,+,"ret_int ? ""true"" : ""false""",9,"			puts(ret_int ? ""true"" : ""false"");"
implicit_predicate,test-genrandom.c,21,+,-,"do{
    next = next * 11 + *c;
} while (*c++);
",,
implicit_predicate,test-genrandom.c,27,+,-,"while (count--){
    next = next * 1103515245 + 12345;
    if (putchar((next >> 16) & 0xff) == EOF)
        return -1;
}
",,
implicit_predicate,test-hash.c,32,+,-,"while (1){
    ssize_t sz, this_sz;
    char* cp = buffer;
    unsigned room = bufsz;
    this_sz = 0;
    while (room){
        sz = xread(0, cp, room);
        if (sz == 0)
            break;

        if (sz < 0)
            die_errno(""test-hash"");

        this_sz += sz;
        cp += sz;
        room -= sz;
    }
    if (this_sz == 0)
        break;

    algop->update_fn(&ctx, buffer, this_sz);
}
",,
implicit_predicate,test-hash.c,37,+,-,"while (room){
    sz = xread(0, cp, room);
    if (sz == 0)
        break;

    if (sz < 0)
        die_errno(""test-hash"");

    this_sz += sz;
    cp += sz;
    room -= sz;
}
",,
implicit_predicate,test-hash.c,53,+,-,"if (binary)
    fwrite(hash, 1, algop->rawsz, stdout);
else
    puts(hash_to_hex_algop(hash, algop));
",,
implicit_predicate,test-hashmap.c,25,-,+,,26,	const int ignore_case = cmp_data ? *((int *)cmp_data) : 0;
implicit_predicate,test-hashmap.c,33,-,+,,30,"		return strcasecmp(e1->key, key ? key : e2->key);"
implicit_predicate,test-hashmap.c,35,-,+,,26,"		return strcmp(e1->key, key ? key : e2->key);"
implicit_predicate,test-hashmap.c,78,+,-,"if (method & HASH_METHOD_X2)
    hash = 2 * hash;
",,
implicit_predicate,test-hashmap.c,103,+,-,"if (method & TEST_ADD){
    for (j = 0;j < rounds;j++){
        hashmap_init(&map, test_entry_cmp, NULL, 0);
        for (i = 0;i < TEST_SIZE;i++){
            hashmap_entry_init(&entries[i]->ent, hashes[i]);
            hashmap_add(&map, &entries[i]->ent);
        }
        hashmap_clear(&map);
    }
}else{
    hashmap_init(&map, test_entry_cmp, NULL, 0);
    j = (method & TEST_SPARSE) ? TEST_SIZE / 10 : TEST_SIZE;
    for (i = 0;i < j;i++){
        hashmap_entry_init(&entries[i]->ent, hashes[i]);
        hashmap_add(&map, &entries[i]->ent);
    }
    for (j = 0;j < rounds;j++){
        for (i = 0;i < TEST_SIZE;i++){
            hashmap_get_from_hash(&map, hashes[i], entries[i]->key);
        }
    }
    hashmap_clear(&map);
}
",,
implicit_predicate,test-hashmap.c,121,+,+,(method & TEST_SPARSE) ? TEST_SIZE / 10 : TEST_SIZE,7,		j = (method & TEST_SPARSE) ? TEST_SIZE / 10 : TEST_SIZE;
implicit_predicate,test-hashmap.c,183,+,+,icase ? strihash(p1) : strhash(p1),11,			hash = icase ? strihash(p1) : strhash(p1);
implicit_predicate,test-hashmap.c,202,-,+,,9,"			puts(entry ? get_value(entry) : ""NULL"");"
implicit_predicate,test-hashmap.c,225,-,+,,12,"			entry = rm ? container_of(rm, struct test_entry, ent)
					: NULL;"
implicit_predicate,test-hashmap.c,229,-,+,,9,"			puts(entry ? get_value(entry) : ""NULL"");"
implicit_predicate,test-json-writer.c,347,+,-,"t(obj1);
",,
implicit_predicate,test-json-writer.c,348,+,-,"t(obj2);
",,
implicit_predicate,test-json-writer.c,349,+,-,"t(obj3);
",,
implicit_predicate,test-json-writer.c,350,+,-,"t(obj4);
",,
implicit_predicate,test-json-writer.c,351,+,-,"t(obj5);
",,
implicit_predicate,test-json-writer.c,352,+,-,"t(obj6);
",,
implicit_predicate,test-json-writer.c,354,+,-,"t(arr1);
",,
implicit_predicate,test-json-writer.c,355,+,-,"t(arr2);
",,
implicit_predicate,test-json-writer.c,356,+,-,"t(arr3);
",,
implicit_predicate,test-json-writer.c,357,+,-,"t(arr4);
",,
implicit_predicate,test-json-writer.c,359,+,-,"t(nest1);
",,
implicit_predicate,test-json-writer.c,361,+,-,"t(inline1);
",,
implicit_predicate,test-json-writer.c,362,+,-,"t(inline2);
",,
implicit_predicate,test-json-writer.c,378,+,-,"p(obj1);
",,
implicit_predicate,test-json-writer.c,379,+,-,"p(obj2);
",,
implicit_predicate,test-json-writer.c,380,+,-,"p(obj3);
",,
implicit_predicate,test-json-writer.c,381,+,-,"p(obj4);
",,
implicit_predicate,test-json-writer.c,383,+,-,"p(arr1);
",,
implicit_predicate,test-json-writer.c,384,+,-,"p(arr2);
",,
implicit_predicate,test-json-writer.c,385,+,-,"p(arr3);
",,
implicit_predicate,test-json-writer.c,386,+,-,"p(arr4);
",,
implicit_predicate,test-json-writer.c,388,+,-,"p(inline1);
",,
implicit_predicate,test-json-writer.c,389,+,-,"p(inline2);
",,
implicit_predicate,test-json-writer.c,392,+,-,"t(mixed1);
",,
implicit_predicate,test-json-writer.c,393,+,-,"p(mixed1);
",,
implicit_predicate,test-lazy-init-name-hash.c,41,+,-,"if (single){
    test_lazy_init_name_hash(the_repository->index, 0);
}else{
    int nr_threads_used = test_lazy_init_name_hash(the_repository->index, 1);
    if (!nr_threads_used)
        die(""non-threaded code path used"");
}
",,
implicit_predicate,test-lazy-init-name-hash.c,84,+,-,"if (nr_threads_used)
    printf(""%f %f %d multi %d\n"", ((double)(t1 - t0)) / 1000000000, ((double)(t2 - t1)) / 1000000000, the_repository->index->cache_nr, nr_threads_used);
else
    printf(""%f %f %d single\n"", ((double)(t1 - t0)) / 1000000000, ((double)(t2 - t1)) / 1000000000, the_repository->index->cache_nr);
",,
implicit_predicate,test-lazy-init-name-hash.c,104,+,+,"(try_threaded) ? ""multi"" : ""single""",7,"			   (try_threaded) ? ""multi"" : ""single"");"
implicit_predicate,test-lazy-init-name-hash.c,126,+,-,"while (1){
    uint64_t sum_single = 0;
    uint64_t sum_multi = 0;
    uint64_t avg_single;
    uint64_t avg_multi;
    if (nr > cache_nr_limit)
        nr = cache_nr_limit;

    for (i = 0;i < count;i++){
        repo_read_index(the_repository);
        the_repository->index->cache_nr = nr;
        t1s = getnanotime();
        test_lazy_init_name_hash(the_repository->index, 0);
        t2s = getnanotime();
        sum_single += (t2s - t1s);
        the_repository->index->cache_nr = cache_nr_limit;
        discard_index(the_repository->index);
        repo_read_index(the_repository);
        the_repository->index->cache_nr = nr;
        t1m = getnanotime();
        nr_threads_used = test_lazy_init_name_hash(the_repository->index, 1);
        t2m = getnanotime();
        sum_multi += (t2m - t1m);
        the_repository->index->cache_nr = cache_nr_limit;
        discard_index(the_repository->index);
        if (!nr_threads_used)
            printf(""    [size %8d] [single %f]   non-threaded code path used\n"", nr, ((double)(t2s - t1s)) / 1000000000);
        else
            printf(""    [size %8d] [single %f] %c [multi %f %d]\n"", nr, ((double)(t2s - t1s)) / 1000000000, (((t2s - t1s) < (t2m - t1m)) ? '<' : '>'), ((double)(t2m - t1m)) / 1000000000, nr_threads_used);

        fflush (stdout);
    }
    if (count > 1){
        avg_single = sum_single / count;
        avg_multi = sum_multi / count;
        if (!nr_threads_used)
            printf(""avg [size %8d] [single %f]\n"", nr, (double)avg_single / 1000000000);
        else
            printf(""avg [size %8d] [single %f] %c [multi %f %d]\n"", nr, (double)avg_single / 1000000000, (avg_single < avg_multi ? '<' : '>'), (double)avg_multi / 1000000000, nr_threads_used);

        fflush (stdout);
    }
    if (nr >= cache_nr_limit)
        return;

    nr += analyze_step;
}
",,
implicit_predicate,test-lazy-init-name-hash.c,221,+,-,"if (dump){
    if (perf || analyze > 0)
        die(""cannot combine dump, perf, or analyze"");

    if (count > 1)
        die(""count not valid with dump"");

    if (single && multi)
        die(""cannot use both single and multi with dump"");

    if (!single && !multi)
        die(""dump requires either single or multi"");

    dump_run();
    return 0;
}
",,
implicit_predicate,test-lazy-init-name-hash.c,234,+,-,"if (perf){
    if (analyze > 0)
        die(""cannot combine dump, perf, or analyze"");

    if (single || multi)
        die(""cannot use single or multi with perf"");

    avg_single = time_runs(0);
    avg_multi = time_runs(1);
    if (avg_multi > avg_single)
        die(""multi is slower"");

    return 0;
}
",,
implicit_predicate,test-lazy-init-name-hash.c,246,+,-,"if (analyze){
    if (analyze < 500)
        die(""analyze must be at least 500"");

    if (!analyze_step)
        analyze_step = analyze;

    if (single || multi)
        die(""cannot use single or multi with analyze"");

    analyze_run();
    return 0;
}
",,
implicit_predicate,test-lazy-init-name-hash.c,260,+,-,"if (single)
    time_runs(0);
",,
implicit_predicate,test-lazy-init-name-hash.c,262,+,-,"if (multi)
    time_runs(1);
",,
implicit_predicate,test-lib.c,91,+,-,"for (p = buf;*p;p++)
    if (*p == '\\')
        *p = '/';
",,
implicit_predicate,test-lib.c,130,+,-,"if (ctx.lazy_plan)
    test_plan(ctx.count);
",,
implicit_predicate,test-lib.c,275,+,-,"if (ok){
    test_pass();
}else{
    test_msg(""check \""%s\"" failed at %s"", check, make_relative(location));
    test_fail();
}
",,
implicit_predicate,test-lib.c,303,+,-,"if (res){
    test_msg(""todo check '%s' succeeded at %s"", check, make_relative(location));
    test_fail();
}else{
    test_todo();
}
",,
implicit_predicate,test-mergesort.c,370,+,-,"while (argc--){
    int i, j, m, n = strtol(*argv++, NULL, 10);
    for (i = 0;i < ARRAY_SIZE(dist);i++){
        for (j = 0;j < ARRAY_SIZE(mode);j++){
            for (m = 1;m < 2 * n;m *= 2){
                if (test(&dist[i], &mode[j], n, m))
                    return 1;
            }
        }
    }
}
",,
implicit_predicate,test-mergesort.c,375,+,-,"if (test(&dist[i], &mode[j], n, m))
    return 1;
",,
implicit_predicate,test-oidmap.c,75,-,+,,9,"			puts(entry ? entry->name : ""NULL"");"
implicit_predicate,test-oidmap.c,89,-,+,,9,"			puts(entry ? entry->name : ""NULL"");"
implicit_predicate,test-oidmap.c,102,-,+,,9,"			puts(entry ? entry->name : ""NULL"");"
implicit_predicate,test-parse-options.c,26,+,-,"if (unset)
    *(int*)opt->value = 0;
else
    if (!strcmp(arg, ""3""))
        *(int*)opt->value = 3;
    else
        if (!strcmp(arg, ""4""))
            *(int*)opt->value = 4;
        else
            return error(""invalid value for '%s': '%s'"", ""--mode34"", arg);
",,
implicit_predicate,test-parse-options.c,43,+,-,"if (unset)
    return 1;
",,
implicit_predicate,test-parse-options.c,184,+,-,"if (length_cb.called){
    const char* arg = length_cb.arg;
    int unset = length_cb.unset;
    show(&expect, &ret, ""Callback: \""%s\"", %d"", (arg ? arg : ""not set""), unset);
}
",,
implicit_predicate,test-parse-options.c,188,-,+,,9,"		     (arg ? arg : ""not set""), unset);"
implicit_predicate,test-parse-options.c,194,-,+,,36,"	show(&expect, &ret, ""string: %s"", string ? string : ""(not set)"");"
implicit_predicate,test-parse-options.c,198,+,+,"dry_run ? ""yes"" : ""no""",37,"	show(&expect, &ret, ""dry run: %s"", dry_run ? ""yes"" : ""no"");"
implicit_predicate,test-parse-options.c,199,-,+,,34,"	show(&expect, &ret, ""file: %s"", file ? file : ""(not set)"");"
implicit_predicate,test-path-utils.c,192,+,-,"expect ? ""not "" : """"",,
implicit_predicate,test-path-utils.c,195,+,+,"expect ? """" : ""not """,12,"				*argv, expect ? """" : ""not "", x);"
implicit_predicate,test-path-utils.c,306,+,+,"rv ? ""++failed++"" : buf",8,"		puts(rv ? ""++failed++"" : buf);"
implicit_predicate,test-path-utils.c,377,-,+,,18,"		printf(""%s\n"", prefix ? prefix : ""(null)"");"
implicit_predicate,test-path-utils.c,495,+,-,"expect ? "" not"" : """"",,
implicit_predicate,test-path-utils.c,499,+,+,"expect ? """" : "" not""",15,"					argv[i], expect ? """" : "" not"");"
implicit_predicate,test-path-utils.c,507,+,-,"if (ret)
    printf(""equal\n"");
else
    printf(""different\n"");
",,
implicit_predicate,test-path-utils.c,515,-,+,,3,"		argv[1] ? argv[1] : ""(there was none)"");"
implicit_predicate,test-pkt-line.c,20,+,-,"if (argc){
    int i;
    for (i = 0;i < argc;i++)
        pack_line(argv[i]);
}else{
    char line[LARGE_PACKET_MAX];
    while (fgets(line, sizeof (line), stdin)){
        pack_line(line);
    }
}
",,
implicit_predicate,test-pkt-line.c,92,+,-,"if (chomp_newline)
    options |= PACKET_READ_CHOMP_NEWLINE;
",,
implicit_predicate,test-proc-receive.c,40,+,-,"if (die_read_version)
    die(""die with the --die-read-version option"");
",,
implicit_predicate,test-proc-receive.c,68,+,-,"if (die_write_version)
    die(""die with the --die-write-version option"");
",,
implicit_predicate,test-proc-receive.c,92,+,-,"if (die_read_commands)
    die(""die with the --die-read-commands option"");
",,
implicit_predicate,test-proc-receive.c,118,+,-,"if (die_read_push_options)
    die(""die with the --die-read-push-options option"");
",,
implicit_predicate,test-proc-receive.c,121,+,-,"while (1){
    if (packet_reader_read(reader) != PACKET_READ_NORMAL)
        break;

    string_list_append(options, reader->line);
}
",,
implicit_predicate,test-proc-receive.c,171,+,-,<!!!>,,
implicit_predicate,test-proc-receive.c,176,+,+,"use_atomic ? "" atomic"" : """"",5,"				use_atomic? "" atomic"": """","
implicit_predicate,test-proc-receive.c,177,+,+,"use_push_options ? "" push_options"" : """"",5,"				use_push_options ? "" push_options"": """");"
implicit_predicate,test-proc-receive.c,194,+,-,"if (die_write_report)
    die(""die with the --die-write-report option"");
",,
implicit_predicate,test-progress.c,43,+,-,"if (argc)
    usage_with_options(usage, options);
",,
implicit_predicate,test-read-midx.c,50,+,-,<!!!>,,
implicit_predicate,test-ref-store.c,80,+,-,"if (ret)
    die(""strbuf_git_path_submodule failed: %d"", ret);
",,
implicit_predicate,test-ref-store.c,189,-,+,,43,"	printf(""%s %s 0x%x\n"", oid_to_hex(&oid), ref ? ref : ""(null)"", flags);"
implicit_predicate,test-ref-store.c,190,-,+,,9,	return ref ? 0 : 1;
implicit_predicate,test-regex.c,90,+,-,"if (ret){
    if (silent)
        return ret;

    regerror(ret, &r, errbuf, sizeof (errbuf));
    die(""failed regcomp() for pattern '%s' (%s)"", pat, errbuf);
}
",,
implicit_predicate,test-regex.c,91,+,-,"if (silent)
    return ret;
",,
implicit_predicate,test-regex.c,101,+,-,"if (ret){
    if (silent || ret == REG_NOMATCH)
        goto cleanup;

    regerror(ret, &r, errbuf, sizeof (errbuf));
    die(""failed regexec() for subject '%s' (%s)"", str, errbuf);
}
",,
implicit_predicate,test-rot13-filter.c,51,-,+,,9,"	return str ? str : ""(null)"";"
implicit_predicate,test-rot13-filter.c,57,+,-,"for (c = str;*c;c++)
    if (isalpha(*c))
        *c += tolower(*c) < 'n' ? 13 : -13;
",,
implicit_predicate,test-run-command.c,87,+,-,"if (suite->quiet)
    strvec_push(&cp->args, ""--quiet"");
",,
implicit_predicate,test-run-command.c,89,+,-,"if (suite->immediate)
    strvec_push(&cp->args, ""-i"");
",,
implicit_predicate,test-run-command.c,91,+,-,"if (suite->verbose)
    strvec_push(&cp->args, ""-v"");
",,
implicit_predicate,test-run-command.c,93,+,-,"if (suite->verbose_log)
    strvec_push(&cp->args, ""-V"");
",,
implicit_predicate,test-run-command.c,95,+,-,"if (suite->trace)
    strvec_push(&cp->args, ""-x"");
",,
implicit_predicate,test-run-command.c,97,+,-,"if (suite->write_junit_xml)
    strvec_push(&cp->args, ""--write-junit-xml"");
",,
implicit_predicate,test-run-command.c,112,+,-,"if (result)
    string_list_append(&suite->failed, name);
",,
implicit_predicate,test-run-command.c,115,+,+,"result ? ""FAIL"" : ""SUCCESS""",33,"	strbuf_addf(err, ""%s: '%s'\n"", result ? ""FAIL"" : ""SUCCESS"", name);"
implicit_predicate,test-run-command.c,273,+,-,"if (msys2)
    strvec_pushl(&args, ""sh"", ""-c"", ""printf %s\\\\0 \""$@\"""", ""skip"", NULL);
else
    strvec_pushl(&args, ""test-tool"", ""run-command"", ""quote-echo"", NULL);
",,
implicit_predicate,test-run-command.c,325,+,-,"if (ret){
    fprintf(stderr, ""Trial #%d failed. Arguments:\n"", i);
    for (j = 0;j < arg_count;j++)
        fprintf(stderr, ""arg #%d: '%s'\n"", (int)j, args.v[j + arg_offset]);
    strbuf_release(&out);
    strvec_clear(&args);
    return ret;
}
",,
implicit_predicate,test-serve-v2.c,30,+,-,"if (advertise_capabilities)
    protocol_v2_advertise_capabilities();
else
    protocol_v2_serve_loop(stateless_rpc);
",,
implicit_predicate,test-string-list.c,127,-,+,,3,"		argv[1] ? argv[1] : ""(there was none)"");"
implicit_predicate,test-submodule-config.c,51,+,-,"if (lookup_name){
    submodule = submodule_from_name(the_repository, &commit_oid, path_or_name);
}else
    submodule = submodule_from_path(the_repository, &commit_oid, path_or_name);
",,
implicit_predicate,test-submodule.c,71,+,-,"if (argc)
    usage_with_options(submodule_check_name_usage, options);
",,
implicit_predicate,test-submodule.c,84,+,-,"if (argc)
    usage_with_options(submodule_check_url_usage, options);
",,
implicit_predicate,test-submodule.c,206,-,+,,10,		return is_writing_gitmodules_ok() ? 0 : -1;
implicit_predicate,test-subprocess.c,11,+,-,"if (nogit)
    die(""No git repo found"");
",,
implicit_predicate,test-trace2.c,191,+,-,"while (argc){
    if (!argv[0] || !*argv[0] || !argv[1] || !*argv[1] || !argv[2] || !*argv[2])
        die(""%s"", usage_error);

    trace2_data_string(argv[0], the_repository, argv[1], argv[2]);
    argv += 3;
    argc -= 3;
}
",,
implicit_predicate,test-trace2.c,251,+,-,"if (get_i(&count, argv[0]))
    die(""%s"", usage_error);
",,
implicit_predicate,test-trace2.c,253,+,-,"if (get_i(&delay, argv[1]))
    die(""%s"", usage_error);
",,
implicit_predicate,test-trace2.c,305,+,-,"if (get_i(&data.count, argv[0]))
    die(""%s"", usage_error);
",,
implicit_predicate,test-trace2.c,307,+,-,"if (get_i(&data.delay, argv[1]))
    die(""%s"", usage_error);
",,
implicit_predicate,test-trace2.c,309,+,-,"if (get_i(&nr_threads, argv[2]))
    die(""%s"", usage_error);
",,
implicit_predicate,test-trace2.c,345,+,-,"if (get_i(&value, argv[k]))
    die(""invalid value[%s] -- %s"", argv[k], usage_error);
",,
implicit_predicate,test-trace2.c,391,+,-,"if (get_i(&data.v1, argv[0]))
    die(""%s"", usage_error);
",,
implicit_predicate,test-trace2.c,393,+,-,"if (get_i(&data.v2, argv[1]))
    die(""%s"", usage_error);
",,
implicit_predicate,test-trace2.c,395,+,-,"if (get_i(&nr_threads, argv[2]))
    die(""%s"", usage_error);
",,
implicit_predicate,test-trace2.c,547,+,-,"if (argc)
    for_each_ut (k, ut_k)
			if (!strcmp(argv[0], ut_k->ut_name))
				return ut_k->ut_fn(argc - 1, argv + 1);
",,
implicit_predicate,test-truncate.c,17,+,-,"if (*p)
    die(""invalid size"");
",,
implicit_predicate,test-urlmatch-normalization.c,39,+,-,"if (opt_p)
    printf(""%s\n"", url1);
",,
implicit_predicate,test-urlmatch-normalization.c,41,+,-,"if (opt_l)
    printf(""%u\n"", (unsigned )info.url_len);
",,
implicit_predicate,tr2_cfg.c,26,+,-,"if (tr2_cfg_loaded)
    return tr2_cfg_count_patterns;
",,
implicit_predicate,tr2_cfg.c,65,+,-,"if (tr2_cfg_env_vars_loaded)
    return tr2_cfg_env_vars_count;
",,
implicit_predicate,tr2_dst.c,149,+,-,"if (tr2_dst_want_warning())
    warning(""trace2: not opening %s trace file due to too many files in target directory %s"", tr2_sysenv_display_name(dst->sysenv_var), tgt_prefix);
",,
implicit_predicate,tr2_dst.c,158,+,-,"if (tr2_dst_want_warning())
    warning(""trace2: could not open '%.*s' for '%s' tracing: %s"", (int)base_path_len, path.buf, tr2_sysenv_display_name(dst->sysenv_var), strerror(errno));
",,
implicit_predicate,tr2_dst.c,181,+,-,"if (tr2_dst_want_warning())
    warning(""trace2: could not open '%s' for '%s' tracing: %s"", tgt_value, tr2_sysenv_display_name(dst->sysenv_var), strerror(errno));
",,
implicit_predicate,tr2_dst.c,257,+,-,"if (tr2_dst_want_warning())
    warning(""trace2: invalid AF_UNIX value '%s' for '%s' tracing"", tgt_value, tr2_sysenv_display_name(dst->sysenv_var));
",,
implicit_predicate,tr2_dst.c,268,+,-,"if (tr2_dst_want_warning())
    warning(""trace2: invalid AF_UNIX path '%s' for '%s' tracing"", path, tr2_sysenv_display_name(dst->sysenv_var));
",,
implicit_predicate,tr2_dst.c,276,+,-,"if (uds_try & TR2_DST_UDS_TRY_STREAM){
    if (!tr2_dst_try_uds_connect(path, SOCK_STREAM, &fd))
        goto connected;

    if (errno != EPROTOTYPE)
        goto error;
}
",,
implicit_predicate,tr2_dst.c,282,+,-,"if (uds_try & TR2_DST_UDS_TRY_DGRAM){
    if (!tr2_dst_try_uds_connect(path, SOCK_DGRAM, &fd))
        goto connected;
}
",,
implicit_predicate,tr2_dst.c,288,+,-,"if (tr2_dst_want_warning())
    warning(""trace2: could not connect to socket '%s' for '%s' tracing: %s"", path, tr2_sysenv_display_name(dst->sysenv_var), strerror(errno));
",,
implicit_predicate,tr2_dst.c,392,+,-,"if (tr2_dst_want_warning())
    warning(""unable to write trace to '%s': %s"", tr2_sysenv_display_name(dst->sysenv_var), strerror(errno));
",,
implicit_predicate,tr2_tgt_event.c,352,-,+,,4,"			cmd->trace2_child_class ? cmd->trace2_child_class : ""?"";"
implicit_predicate,tr2_tgt_event.c,629,+,+,"is_final_data ? ""timer"" : ""th_timer""",27,"	const char *event_name = is_final_data ? ""timer"" : ""th_timer"";"
implicit_predicate,tr2_tgt_event.c,653,+,+,"is_final_data ? ""counter"" : ""th_counter""",27,"	const char *event_name = is_final_data ? ""counter"" : ""th_counter"";"
implicit_predicate,tr2_tgt_normal.c,343,+,+,"is_final_data ? ""timer"" : ""th_timer""",27,"	const char *event_name = is_final_data ? ""timer"" : ""th_timer"";"
implicit_predicate,tr2_tgt_normal.c,364,+,+,"is_final_data ? ""counter"" : ""th_counter""",27,"	const char *event_name = is_final_data ? ""counter"" : ""th_counter"";"
implicit_predicate,tr2_tgt_perf.c,136,-,+,,36,"		    TR2FMT_PERF_CATEGORY_WIDTH, (category ? category : """"));"
implicit_predicate,tr2_tgt_perf.c,329,-,+,,4,"			cmd->trace2_child_class ? cmd->trace2_child_class : ""?"";"
implicit_predicate,tr2_tgt_perf.c,564,+,+,"is_final_data ? ""timer"" : ""th_timer""",27,"	const char *event_name = is_final_data ? ""timer"" : ""th_timer"";"
implicit_predicate,tr2_tgt_perf.c,586,+,+,"is_final_data ? ""counter"" : ""th_counter""",27,"	const char *event_name = is_final_data ? ""counter"" : ""th_counter"";"
implicit_predicate,trace.c,44,-,+,,10,	trace = override_envvar ? override_envvar : getenv(key->key);
implicit_predicate,trace.c,264,+,-,"if (perf_indent)
    perf_indent--;
",,
implicit_predicate,trace2.c,220,+,-,"if (trace2_enabled)
    return;
",,
implicit_predicate,trace2.c,312,-,+,,12,		ret[i] = redacted ? redacted : argv[i];
implicit_predicate,trace2.c,475,+,-,"if (emitted)
    return;
",,
implicit_predicate,trace2.c,489,+,-,"if (emitted)
    return;
",,
implicit_predicate,trace2_win32_process_info.c,84,+,-,"if (nr_pids)
    jw_array_string(jw, pe32.szExeFile);
",,
implicit_predicate,trailer.c,183,+,-,"if (aoe)
    list_add(&to_add->list, &on_tok->list);
else
    list_add_tail(&to_add->list, &on_tok->list);
",,
implicit_predicate,trailer.c,196,+,-,<!!!>,,
implicit_predicate,trailer.c,197,+,-,"if (same_trailer(in_tok, arg_tok))
    return 0;
",,
implicit_predicate,trailer.c,203,-,+,,15,"		next_head = after_or_end(where) ? in_tok->list.prev
						: in_tok->list.next;"
implicit_predicate,trailer.c,285,+,-,"if (check_if_different(in_tok, arg_tok, 1, head))
    add_arg_to_input_list(on_tok, arg_tok);
else
    free_arg_item(arg_tok);
",,
implicit_predicate,trailer.c,292,+,-,"if (check_if_different(on_tok, arg_tok, 0, head))
    add_arg_to_input_list(on_tok, arg_tok);
else
    free_arg_item(arg_tok);
",,
implicit_predicate,trailer.c,351,+,+,middle ? in_tok : start_tok,12,		on_tok = middle ? in_tok : start_tok;
implicit_predicate,trailer.c,583,+,-,"if (configured)
    return;
",,
implicit_predicate,trailer.c,608,-,+,,9,"	return item->conf.key ? !strncasecmp(tok, item->conf.key, tok_len) : 0;"
implicit_predicate,trailer.c,865,+,-,"if (is_blank_line(s))
    break;
",,
implicit_predicate,trailer.c,888,+,-,"if (is_blank_line(bol)){
    if (only_spaces)
        continue;

    non_trailer_lines += possible_continuation_lines;
    if (recognized_prefix && trailer_lines * 3 >= non_trailer_lines)
        return next_line(bol) - buf;
    else
        if (trailer_lines && !non_trailer_lines)
            return next_line(bol) - buf;

    return len;
}
",,
implicit_predicate,trailer.c,889,+,-,"if (only_spaces)
    continue;
",,
implicit_predicate,trailer.c,916,+,-,"if (recognized_prefix)
    continue;
",,
implicit_predicate,transport-helper.c,63,+,-,"if (debug)
    fprintf(stderr, ""Debug: Remote helper: -> %s"", buffer->buf);
",,
implicit_predicate,transport-helper.c,72,+,-,"if (debug)
    fprintf(stderr, ""Debug: Remote helper: Waiting...\n"");
",,
implicit_predicate,transport-helper.c,75,+,-,"if (debug)
    fprintf(stderr, ""Debug: Remote helper quit.\n"");
",,
implicit_predicate,transport-helper.c,80,+,-,"if (debug)
    fprintf(stderr, ""Debug: Remote helper: <- %s\n"", buffer->buf);
",,
implicit_predicate,transport-helper.c,92,+,-,"if (debug)
    fprintf(stderr, ""Debug: Remote helper: -> %s"", str);
",,
implicit_predicate,transport-helper.c,170,+,-,<!!!>,,
implicit_predicate,transport-helper.c,173,+,-,"if (recvline(data, &buf))
    exit(128);
",,
implicit_predicate,transport-helper.c,185,+,-,"if (debug)
    fprintf(stderr, ""Debug: Got cap %s\n"", capname);
",,
implicit_predicate,transport-helper.c,227,+,-,"if (debug)
    fprintf(stderr, ""Debug: Capabilities complete.\n"");
",,
implicit_predicate,transport-helper.c,239,+,-,"if (debug)
    fprintf(stderr, ""Debug: Disconnecting.\n"");
",,
implicit_predicate,transport-helper.c,281,+,-,"if (recvline(data, buf))
    exit(128);
",,
implicit_predicate,transport-helper.c,309,+,-,"if ((ret = strbuf_set_helper_option(data, &buf)))
    break;
",,
implicit_predicate,transport-helper.c,346,+,-,"if (is_bool)
    strbuf_addstr(&buf, value ? ""true"" : ""false"");
else
    quote_c_style(value, &buf, NULL, 0);
",,
implicit_predicate,transport-helper.c,347,-,+,,23,"		strbuf_addstr(&buf, value ? ""true"" : ""false"");"
implicit_predicate,transport-helper.c,362,-,+,,35,"	set_helper_option(t, ""progress"", t->progress ? ""true"" : ""false"");"
implicit_predicate,transport-helper.c,407,-,+,,8,			    posn->symref ? posn->symref : posn->name);
implicit_predicate,transport-helper.c,413,+,-,"while (1){
    const char* name;
    if (recvline(data, &buf))
        exit(128);

    if (skip_prefix(buf.buf, ""lock "", &name)){
        if (transport->pack_lockfiles.nr)
            warning(_(""%s also locked %s""), data->name, name);
        else
            string_list_append(&transport->pack_lockfiles, name);
    }else
        if (data->check_connectivity && data->transport_options.check_self_contained_and_connected && !strcmp(buf.buf, ""connectivity-ok""))
            data->transport_options.self_contained_and_connected = 1;
        else
            if (!buf.len)
                break;
            else
                warning(_(""%s unexpectedly said: '%s'""), data->name, buf.buf);
}
",,
implicit_predicate,transport-helper.c,416,+,-,"if (recvline(data, &buf))
    exit(128);
",,
implicit_predicate,transport-helper.c,450,+,+,"debug ? ""--stats"" : ""--quiet""",33,"	strvec_push(&fastimport->args, debug ? ""--stats"" : ""--quiet"");"
implicit_predicate,transport-helper.c,477,-,+,,33,"	strvec_push(&fastexport->args, data->signed_tags ?
		""--signed-tags=verbatim"" : ""--signed-tags=warn-strip"");"
implicit_predicate,transport-helper.c,502,+,-,"if (get_importer(transport, &fastimport))
    die(_(""couldn't run fast-import""));
",,
implicit_predicate,transport-helper.c,511,-,+,,8,			    posn->symref ? posn->symref : posn->name);
implicit_predicate,transport-helper.c,548,-,+,,10,		name = posn->symref ? posn->symref : posn->name;
implicit_predicate,transport-helper.c,591,+,-,"if (debug)
    fprintf(stderr, ""Debug: Smart transport connection ready.\n"");
",,
implicit_predicate,transport-helper.c,596,+,-,"if (debug)
    fprintf(stderr, ""Debug: Falling back to dumb transport.\n"");
",,
implicit_predicate,transport-helper.c,636,+,-,"if (ret)
    transport->stateless_rpc = 1;
",,
implicit_predicate,transport-helper.c,652,+,+,"for_push ? ""git-receive-pack"" : ""git-upload-pack""",9,"	name = for_push ? ""git-receive-pack"" : ""git-upload-pack"";"
implicit_predicate,transport-helper.c,653,+,-,"if (for_push)
    exec = data->transport_options.receivepack;
else
    exec = data->transport_options.uploadpack;
",,
implicit_predicate,transport-helper.c,659,+,-,"if (ret)
    do_take_over(transport);
",,
implicit_predicate,transport-helper.c,693,+,-,"if (process_connect(transport, 0))
    return transport->vtable->fetch_refs(transport, nr_heads, to_fetch);
",,
implicit_predicate,transport-helper.c,768,+,-,"if (state->new_report){
    if (!state->hint->report){
        CALLOC_ARRAY(state->hint->report, 1);
        state->report = state->hint->report;
    }else{
        state->report = state->hint->report;
        while (state->report->next)
            state->report = state->report->next;
        CALLOC_ARRAY(state->report->next, 1);
        state->report = state->report->next;
    }
    state->new_report = 0;
}
",,
implicit_predicate,transport-helper.c,902,+,-,"if (recvline(data, &buf)){
    strbuf_release(&buf);
    return 1;
}
",,
implicit_predicate,transport-helper.c,934,-,+,,9,"							 report->ref_name
							 ? report->ref_name
							 : ref->name);"
implicit_predicate,transport-helper.c,941,-,+,,7,"						report->new_oid
						? report->new_oid
						: &(ref->new_oid),"
implicit_predicate,transport-helper.c,1009,+,-,"if (atomic){
    reject_atomic_push(remote_refs, mirror);
    string_list_clear(&cas_options, 0);
    return 0;
}else
    continue;
",,
implicit_predicate,transport-helper.c,1021,+,-,"if (force_all)
    ref->force = 1;
",,
implicit_predicate,transport-helper.c,1132,+,-,"if (get_exporter(transport, &exporter, &revlist_args))
    die(_(""couldn't run fast-export""));
",,
implicit_predicate,transport-helper.c,1139,+,-,"if (push_update_refs_status(data, remote_refs, flags))
    return 1;
",,
implicit_predicate,transport-helper.c,1156,+,-,"if (process_connect(transport, 1))
    return transport->vtable->push_refs(transport, remote_refs, flags);
",,
implicit_predicate,transport-helper.c,1198,+,-,"if (process_connect(transport, for_push))
    return transport->vtable->get_refs_list(transport, for_push, transport_options);
",,
implicit_predicate,transport-helper.c,1226,+,-,"while (1){
    char *eov, *eon;
    if (recvline(data, &buf))
        exit(128);

    if (!*buf.buf)
        break;
    else
        if (buf.buf[0] == ':'){
            const char* value;
            if (skip_prefix(buf.buf, "":object-format "", &value)){
                int algo = hash_algo_by_name(value);
                if (algo == GIT_HASH_UNKNOWN)
                    die(_(""unsupported object format '%s'""), value);

                transport->hash_algo = &hash_algos[algo];
            }
            continue;
        }

    eov = strchr(buf.buf, ' ');
    if (!eov)
        die(_(""malformed response in ref list: %s""), buf.buf);

    eon = strchr(eov + 1, ' ');
    *eov = '\0';
    if (eon)
        *eon = '\0';

    *tail = alloc_ref(eov + 1);
    if (buf.buf[0] == '@')
        (*tail)->symref = xstrdup(buf.buf + 1);
    else
        if (buf.buf[0] != '?')
            get_oid_hex_algop(buf.buf, &(*tail)->old_oid, transport->hash_algo);

    if (eon){
        if (has_attribute(eon + 1, ""unchanged"")){
            (*tail)->status |= REF_STATUS_UPTODATE;
            if (refs_read_ref(get_main_ref_store(the_repository), (*tail)->name, &(*tail)->old_oid) < 0)
                die(_(""could not read ref %s""), (*tail)->name);
        }
    }
    tail = &((*tail)->next);
}
",,
implicit_predicate,transport-helper.c,1228,+,-,"if (recvline(data, &buf))
    exit(128);
",,
implicit_predicate,transport-helper.c,1258,+,-,"if (has_attribute(eon + 1, ""unchanged"")){
    (*tail)->status |= REF_STATUS_UPTODATE;
    if (refs_read_ref(get_main_ref_store(the_repository), (*tail)->name, &(*tail)->old_oid) < 0)
        die(_(""could not read ref %s""), (*tail)->name);
}
",,
implicit_predicate,transport-helper.c,1267,+,-,"if (debug)
    fprintf(stderr, ""Debug: Read ref listing.\n"");
",,
implicit_predicate,transport-helper.c,1281,+,-,"if (process_connect(transport, 0))
    return transport->vtable->get_bundle_uri(transport);
",,
implicit_predicate,transport-helper.c,1339,-,+,,19,"		debug_enabled = getenv(""GIT_TRANSLOOP_DEBUG"") ? 1 : 0;"
implicit_predicate,transport-helper.c,1390,+,-,"if (t->dest_is_sock)
    shutdown(t->dest, SHUT_WR);
else
    close(t->dest);
",,
implicit_predicate,transport-helper.c,1465,+,-,"if (udt_do_read(t))
    return NULL;
",,
implicit_predicate,transport-helper.c,1468,+,-,"if (udt_do_write(t))
    return NULL;
",,
implicit_predicate,transport-helper.c,1491,+,-,"if (err){
    error(_(""%s thread failed to join: %s""), name, strerror(err));
    return 1;
}
",,
implicit_predicate,transport-helper.c,1510,+,-,"if (err)
    die(_(""can't start thread for copying data: %s""), strerror(err));
",,
implicit_predicate,transport-helper.c,1514,+,-,"if (err)
    die(_(""can't start thread for copying data: %s""), strerror(err));
",,
implicit_predicate,transport.c,51,+,-,"if (initialized)
    return 0;
",,
implicit_predicate,transport.c,239,+,-,"if (*end)
    die(_(""transport: invalid depth option '%s'""), value);
",,
implicit_predicate,transport.c,284,+,+,"for_push ? ""git-receive-pack"" : ""git-upload-pack""",6,"				 for_push ?
					""git-receive-pack"" :
					""git-upload-pack"","
implicit_predicate,transport.c,287,+,+,for_push ? data->options.receivepack : data->options.uploadpack,6,"				 for_push ?
					data->options.receivepack :
					data->options.uploadpack,"
implicit_predicate,transport.c,334,+,-,"if (must_list_refs)
    get_remote_refs(data->fd[1], &reader, &refs, for_push, options, transport->server_options, transport->stateless_rpc);
",,
implicit_predicate,transport.c,344,+,+,for_push ? REF_NORMAL : 0,6,"				 for_push ? REF_NORMAL : 0,"
implicit_predicate,transport.c,476,-,+,,6,"			  refs_tmp ? refs_tmp : transport->remote_refs,"
implicit_predicate,transport.c,544,+,-,"if (verbose)
    fprintf(stderr, ""updating local tracking ref '%s'\n"", rs.dst);
",,
implicit_predicate,transport.c,546,+,-,"if (deletion)
    refs_delete_ref(get_main_ref_store(the_repository), NULL, rs.dst, NULL, 0);
else
    refs_update_ref(get_main_ref_store(the_repository), ""update by push"", rs.dst, new_oid, NULL, 0, 0);
",,
implicit_predicate,transport.c,572,-,+,,14,			refname = report->ref_name ? (char *)report->ref_name : ref->name;
implicit_predicate,transport.c,573,-,+,,14,			new_oid = report->new_oid ? report->new_oid : &ref->new_oid;
implicit_predicate,transport.c,591,+,-,"if (porcelain){
    if (from)
        fprintf(stdout, ""%c\t%s:%s\t"", flag, from->name, to_name);
    else
        fprintf(stdout, ""%c\t:%s\t"", flag, to_name);

    if (msg)
        fprintf(stdout, ""%s (%s)\n"", summary, msg);
    else
        fprintf(stdout, ""%s\n"", summary);
}else{
    const char *red = """", *reset = """";
    if (push_had_errors(to)){
        red = transport_get_color(TRANSPORT_COLOR_REJECTED);
        reset = transport_get_color(TRANSPORT_COLOR_RESET);
    }
    fprintf(stderr, "" %s%c %-*s%s "", red, flag, summary_width, summary, reset);
    if (from)
        fprintf(stderr, ""%s -> %s"", prettify_refname(from->name), prettify_refname(to_name));
    else
        fputs(prettify_refname(to_name), stderr);

    if (msg){
        fputs("" ("", stderr);
        fputs(msg, stderr);
        fputc(')', stderr);
    }
    fputc('\n', stderr);
}
",,
implicit_predicate,transport.c,602,+,-,"if (push_had_errors(to)){
    red = transport_get_color(TRANSPORT_COLOR_REJECTED);
    reset = transport_get_color(TRANSPORT_COLOR_RESET);
}
",,
implicit_predicate,transport.c,654,-,+,,7,"				 (starts_with(ref_name, ""refs/tags/"")
				  ? ""[new tag]""
				  : (starts_with(ref_name, ""refs/heads/"")
				     ? ""[new branch]""
				     : ""[new reference]"")),"
implicit_predicate,transport.c,656,-,+,,10,"				  : (starts_with(ref_name, ""refs/heads/"")
				     ? ""[new branch]""
				     : ""[new reference]"")),"
implicit_predicate,transport.c,668,+,-,"if (forced_update){
    strbuf_addstr(&quickref, ""..."");
    type = '+';
    msg = ""forced update"";
}else{
    strbuf_addstr(&quickref, "".."");
    type = ' ';
    msg = NULL;
}
",,
implicit_predicate,transport.c,692,+,+,porcelain ? stdout : stderr,11,"		fprintf(porcelain ? stdout : stderr, ""To %s\n"", url);"
implicit_predicate,transport.c,748,-,+,,6,"				 ref->deletion ? NULL : ref->peer_ref,"
implicit_predicate,transport.c,754,-,+,,6,"				 ref->deletion ? NULL : ref->peer_ref,"
implicit_predicate,transport.c,823,+,-,"if (verbose){
    for (ref = refs;ref;ref = ref->next)
        if (ref->status == REF_STATUS_UPTODATE)
            n += print_one_push_status(ref, dest, n, porcelain, summary_width);
}
",,
implicit_predicate,transport.c,1010,+,+,enabled ? &allowed : NULL,9,	return enabled ? &allowed : NULL;
implicit_predicate,transport.c,1391,+,-,"if (run_pre_push_hook(transport, remote_refs))
    goto done;
",,
implicit_predicate,transport.c,1572,+,-,"if (in_signal_handler)
    unlink(transport->pack_lockfiles.items[i].string);
else
    unlink_or_warn(transport->pack_lockfiles.items[i].string);
",,
implicit_predicate,tree-diff.c,75,-,+,,10,		return t2->size ? 1 : 0;
implicit_predicate,tree-diff.c,183,-,+,,18,"	oidcpy(&p->oid, oid ? oid : null_oid());"
implicit_predicate,tree-diff.c,239,+,-,"if (emitthis){
    int keep;
    struct combine_diff_path* pprev = p;
    p = path_appendnew(p, nparent, base, path, pathlen, mode, oid);
    for (i = 0;i < nparent;++i){
        int tpi_valid = tp && !(tp[i].entry.mode & S_IFXMIN_NEQ);
        const struct object_id* oid_i;
        unsigned mode_i;
        p->parent[i].status = !t ? DIFF_STATUS_DELETED : tpi_valid ? DIFF_STATUS_MODIFIED : DIFF_STATUS_ADDED;
        if (tpi_valid){
            oid_i = &tp[i].entry.oid;
            mode_i = tp[i].entry.mode;
        }else{
            oid_i = null_oid();
            mode_i = 0;
        }
        p->parent[i].mode = mode_i;
        oidcpy(&p->parent[i].oid, oid_i);
    }
    keep = 1;
    if (opt->pathchange)
        keep = opt->pathchange(opt, p);

    if (!keep)
        p = pprev;
    else
        p->next = NULL;
}
",,
implicit_predicate,tree-diff.c,256,+,+,tpi_valid ? DIFF_STATUS_MODIFIED : DIFF_STATUS_ADDED,6,"					tpi_valid ?
						DIFF_STATUS_MODIFIED :
						DIFF_STATUS_ADDED;"
implicit_predicate,tree-diff.c,260,+,-,"if (tpi_valid){
    oid_i = &tp[i].entry.oid;
    mode_i = tp[i].entry.mode;
}else{
    oid_i = null_oid();
    mode_i = 0;
}
",,
implicit_predicate,tree-diff.c,294,+,-,"if (recurse){
    const struct object_id** parents_oid;
    FAST_ARRAY_ALLOC(parents_oid, nparent);
    for (i = 0;i < nparent;++i){
        int tpi_valid = tp && !(tp[i].entry.mode & S_IFXMIN_NEQ);
        parents_oid[i] = tpi_valid ? &tp[i].entry.oid : NULL;
    }
    strbuf_add(base, path, pathlen);
    strbuf_addch(base, '/');
    p = ll_diff_tree_paths(p, oid, parents_oid, nparent, base, opt, depth + 1);
    FAST_ARRAY_FREE(parents_oid, nparent);
}
",,
implicit_predicate,tree-diff.c,297,+,-,"FAST_ARRAY_ALLOC(parents_oid, nparent);
",,
implicit_predicate,tree-diff.c,302,+,+,tpi_valid ? &tp[i].entry.oid : NULL,21,			parents_oid[i] = tpi_valid ? &tp[i].entry.oid : NULL;
implicit_predicate,tree-diff.c,309,+,-,"FAST_ARRAY_FREE(parents_oid, nparent);
",,
implicit_predicate,tree-diff.c,439,+,-,"FAST_ARRAY_ALLOC(tp, nparent);
",,
implicit_predicate,tree-diff.c,440,+,-,"FAST_ARRAY_ALLOC(tptree, nparent);
",,
implicit_predicate,tree-diff.c,478,+,-,"if (done)
    break;
",,
implicit_predicate,tree-diff.c,571,+,-,"FAST_ARRAY_FREE(tptree, nparent);
",,
implicit_predicate,tree-diff.c,572,+,-,"FAST_ARRAY_FREE(tp, nparent);
",,
implicit_predicate,tree-walk.c,39,-,+,,21,	desc->entry.mode = (desc->flags & TREE_DESC_RAW_MODES) ? mode : canon_mode(mode);
implicit_predicate,tree-walk.c,57,+,-,"if (size)
    return decode_tree_entry(desc, buffer, size, err);
",,
implicit_predicate,tree-walk.c,77,+,-,"if (result)
    error(""%s"", err.buf);
",,
implicit_predicate,tree-walk.c,122,+,-,"if (size)
    return decode_tree_entry(desc, buf, size, err);
",,
implicit_predicate,tree-walk.c,130,+,-,"if (update_tree_entry_internal(desc, &err))
    die(""%s"", err.buf);
",,
implicit_predicate,tree-walk.c,138,+,-,"if (update_tree_entry_internal(desc, &err)){
    error(""%s"", err.buf);
    strbuf_release(&err);
    desc->size = 0;
    return -1;
}
",,
implicit_predicate,tree-walk.c,165,+,-,"if (update_tree_entry_gently(desc))
    return 0;
",,
implicit_predicate,tree-walk.c,197,-,+,,18,	info->pathlen = pathlen ? pathlen + 1 : 0;
implicit_predicate,tree-walk.c,339,+,-,"while (1){
    if (!t->d.size){
        entry_clear(a);
        break;
    }
    entry_extract(&t->d, a);
    for (skip = t->skip;skip;skip = skip->prev)
        if (a->path == skip->ptr)
            break;
    if (!skip)
        break;

    update_tree_entry(&t->d);
}
",,
implicit_predicate,tree-walk.c,533,+,-,"if (interesting){
    trees_used = info->fn(n, mask, dirmask, entry, info);
    if (trees_used < 0){
        ret = trees_used;
        if (!info->show_all_errors)
            break;
    }
    mask &= trees_used;
}
",,
implicit_predicate,tree-walk.c,543,+,-,"if (mask & (1ul << i))
    update_extended_entry(tx + i, entry + i);
",,
implicit_predicate,tree-walk.c,673,+,-,"while (1){
    int find_result;
    char* first_slash;
    char* remainder = NULL;
    if (!t.buffer){
        void* tree;
        struct object_id root;
        unsigned long size;
        tree = read_object_with_reference(r, &current_tree_oid, OBJ_TREE, &size, &root);
        if (!tree)
            goto done;

        ALLOC_GROW(parents, parents_nr + 1, parents_alloc);
        parents[parents_nr].tree = tree;
        parents[parents_nr].size = size;
        oidcpy(&parents[parents_nr].oid, &root);
        parents_nr++;
        if (namebuf.buf[0] == '\0'){
            oidcpy(result, &root);
            retval = FOUND;
            goto done;
        }
        if (!size)
            goto done;

        init_tree_desc(&t, &current_tree_oid, tree, size);
    }
    while (namebuf.buf[0] == '/'){
        strbuf_remove(&namebuf, 0, 1);
    }
    if ((first_slash = strchr(namebuf.buf, '/'))){
        *first_slash = 0;
        remainder = first_slash + 1;
    }
    if (!strcmp(namebuf.buf, "".."")){
        struct dir_state* parent;
        if (parents_nr == 1){
            if (remainder)
                *first_slash = '/';

            strbuf_add(result_path, namebuf.buf, namebuf.len);
            *mode = 0;
            retval = FOUND;
            goto done;
        }
        parent = &parents[parents_nr - 1];
        free(parent->tree);
        parents_nr--;
        parent = &parents[parents_nr - 1];
        init_tree_desc(&t, &parent->oid, parent->tree, parent->size);
        strbuf_remove(&namebuf, 0, remainder ? 3 : 2);
        continue;
    }
    if (namebuf.buf[0] == '\0'){
        oidcpy(result, &parents[parents_nr - 1].oid);
        retval = FOUND;
        goto done;
    }
    find_result = find_tree_entry(r, &t, namebuf.buf, &current_tree_oid, mode);
    if (find_result){
        goto done;
    }
    if (S_ISDIR(*mode)){
        if (!remainder){
            oidcpy(result, &current_tree_oid);
            retval = FOUND;
            goto done;
        }
        t.buffer = NULL;
        strbuf_remove(&namebuf, 0, 1 + first_slash - namebuf.buf);
    }else
        if (S_ISREG(*mode)){
            if (!remainder){
                oidcpy(result, &current_tree_oid);
                retval = FOUND;
            }else{
                retval = NOT_DIR;
            }
            goto done;
        }else
            if (S_ISLNK(*mode)){
                unsigned long link_len;
                size_t len;
                char *contents, *contents_start;
                struct dir_state* parent;
                enum object_type type;
                if (follows_remaining-- == 0){
                    retval = SYMLINK_LOOP;
                    goto done;
                }
                retval = DANGLING_SYMLINK;
                contents = repo_read_object_file(r, &current_tree_oid, &type, &link_len);
                if (!contents)
                    goto done;

                if (contents[0] == '/'){
                    strbuf_addstr(result_path, contents);
                    free(contents);
                    *mode = 0;
                    retval = FOUND;
                    goto done;
                }
                if (remainder)
                    len = first_slash - namebuf.buf;
                else
                    len = namebuf.len;

                contents_start = contents;
                parent = &parents[parents_nr - 1];
                init_tree_desc(&t, &parent->oid, parent->tree, parent->size);
                strbuf_splice(&namebuf, 0, len, contents_start, link_len);
                if (remainder)
                    namebuf.buf[link_len] = '/';

                free(contents);
            }
}
",,
implicit_predicate,tree-walk.c,740,-,+,,31,"			strbuf_remove(&namebuf, 0, remainder ? 3 : 2);"
implicit_predicate,tree-walk.c,754,+,-,"if (find_result){
    goto done;
}
",,
implicit_predicate,tree-walk.c,934,+,-,"if (ret)
    return ret;
",,
implicit_predicate,tree-walk.c,947,+,-,"if (basecmp(item, base, match, matchlen))
    return 0;
",,
implicit_predicate,tree-walk.c,976,+,-,"if (baselen){
    int dirlen;
    if (baselen >= matchlen){
        *matched = matchlen;
        return !basecmp(item, base, match, matchlen);
    }
    dirlen = matchlen;
    while (dirlen && match[dirlen - 1] != '/')
        dirlen--;
    if (basecmp(item, base, match, baselen))
        return 0;

    *matched = baselen;
}else
    *matched = 0;
",,
implicit_predicate,tree-walk.c,997,+,-,"if (basecmp(item, base, match, baselen))
    return 0;
",,
implicit_predicate,tree-walk.c,1025,-,+,,39,"	enum interesting never_interesting = ps->has_wildcard ?
		entry_not_interesting : all_entries_not_interesting;"
implicit_predicate,tree-walk.c,1042,-,+,,10,"		return within_depth(base->buf, baselen,
				    !!S_ISDIR(entry->mode),
				    ps->max_depth) ?
			entry_interesting : entry_not_interesting;"
implicit_predicate,tree.c,107,+,-,"if (cmp)
    return cmp;
",,
implicit_predicate,tree.c,136,+,-,"if (cmp)
    return cmp;
",,
implicit_predicate,tree.c,158,+,-,"if (cmp)
    return cmp;
",,
implicit_predicate,tree.c,197,+,+,"quiet_on_missing ? -1 : error(""Could not read %s"", oid_to_hex(&item->object.oid))",10,"		return quiet_on_missing ? -1 :
			error(""Could not read %s"",
			     oid_to_hex(&item->object.oid));"
implicit_predicate,unix-socket.c,45,+,-,"if (disallow_chdir){
    errno = ENAMETOOLONG;
    return -1;
}
",,
implicit_predicate,unix-stream-server.c,57,+,-,"if (is_another_server_alive(path, opts)){
    rollback_lock_file(&lock);
    errno = EADDRINUSE;
    return -2;
}
",,
implicit_predicate,unpack-objects.c,68,+,-,"if (offset){
    the_hash_algo->update_fn(&ctx, buffer, offset);
    memmove(buffer, buffer + offset, len);
    offset = 0;
}
",,
implicit_predicate,unpack-objects.c,141,+,-,"if (dry_run){
    stream.next_out = buf;
    stream.avail_out = bufsize > size - stream.total_out ? size - stream.total_out : bufsize;
}
",,
implicit_predicate,unpack-objects.c,150,+,-,"if (dry_run)
    FREE_AND_NULL(buf);
",,
implicit_predicate,unpack-objects.c,408,+,-,"if (strict){
    struct blob* blob = lookup_blob(the_repository, &info->oid);
    if (!blob)
        die(_(""invalid blob object from stream""));

    blob->object.flags |= FLAG_WRITTEN;
}
",,
implicit_predicate,unpack-objects.c,449,+,-,"if (resolve_against_held(nr, &base_oid, delta_data, delta_size))
    return;
else{
    oidclr(&obj_list[nr].oid);
    add_delta_to_list(nr, &base_oid, 0, delta_data, delta_size);
    return;
}
",,
implicit_predicate,unpack-objects.c,468,+,-,"while (c & 128){
    base_offset += 1;
    if (!base_offset || MSB(base_offset, 7))
        die(""offset value overflow for delta base object"");

    pack = fill(1);
    c = *pack;
    use(1);
    base_offset = (base_offset << 7) + (c & 127);
}
",,
implicit_predicate,unpack-objects.c,510,+,-,"if (resolve_against_held(nr, &base_oid, delta_data, delta_size))
    return;
",,
implicit_predicate,unpack-objects.c,542,+,-,"while (c & 0x80){
    pack = fill(1);
    c = *pack;
    use(1);
    size += (c & 0x7f) << shift;
    shift += 7;
}
",,
implicit_predicate,unpack-objects.c,569,+,-,"if (recover)
    return;
",,
implicit_predicate,unpack-trees.c,126,-,+,,9,"		msg = advice_enabled(ADVICE_COMMIT_BEFORE_MERGE)
		      ? _(""Your local changes to the following files would be overwritten by checkout:\n%%s""
			  ""Please commit your changes or stash them before you switch branches."")
		      : _(""Your local changes to the following files would be overwritten by checkout:\n%%s"");"
implicit_predicate,unpack-trees.c,131,-,+,,9,"		msg = advice_enabled(ADVICE_COMMIT_BEFORE_MERGE)
		      ? _(""Your local changes to the following files would be overwritten by merge:\n%%s""
			  ""Please commit your changes or stash them before you merge."")
		      : _(""Your local changes to the following files would be overwritten by merge:\n%%s"");"
implicit_predicate,unpack-trees.c,136,-,+,,9,"		msg = advice_enabled(ADVICE_COMMIT_BEFORE_MERGE)
		      ? _(""Your local changes to the following files would be overwritten by %s:\n%%s""
			  ""Please commit your changes or stash them before you %s."")
		      : _(""Your local changes to the following files would be overwritten by %s:\n%%s"");"
implicit_predicate,unpack-trees.c,150,-,+,,9,"		msg = advice_enabled(ADVICE_COMMIT_BEFORE_MERGE)
		      ? _(""The following untracked working tree files would be removed by checkout:\n%%s""
			  ""Please move or remove them before you switch branches."")
		      : _(""The following untracked working tree files would be removed by checkout:\n%%s"");"
implicit_predicate,unpack-trees.c,155,-,+,,9,"		msg = advice_enabled(ADVICE_COMMIT_BEFORE_MERGE)
		      ? _(""The following untracked working tree files would be removed by merge:\n%%s""
			  ""Please move or remove them before you merge."")
		      : _(""The following untracked working tree files would be removed by merge:\n%%s"");"
implicit_predicate,unpack-trees.c,160,-,+,,9,"		msg = advice_enabled(ADVICE_COMMIT_BEFORE_MERGE)
		      ? _(""The following untracked working tree files would be removed by %s:\n%%s""
			  ""Please move or remove them before you %s."")
		      : _(""The following untracked working tree files would be removed by %s:\n%%s"");"
implicit_predicate,unpack-trees.c,168,-,+,,9,"		msg = advice_enabled(ADVICE_COMMIT_BEFORE_MERGE)
		      ? _(""The following untracked working tree files would be overwritten by checkout:\n%%s""
			  ""Please move or remove them before you switch branches."")
		      : _(""The following untracked working tree files would be overwritten by checkout:\n%%s"");"
implicit_predicate,unpack-trees.c,173,-,+,,9,"		msg = advice_enabled(ADVICE_COMMIT_BEFORE_MERGE)
		      ? _(""The following untracked working tree files would be overwritten by merge:\n%%s""
			  ""Please move or remove them before you merge."")
		      : _(""The following untracked working tree files would be overwritten by merge:\n%%s"");"
implicit_predicate,unpack-trees.c,178,-,+,,9,"		msg = advice_enabled(ADVICE_COMMIT_BEFORE_MERGE)
		      ? _(""The following untracked working tree files would be overwritten by %s:\n%%s""
			  ""Please move or remove them before you %s."")
		      : _(""The following untracked working tree files would be overwritten by %s:\n%%s"");"
implicit_predicate,unpack-trees.c,280,+,-,"if (error_displayed)
    fprintf(stderr, _(""Aborting\n""));
",,
implicit_predicate,unpack-trees.c,308,+,-,"if (warning_displayed)
    fprintf(stderr, _(""After fixing the above paths, you may want to run `git sparse-checkout reapply`.\n""));
",,
implicit_predicate,unpack-trees.c,485,+,-,"if (must_checkout(ce)){
    size_t last_pc_queue_size = pc_queue_size();
    if (ce->ce_flags & CE_WT_REMOVE)
        BUG(""both update and delete flags are set on %s"", ce->name);

    ce->ce_flags &= ~CE_UPDATE;
    errs |= checkout_entry(ce, &state, NULL, NULL);
    if (last_pc_queue_size == pc_queue_size())
        display_progress(progress, ++cnt);
}
",,
implicit_predicate,unpack-trees.c,931,+,-,"if (dirmask & 1)
    oid = &names[i].oid;
",,
implicit_predicate,unpack-trees.c,970,+,-,"if (cmp)
    return cmp;
",,
implicit_predicate,unpack-trees.c,1005,+,-,"if (cmp)
    return cmp;
",,
implicit_predicate,unpack-trees.c,1024,+,-,"if (cmp)
    return cmp;
",,
implicit_predicate,unpack-trees.c,1067,+,+,is_sparse_directory ? len + 1 : len,21,	size_t alloc_len = is_sparse_directory ? len + 1 : len;
implicit_predicate,unpack-trees.c,1069,+,+,"is_transient ? make_empty_transient_cache_entry(alloc_len, NULL) : make_empty_cache_entry(istate, alloc_len)",3,"		is_transient ?
		make_empty_transient_cache_entry(alloc_len, NULL) :
		make_empty_cache_entry(istate, alloc_len);"
implicit_predicate,unpack-trees.c,1080,+,-,"if (is_sparse_directory){
    ce->name[len] = '/';
    ce->name[len + 1] = '\0';
    ce->ce_namelen++;
    ce->ce_flags |= CE_SKIP_WORKTREE;
}
",,
implicit_predicate,unpack-trees.c,1207,+,-,"if (conflicts & bit){
    src[i + o->merge] = o->df_conflict_entry;
    continue;
}
",,
implicit_predicate,unpack-trees.c,1247,+,-,"if (do_add_entry(o, src[i], 0, 0))
    return -1;
",,
implicit_predicate,unpack-trees.c,1318,-,+,,11,			return ce_slash ? -2 - pos : pos;
implicit_predicate,unpack-trees.c,1419,-,+,,9,"	       n->path ? n->mode : 0,"
implicit_predicate,unpack-trees.c,1420,-,+,,9,"	       n->path ? n->path : ""(missing)"");"
implicit_predicate,unpack-trees.c,1510,+,-,"while (1){
    int cmp;
    struct cache_entry* ce;
    if (o->diff_index_cached)
        ce = next_cache_entry(o);
    else
        ce = find_cache_entry(info, p);

    if (!ce)
        break;

    cmp = compare_entry(ce, info, p);
    if (cmp < 0){
        if (unpack_index_entry(ce, o) < 0)
            return unpack_failed(o, NULL);

        continue;
    }
    if (!cmp){
        if (ce_stage(ce)){
            if (o->skip_unmerged){
                add_same_unmerged(ce, o);
                return mask;
            }
        }
        src[0] = ce;
    }
    break;
}
",,
implicit_predicate,unpack-trees.c,1546,+,-,"if (unpack_single_entry(n, mask, dirmask, src, names, info, &is_new_sparse_dir))
    return -1;
",,
implicit_predicate,unpack-trees.c,1557,+,-,"if (dirmask){
    if (o->diff_index_cached && n == 1 && dirmask == 1 && S_ISDIR(names->mode)){
        int matches;
        matches = cache_tree_matches_traversal(o->src_index->cache_tree, names, info);
        if (matches){
            if (!src[0] || !S_ISSPARSEDIR(src[0]->ce_mode))
                o->internal.cache_bottom += matches;

            return mask;
        }
    }
    if (!is_sparse_directory_entry(src[0], p, info) && !is_new_sparse_dir && traverse_trees_recursive(n, dirmask, mask & ~dirmask, names, info) < 0){
        return -1;
    }
    return mask;
}
",,
implicit_predicate,unpack-trees.c,1570,+,-,"if (matches){
    if (!src[0] || !S_ISSPARSEDIR(src[0]->ce_mode))
        o->internal.cache_bottom += matches;

    return mask;
}
",,
implicit_predicate,unpack-trees.c,1680,+,+,nr ? cache + nr : cache,35,	struct cache_entry **cache_end = nr ? cache + nr : cache;
implicit_predicate,unpack-trees.c,1721,+,-,"if (processed){
    cache += processed;
    progress_nr += processed;
    strbuf_setlen(prefix, prefix->len - len);
    continue;
}
",,
implicit_predicate,unpack-trees.c,1768,+,-,"if (show_progress)
    istate->progress = start_delayed_progress(_(""Updating index flags""), istate->cache_nr);
",,
implicit_predicate,unpack-trees.c,1973,+,-,"if (len){
    const char* prefix = o->prefix ? o->prefix : """";
    struct traverse_info info;
    setup_traverse_info(&info, prefix);
    info.fn = unpack_callback;
    info.data = o;
    info.show_all_errors = o->internal.show_all_errors;
    info.pathspec = o->pathspec;
    if (o->prefix){
        while (1){
            struct cache_entry* ce = next_cache_entry(o);
            if (!ce)
                break;

            if (ce_in_traverse_path(ce, &info))
                break;

            if (unpack_index_entry(ce, o) < 0)
                goto return_failed;
        }
    }
    trace_performance_enter();
    trace2_region_enter(""unpack_trees"", ""traverse_trees"", the_repository);
    ret = traverse_trees(o->src_index, len, t, &info);
    trace2_region_leave(""unpack_trees"", ""traverse_trees"", the_repository);
    trace_performance_leave(""traverse_trees"");
    if (ret < 0)
        goto return_failed;
}
",,
implicit_predicate,unpack-trees.c,1974,-,+,,24,"		const char *prefix = o->prefix ? o->prefix : """";"
implicit_predicate,unpack-trees.c,1989,+,-,"while (1){
    struct cache_entry* ce = next_cache_entry(o);
    if (!ce)
        break;

    if (ce_in_traverse_path(ce, &info))
        break;

    if (unpack_index_entry(ce, o) < 0)
        goto return_failed;
}
",,
implicit_predicate,unpack-trees.c,1993,+,-,"if (ce_in_traverse_path(ce, &info))
    break;
",,
implicit_predicate,unpack-trees.c,2011,+,-,"while (1){
    struct cache_entry* ce = next_cache_entry(o);
    if (!ce)
        break;

    if (unpack_index_entry(ce, o) < 0)
        goto return_failed;
}
",,
implicit_predicate,unpack-trees.c,2066,-,+,,8,"	ret = check_updates(o, &o->internal.result) ? (-2) : 0;"
implicit_predicate,unpack-trees.c,2089,+,-,"if (free_pattern_list)
    clear_pattern_list(&pl);
",,
implicit_predicate,unpack-trees.c,2173,+,-,"if (free_pattern_list){
    clear_pattern_list(pl);
    free(pl);
    o->internal.pl = NULL;
}
",,
implicit_predicate,unpack-trees.c,2233,+,-,"if (r)
    return add_rejected_path(o, error_type, ce->name);
",,
implicit_predicate,unpack-trees.c,2328,+,+,sub_head ? NULL : oid_to_hex(&oid),33,"		return verify_clean_submodule(sub_head ? NULL : oid_to_hex(&oid),"
implicit_predicate,unpack-trees.c,2329,+,-,sub_head ? NULL : oid_to_hex(&oid),,
implicit_predicate,unpack-trees.c,2351,+,-,"if (verify_uptodate(ce2, o))
    return -1;
",,
implicit_predicate,unpack-trees.c,2352,+,-,"if (verify_uptodate(ce2, o))
    return -1;
",,
implicit_predicate,unpack-trees.c,2369,+,-,"if (i)
    return add_rejected_path(o, ERROR_NOT_UPTODATE_DIR, ce->name);
",,
implicit_predicate,unpack-trees.c,2370,+,-,"if (i)
    return add_rejected_path(o, ERROR_NOT_UPTODATE_DIR, ce->name);
",,
implicit_predicate,unpack-trees.c,2578,+,-,"if (ret)
    return ret;
",,
implicit_predicate,unpack-trees.c,2579,+,-,"if (ret)
    return ret;
",,
implicit_predicate,unpack-trees.c,2590,+,-,"if (same(old, merge)){
    copy_cache_entry(merge, old);
    update = 0;
}else{
    if (verify_uptodate(old, o)){
        discard_cache_entry(merge);
        return -1;
    }
    update |= old->ce_flags & (CE_SKIP_WORKTREE | CE_NEW_SKIP_WORKTREE);
    invalidate_ce_path(old, o);
}
",,
implicit_predicate,unpack-trees.c,2591,+,-,"if (same(old, merge)){
    copy_cache_entry(merge, old);
    update = 0;
}else{
    if (verify_uptodate(old, o)){
        discard_cache_entry(merge);
        return -1;
    }
    update |= old->ce_flags & (CE_SKIP_WORKTREE | CE_NEW_SKIP_WORKTREE);
    invalidate_ce_path(old, o);
}
",,
implicit_predicate,unpack-trees.c,2594,+,-,"if (verify_uptodate(old, o)){
    discard_cache_entry(merge);
    return -1;
}
",,
implicit_predicate,unpack-trees.c,2595,+,-,"if (verify_uptodate(old, o)){
    discard_cache_entry(merge);
    return -1;
}
",,
implicit_predicate,unpack-trees.c,2607,+,-,"if (ret)
    return ret;
",,
implicit_predicate,unpack-trees.c,2608,+,-,"if (ret)
    return ret;
",,
implicit_predicate,unpack-trees.c,2748,+,-,"if (same(stages[i], head)){
    head_match = i;
}
",,
implicit_predicate,unpack-trees.c,2749,+,-,"if (same(stages[i], head)){
    head_match = i;
}
",,
implicit_predicate,unpack-trees.c,2751,+,-,"if (same(stages[i], remote)){
    remote_match = i;
}
",,
implicit_predicate,unpack-trees.c,2752,+,-,"if (same(stages[i], remote)){
    remote_match = i;
}
",,
implicit_predicate,unpack-trees.c,2785,+,-,"if (same(head, remote))
    return merged_entry(head, index, o);
",,
implicit_predicate,unpack-trees.c,2786,+,-,"if (same(head, remote))
    return merged_entry(head, index, o);
",,
implicit_predicate,unpack-trees.c,2858,+,-,"if (verify_uptodate(index, o))
    return -1;
",,
implicit_predicate,unpack-trees.c,2859,+,-,"if (verify_uptodate(index, o))
    return -1;
",,
implicit_predicate,unpack-trees.c,2964,+,-,"if (same(oldtree, newtree))
    return 1;
",,
implicit_predicate,unpack-trees.c,2965,+,-,"if (same(oldtree, newtree))
    return 1;
",,
implicit_predicate,unpack-trees.c,2989,-,+,,10,"		return o->quiet ? -1 :
			error(ERRORMSG(o, ERROR_BIND_OVERLAP),
			      super_prefixed(a->name, o->super_prefix),
			      super_prefixed(old->name, o->super_prefix));"
implicit_predicate,unpack-trees.c,3055,-,+,,22,
implicit_predicate,update-index.c,253,+,-,"if (mark)
    the_repository->index->cache[pos]->ce_flags |= flag;
else
    the_repository->index->cache[pos]->ce_flags &= ~flag;
",,
implicit_predicate,update-index.c,305,+,+,info_only ? 0 : HASH_WRITE_OBJECT,10,		       info_only ? 0 : HASH_WRITE_OBJECT)) {
implicit_predicate,update-index.c,309,+,+,allow_add ? ADD_CACHE_OK_TO_ADD : 0,11,	option = allow_add ? ADD_CACHE_OK_TO_ADD : 0;
implicit_predicate,update-index.c,310,+,+,allow_replace ? ADD_CACHE_OK_TO_REPLACE : 0,12,	option |= allow_replace ? ADD_CACHE_OK_TO_REPLACE : 0;
implicit_predicate,update-index.c,412,+,-,"if (stat_errno)
    return process_lstat_error(path, stat_errno);
",,
implicit_predicate,update-index.c,440,+,+,allow_add ? ADD_CACHE_OK_TO_ADD : 0,11,	option = allow_add ? ADD_CACHE_OK_TO_ADD : 0;
implicit_predicate,update-index.c,441,+,+,allow_replace ? ADD_CACHE_OK_TO_REPLACE : 0,12,	option |= allow_replace ? ADD_CACHE_OK_TO_REPLACE : 0;
implicit_predicate,update-index.c,484,+,-,"if (mark_valid_only){
    if (mark_ce_flags(path, CE_VALID, mark_valid_only == MARK_FLAG))
        die(""Unable to mark file %s"", path);

    return;
}
",,
implicit_predicate,update-index.c,489,+,-,"if (mark_skip_worktree_only){
    if (mark_ce_flags(path, CE_SKIP_WORKTREE, mark_skip_worktree_only == MARK_FLAG))
        die(""Unable to mark file %s"", path);

    return;
}
",,
implicit_predicate,update-index.c,494,+,-,"if (mark_fsmonitor_only){
    if (mark_ce_flags(path, CE_FSMONITOR_VALID, mark_fsmonitor_only == MARK_FLAG))
        die(""Unable to mark file %s"", path);

    return;
}
",,
implicit_predicate,update-index.c,500,+,-,"if (force_remove){
    if (remove_file_from_index(the_repository->index, path))
        die(""git update-index: unable to remove %s"", path);

    report(""remove '%s'"", path);
    return;
}
",,
implicit_predicate,update-index.c,506,+,-,"if (process_path(path, &st, stat_errno))
    die(""Unable to process path %s"", path);
",,
implicit_predicate,update-index.c,518,+,+,nul_term_line ? strbuf_getline_nul : strbuf_getline_lf,15,	getline_fn = nul_term_line ? strbuf_getline_nul : strbuf_getline_lf;
implicit_predicate,update-index.c,594,+,-,"if (add_cacheinfo(mode, &oid, path_name, stage))
    die(""git update-index: unable to update %s"", path_name);
",,
implicit_predicate,update-index.c,699,+,-,"if (has_head)
    old = read_one_ent(NULL, &head_oid, ce->name, ce_namelen(ce), 0);
",,
implicit_predicate,update-index.c,889,-,+,,13,"				prefix, prefix ? strlen(prefix) : 0);"
implicit_predicate,update-index.c,890,+,-,"if (*has_errors)
    the_repository->index->cache_changed = 0;
",,
implicit_predicate,update-index.c,911,+,-,"if (*has_errors)
    the_repository->index->cache_changed = 0;
",,
implicit_predicate,update-index.c,924,-,+,,22,	int prefix_length = prefix ? strlen(prefix) : 0;
implicit_predicate,update-index.c,1094,+,-,"if (set_executable_bit)
    chmod_path(set_executable_bit, p);
",,
implicit_predicate,update-index.c,1111,+,+,nul_term_line ? strbuf_getline_nul : strbuf_getline_lf,15,	getline_fn = nul_term_line ? strbuf_getline_nul : strbuf_getline_lf;
implicit_predicate,update-index.c,1112,+,-,"if (preferred_index_format){
    if (preferred_index_format < 0){
        printf(_(""%d\n""), the_repository->index->version);
    }else
        if (preferred_index_format < INDEX_FORMAT_LB || INDEX_FORMAT_UB < preferred_index_format){
            die(""index-version %d not in range: %d..%d"", preferred_index_format, INDEX_FORMAT_LB, INDEX_FORMAT_UB);
        }else{
            if (the_repository->index->version != preferred_index_format)
                the_repository->index->cache_changed |= SOMETHING_CHANGED;

            report(_(""index-version: was %d, set to %d""), the_repository->index->version, preferred_index_format);
            the_repository->index->version = preferred_index_format;
        }
}
",,
implicit_predicate,update-index.c,1129,+,-,"if (read_from_stdin){
    struct strbuf buf = STRBUF_INIT;
    struct strbuf unquoted = STRBUF_INIT;
    setup_work_tree();
    while (getline_fn(&buf, stdin) != EOF){
        char* p;
        if (!nul_term_line && buf.buf[0] == '""'){
            strbuf_reset(&unquoted);
            if (unquote_c_style(&unquoted, buf.buf, NULL))
                die(""line is badly quoted"");

            strbuf_swap(&buf, &unquoted);
        }
        p = prefix_path(prefix, prefix_length, buf.buf);
        update_one(p);
        if (set_executable_bit)
            chmod_path(set_executable_bit, p);

        free(p);
    }
    strbuf_release(&unquoted);
    strbuf_release(&buf);
}
",,
implicit_predicate,update-index.c,1144,+,-,"if (set_executable_bit)
    chmod_path(set_executable_bit, p);
",,
implicit_predicate,update-index.c,1249,+,+,has_errors ? 1 : 0,9,
implicit_predicate,update-ref.c,59,+,-,"if (line_termination){
    *next = parse_arg(*next, &ref);
}else{
    strbuf_addstr(&ref, *next);
    *next += ref.len;
}
",,
implicit_predicate,update-ref.c,111,+,-,"if (line_termination){
    if (!**next || **next == line_termination)
        return 1;

    if (**next != ' ')
        die(""%s %s: expected SP but got: %s"", command, refname, *next);

    (*next)++;
    *next = parse_arg(*next, &arg);
    if (arg.len){
        if (repo_get_oid(the_repository, arg.buf, oid))
            goto invalid;
    }else{
        oidclr(oid);
    }
}else{
    if (**next)
        die(""%s %s: expected NUL but got: %s"", command, refname, *next);

    (*next)++;
    if (*next == end)
        goto eof;

    strbuf_addstr(&arg, *next);
    *next += arg.len;
    if (arg.len){
        if (repo_get_oid(the_repository, arg.buf, oid))
            goto invalid;
    }else
        if (flags & PARSE_SHA1_ALLOW_EMPTY){
            warning(""%s %s: missing <new-oid>, treating as zero"", command, refname);
            oidclr(oid);
        }else{
            ret = 1;
        }
}
",,
implicit_predicate,update-ref.c,141,+,-,"if (flags & PARSE_SHA1_ALLOW_EMPTY){
    warning(""%s %s: missing <new-oid>, treating as zero"", command, refname);
    oidclr(oid);
}else{
    ret = 1;
}
",,
implicit_predicate,update-ref.c,160,+,+,"flags & PARSE_SHA1_OLD ? ""%s %s: invalid <old-oid>: %s"" : ""%s %s: invalid <new-oid>: %s""",6,"	die(flags & PARSE_SHA1_OLD ?
	    ""%s %s: invalid <old-oid>: %s"" :
	    ""%s %s: invalid <new-oid>: %s"","
implicit_predicate,update-ref.c,166,+,+,"flags & PARSE_SHA1_OLD ? ""%s %s: unexpected end of input when reading <old-oid>"" : ""%s %s: unexpected end of input when reading <new-oid>""",6,"	die(flags & PARSE_SHA1_OLD ?
	    ""%s %s: unexpected end of input when reading <old-oid>"" :
	    ""%s %s: unexpected end of input when reading <new-oid>"","
implicit_predicate,update-ref.c,195,+,-,"if (parse_next_oid(&next, end, &new_oid, ""update"", refname, PARSE_SHA1_ALLOW_EMPTY))
    die(""update %s: missing <new-oid>"", refname);
",,
implicit_predicate,update-ref.c,206,+,+,have_old ? &old_oid : NULL,18,"				   &new_oid, have_old ? &old_oid : NULL,"
implicit_predicate,update-ref.c,228,+,-,"if (parse_next_oid(&next, end, &new_oid, ""create"", refname, 0))
    die(""create %s: missing <new-oid>"", refname);
",,
implicit_predicate,update-ref.c,259,+,-,"if (parse_next_oid(&next, end, &old_oid, ""delete"", refname, PARSE_SHA1_OLD)){
    have_old = 0;
}else{
    if (is_null_oid(&old_oid))
        die(""delete %s: zero <old-oid>"", refname);

    have_old = 1;
}
",,
implicit_predicate,update-ref.c,272,+,+,have_old ? &old_oid : NULL,8,"				   have_old ? &old_oid : NULL,"
implicit_predicate,update-ref.c,292,+,-,"if (parse_next_oid(&next, end, &old_oid, ""verify"", refname, PARSE_SHA1_OLD))
    oidclr(&old_oid);
",,
implicit_predicate,update-ref.c,427,-,+,,8,			c = command[i].args ? ' ' : line_termination;
implicit_predicate,update-ref.c,526,-,+,,23,	create_reflog_flag = create_reflog ? REF_FORCE_CREATE_REFLOG : 0;
implicit_predicate,update-ref.c,584,-,+,,12,"				       oldval ? &oldoid : NULL,"
implicit_predicate,upload-archive.c,108,+,-,"while (1){
    struct pollfd pfd[2];
    pfd[0].fd = writer.out;
    pfd[0].events = POLLIN;
    pfd[1].fd = writer.err;
    pfd[1].events = POLLIN;
    if (poll(pfd, 2, -1) < 0){
        if (errno != EINTR){
            error_errno(""poll failed resuming"");
            sleep(1);
        }
        continue;
    }
    if (pfd[1].revents & POLLIN)
        if (process_input(pfd[1].fd, 2))
            continue;

    if (pfd[0].revents & POLLIN)
        if (process_input(pfd[0].fd, 1))
            continue;

    if (finish_command(&writer))
        error_clnt(""%s"", deadchild);

    packet_flush(1);
    break;
}
",,
implicit_predicate,upload-pack.c,59,+,-,"if (advertise_refs)
    protocol_v2_advertise_capabilities();
else
    protocol_v2_serve_loop(stateless_rpc);
",,
implicit_predicate,upload-pack.c,179,+,-,"if (use_sideband){
    send_sideband(1, fd, data, sz, use_sideband);
    return;
}
",,
implicit_predicate,upload-pack.c,241,+,-,"if (write_packfile_line){
    if (os->packfile_uris_started)
        packet_delim(1);

    packet_write_fmt(1, ""\1packfile\n"");
}
",,
implicit_predicate,upload-pack.c,242,+,-,"if (os->packfile_uris_started)
    packet_delim(1);
",,
implicit_predicate,upload-pack.c,300,+,-,"if (pack_data->shallow_nr){
    strvec_push(&pack_objects.args, ""--shallow-file"");
    strvec_push(&pack_objects.args, """");
}
",,
implicit_predicate,upload-pack.c,306,+,-,"if (pack_data->use_thin_pack)
    strvec_push(&pack_objects.args, ""--thin"");
",,
implicit_predicate,upload-pack.c,310,+,-,"if (pack_data->shallow_nr)
    strvec_push(&pack_objects.args, ""--shallow"");
",,
implicit_predicate,upload-pack.c,314,+,-,"if (pack_data->use_ofs_delta)
    strvec_push(&pack_objects.args, ""--delta-base-offset"");
",,
implicit_predicate,upload-pack.c,316,+,-,"if (pack_data->use_include_tag)
    strvec_push(&pack_objects.args, ""--include-tag"");
",,
implicit_predicate,upload-pack.c,339,+,-,"if (pack_data->shallow_nr)
    for_each_commit_graft(write_one_shallow, pipe_fd);
",,
implicit_predicate,upload-pack.c,360,+,-,"while (1){
    struct pollfd pfd[2];
    int pe, pu, pollsize, polltimeout;
    int ret;
    reset_timeout(pack_data->timeout);
    pollsize = 0;
    pe = pu = -1;
    if (0 <= pack_objects.out){
        pfd[pollsize].fd = pack_objects.out;
        pfd[pollsize].events = POLLIN;
        pu = pollsize;
        pollsize++;
    }
    if (0 <= pack_objects.err){
        pfd[pollsize].fd = pack_objects.err;
        pfd[pollsize].events = POLLIN;
        pe = pollsize;
        pollsize++;
    }
    if (!pollsize)
        break;

    polltimeout = pack_data->keepalive < 0 ? -1 : 1000 * pack_data->keepalive;
    ret = poll(pfd, pollsize, polltimeout);
    if (ret < 0){
        if (errno != EINTR){
            error_errno(""poll failed, resuming"");
            sleep(1);
        }
        continue;
    }
    if (0 <= pe && (pfd[pe].revents & (POLLIN | POLLHUP))){
        sz = xread(pack_objects.err, progress, sizeof (progress));
        if (0 < sz)
            send_client_data(2, progress, sz, pack_data->use_sideband);
        else
            if (sz == 0){
                close(pack_objects.err);
                pack_objects.err = -1;
            }else
                goto fail;

        continue;
    }
    if (0 <= pu && (pfd[pu].revents & (POLLIN | POLLHUP))){
        int result = relay_pack_data(pack_objects.out, output_state, pack_data->use_sideband, !!uri_protocols);
        if (result == 0){
            close(pack_objects.out);
            pack_objects.out = -1;
        }else
            if (result < 0){
                goto fail;
            }
    }
    if (!ret && pack_data->use_sideband){
        static const char buf[] = ""0005\1"";
        write_or_die(1, buf, 5);
    }
}
",,
implicit_predicate,upload-pack.c,459,+,-,"if (pack_data->use_sideband)
    packet_flush(1);
",,
implicit_predicate,upload-pack.c,552,+,-,"if (data->stateless_rpc)
    exit(0);
",,
implicit_predicate,upload-pack.c,618,+,-,"if (allow_hidden_refs(data->allow_uor))
    excludes = hidden_refs_to_excludes(&data->hidden_refs);
",,
implicit_predicate,upload-pack.c,628,+,+,allow_hidden_refs(allow_uor) ? 0 : HIDDEN_REF,22,	return o->flags & ((allow_hidden_refs(allow_uor) ? 0 : HIDDEN_REF) | OUR_REF);
implicit_predicate,upload-pack.c,674,+,-,"if (is_our_ref(o, allow_uor)){
    if (reachable)
        add_object_array(o, NULL, reachable);

    continue;
}
",,
implicit_predicate,upload-pack.c,757,+,-,"if (i)
    goto error;
",,
implicit_predicate,upload-pack.c,869,+,-,"if (data->deepen_relative){
    struct object_array reachable_shallows = OBJECT_ARRAY_INIT;
    struct commit_list* result;
    refs_head_ref_namespaced(get_main_ref_store(the_repository), check_ref, data);
    for_each_namespaced_ref_1(check_ref, data);
    get_reachable_list(data, &reachable_shallows);
    result = get_shallow_commits(&reachable_shallows, depth + 1, SHALLOW, NOT_SHALLOW);
    send_shallow(data, result);
    free_commit_list(result);
    object_array_clear(&reachable_shallows);
}else{
    struct commit_list* result;
    result = get_shallow_commits(&data->want_obj, depth, SHALLOW, NOT_SHALLOW);
    send_shallow(data, result);
    free_commit_list(result);
}
",,
implicit_predicate,upload-pack.c,923,+,-,"if (data->deepen_rev_list){
    struct strvec av = STRVEC_INIT;
    int i;
    strvec_push(&av, ""rev-list"");
    if (data->deepen_since)
        strvec_pushf(&av, ""--max-age=%"", data->deepen_since);

    if (oidset_size(&data->deepen_not)){
        const struct object_id* oid;
        struct oidset_iter iter;
        strvec_push(&av, ""--not"");
        oidset_iter_init(&data->deepen_not, &iter);
        while ((oid = oidset_iter_next(&iter)))
            strvec_push(&av, oid_to_hex(oid));
        strvec_push(&av, ""--not"");
    }
    for (i = 0;i < data->want_obj.nr;i++){
        struct object* o = data->want_obj.objects[i].item;
        strvec_push(&av, oid_to_hex(&o->oid));
    }
    deepen_by_rev_list(data, av.nr, av.v);
    strvec_clear(&av);
    ret = 1;
}else{
    if (data->shallows.nr > 0){
        int i;
        for (i = 0;i < data->shallows.nr;i++)
            register_shallow(the_repository, &data->shallows.objects[i].item->oid);
    }
}
",,
implicit_predicate,upload-pack.c,1182,+,-,"if (has_non_tip)
    check_non_tip(data);
",,
implicit_predicate,upload-pack.c,1191,+,-,"if (send_shallow_list(data))
    packet_flush(1);
",,
implicit_predicate,upload-pack.c,1230,+,-,"if (d->advertise_sid)
    strbuf_addf(buf, "" session-id=%s"", trace2_session_id());
",,
implicit_predicate,upload-pack.c,1243,+,-,"if (mark_our_ref(refname_nons, refname, oid, &data->hidden_refs))
    return;
",,
implicit_predicate,upload-pack.c,1255,+,+,"(data->allow_uor & ALLOW_TIP_SHA1) ? "" allow-tip-sha1-in-want"" : """"",9,"			     (data->allow_uor & ALLOW_TIP_SHA1) ?
				     "" allow-tip-sha1-in-want"" : """","
implicit_predicate,upload-pack.c,1257,+,+,"(data->allow_uor & ALLOW_REACHABLE_SHA1) ? "" allow-reachable-sha1-in-want"" : """"",9,"			     (data->allow_uor & ALLOW_REACHABLE_SHA1) ?
				     "" allow-reachable-sha1-in-want"" : """","
implicit_predicate,upload-pack.c,1259,+,+,"data->no_done ? "" no-done"" : """"",9,"			     data->no_done ? "" no-done"" : """","
implicit_predicate,upload-pack.c,1261,+,+,"data->allow_filter ? "" filter"" : """"",9,"			     data->allow_filter ? "" filter"" : """","
implicit_predicate,upload-pack.c,1416,+,-,"if (data.timeout)
    data.daemon_mode = 1;
",,
implicit_predicate,upload-pack.c,1458,+,-,"if (data.stateless_rpc)
    reader.options |= PACKET_READ_GENTLE_ON_EOF;
",,
implicit_predicate,upload-pack.c,1598,+,-,"if (parse_want(&data->writer, arg, &data->want_obj))
    continue;
",,
implicit_predicate,upload-pack.c,1605,+,-,"if (parse_have(arg, data))
    continue;
",,
implicit_predicate,upload-pack.c,1635,+,-,"if (process_shallow(arg, &data->shallows))
    continue;
",,
implicit_predicate,upload-pack.c,1637,+,-,"if (process_deepen(arg, &data->depth))
    continue;
",,
implicit_predicate,upload-pack.c,1642,+,-,"if (process_deepen_not(arg, &data->deepen_not, &data->deepen_rev_list))
    continue;
",,
implicit_predicate,upload-pack.c,1714,+,-,"if (data->done){
    ret = 1;
}else
    if (send_acks(data, &data->have_obj)){
        packet_writer_delim(&data->writer);
        ret = 1;
    }else{
        packet_writer_flush(&data->writer);
        ret = 0;
    }
",,
implicit_predicate,upload-pack.c,1716,+,-,"if (send_acks(data, &data->have_obj)){
    packet_writer_delim(&data->writer);
    ret = 1;
}else{
    packet_writer_flush(&data->writer);
    ret = 0;
}
",,
implicit_predicate,upload-pack.c,1795,+,-,"if (data.seen_haves){
    state = FETCH_SEND_ACKS;
}else{
    state = FETCH_SEND_PACK;
}
",,
implicit_predicate,upload-pack.c,1809,+,-,"if (process_haves_and_send_acks(&data))
    state = FETCH_SEND_PACK;
else
    state = FETCH_DONE;
",,
implicit_predicate,upload-pack.c,1846,+,-,"if (data.allow_filter)
    strbuf_addstr(value, "" filter"");
",,
implicit_predicate,upload-pack.c,1849,+,-,"if (data.allow_ref_in_want)
    strbuf_addstr(value, "" ref-in-want"");
",,
implicit_predicate,upload-pack.c,1852,+,-,"if (data.allow_sideband_all)
    strbuf_addstr(value, "" sideband-all"");
",,
implicit_predicate,upload-pack.c,1855,+,-,"if (data.allow_packfile_uris)
    strbuf_addstr(value, "" packfile-uris"");
",,
implicit_predicate,url.c,40,+,-,"while (len){
    unsigned char c = *q;
    if (!c)
        break;

    if (stop_at && strchr(stop_at, c)){
        q++;
        len--;
        break;
    }
    if (c == '%' && (len < 0 || len >= 3)){
        int val = hex2chr(q + 1);
        if (0 < val){
            strbuf_addch(out, val);
            q += 3;
            len -= 3;
            continue;
        }
    }
    if (decode_plus && c == '+')
        strbuf_addch(out, ' ');
    else
        strbuf_addch(out, c);

    q++;
    len--;
}
",,
implicit_predicate,urlmatch.c,241,+,-,"if (allow_globs)
    spanned = strspn(url, ""ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789.-_[:]*"");
else
    spanned = strspn(url, URL_HOST_CHARS);
",,
implicit_predicate,urlmatch.c,320,-,+,,37,		host_len = norm.len - host_off - (port_len ? port_len + 1 : 0);
implicit_predicate,urlmatch.c,550,-,+,,10,		return b->user_matched ? -1 : 1;
implicit_predicate,urlmatch.c,565,-,+,,3,		collect->select_fn ? collect->select_fn : cmp_matches;
implicit_predicate,userdiff.c,466,+,-,"if (regexec_supports_multi_byte_chars())
    driver->word_regex = driver->word_regex_multi_byte;
",,
implicit_predicate,userdiff.c,534,+,-,"if (ret)
    return ret;
",,
implicit_predicate,userdiff.c,540,+,-,"if (ret)
    return ret;
",,
implicit_predicate,utf8.c,131,-,+,,15,	remainder = (remainder_p ? *remainder_p : 999);
implicit_predicate,utf8.c,231,-,+,,28,	return cast_size_t_to_int(string ? width : len);
implicit_predicate,utf8.c,342,+,-,"if (assume_utf8){
    w += utf8_width(&text, NULL);
    if (!text){
        assume_utf8 = 0;
        text = start;
        strbuf_setlen(buf, orig_len);
        goto retry;
    }
}else{
    w++;
    text++;
}
",,
implicit_predicate,utf8.c,435,+,-,"if (same_utf_encoding(""utf-8"", name))
    return 1;
",,
implicit_predicate,utf8.c,448,+,-,"if (same_utf_encoding(src, dst))
    return 1;
",,
implicit_predicate,utf8.c,497,+,-,"while (1){
    size_t cnt = iconv(conv, &cp, &insz, &outpos, &outsz);
    if (cnt == (size_t) - 1){
        size_t sofar;
        if (errno != E2BIG){
            free(out);
            return NULL;
        }
        sofar = outpos - out;
        outalloc = st_add3(sofar, st_mult(insz, 2), 32);
        out = xrealloc(out, outalloc);
        outpos = out + sofar;
        outsz = outalloc - sofar - 1;
    }else{
        *outpos = '\0';
        if (outsz_p)
            *outsz_p = outpos - out;

        break;
    }
}
",,
implicit_predicate,utf8.c,536,+,-,"if (is_encoding_utf8(name))
    return ""UTF-8"";
",,
implicit_predicate,utf8.c,562,+,-,"if (same_utf_encoding(""UTF-16LE-BOM"", in_encoding))
    in_encoding = ""UTF-16"";
",,
implicit_predicate,utf8.c,573,+,-,"if (same_utf_encoding(""UTF-16LE-BOM"", out_encoding)){
    bom_str = utf16_le_bom;
    bom_len = sizeof (utf16_le_bom);
    out_encoding = ""UTF-16LE"";
}else
    if (same_utf_encoding(""UTF-16BE-BOM"", out_encoding)){
        bom_str = utf16_be_bom;
        bom_len = sizeof (utf16_be_bom);
        out_encoding = ""UTF-16BE"";
    }
",,
implicit_predicate,utf8.c,577,+,-,"if (same_utf_encoding(""UTF-16BE-BOM"", out_encoding)){
    bom_str = utf16_be_bom;
    bom_len = sizeof (utf16_be_bom);
    out_encoding = ""UTF-16BE"";
}
",,
implicit_predicate,utf8.c,657,-,+,,14,	size_t r = (remainder_p ? *remainder_p : SIZE_MAX);
implicit_predicate,utf8.c,662,+,-,"if (is_encoding_utf8(encoding)){
    pick_one_utf8_char(&p, &r);
    chrlen = p ? (p - *text) : 1;
}else{
    chrlen = 1;
}
",,
implicit_predicate,utf8.c,665,-,+,,12,"		chrlen = p ? (p - *text)
			   : 1 /* not valid UTF-8 -> raw byte sequence */;"
implicit_predicate,utf8.c,690,+,-,"while (1){
    ucs_char_t out = pick_one_utf8_char(in, NULL);
    if (!*in)
        return 0;

    switch (out){
        case 0x200c:
        case 0x200d:
        case 0x200e:
        case 0x200f:
        case 0x202a:
        case 0x202b:
        case 0x202c:
        case 0x202d:
        case 0x202e:
        case 0x206a:
        case 0x206b:
        case 0x206c:
        case 0x206d:
        case 0x206e:
        case 0x206f:
        case 0xfeff:
            continue;
    }
    return out;
}
",,
implicit_predicate,varint.c,9,+,-,"while (c & 128){
    val += 1;
    if (!val || MSB(val, 7))
        return 0;

    c = *buf++;
    val = (val << 7) + (c & 127);
}
",,
implicit_predicate,verify-commit.c,71,+,-,"if (verbose)
    flags |= GPG_VERIFY_VERBOSE;
",,
implicit_predicate,verify-commit.c,78,+,-,"if (verify_commit(argv[i++], flags))
    had_error = 1;
",,
implicit_predicate,verify-pack.c,22,+,-,"if (stat_only)
    strvec_push(argv, ""--verify-stat-only"");
else
    if (verbose)
        strvec_push(argv, ""--verify-stat"");
    else
        strvec_push(argv, ""--verify"");
",,
implicit_predicate,verify-pack.c,24,+,-,"if (verbose)
    strvec_push(argv, ""--verify-stat"");
else
    strvec_push(argv, ""--verify"");
",,
implicit_predicate,verify-pack.c,47,+,-,"if (err)
    printf(""%s: bad\n"", arg.buf);
else{
    if (!stat_only)
        printf(""%s: ok\n"", arg.buf);
}
",,
implicit_predicate,verify-pack.c,86,+,-,"if (verify_one_pack(argv[i], flags, object_format))
    err = 1;
",,
implicit_predicate,verify-tag.c,41,+,-,"if (verbose)
    flags |= GPG_VERIFY_VERBOSE;
",,
implicit_predicate,walker.c,31,-,+,,3,"		obj->type ? type_name(obj->type): ""object"","
implicit_predicate,walker.c,123,+,-,"if (process_commit(walker, (struct commit*)obj))
    return -1;
",,
implicit_predicate,walker.c,128,+,-,"if (process_tree(walker, (struct tree*)obj))
    return -1;
",,
implicit_predicate,walker.c,136,+,-,"if (process_tag(walker, (struct tag*)obj))
    return -1;
",,
implicit_predicate,walker.c,195,+,-,"if (process_object(walker, obj)){
    stop_progress(&progress);
    return -1;
}
",,
implicit_predicate,walker.c,241,+,-,"while (1){
    char* rf_one = NULL;
    char* tg_one;
    if (strbuf_getline_lf(&buf, stdin) == EOF)
        break;

    tg_one = buf.buf;
    rf_one = strchr(tg_one, '\t');
    if (rf_one)
        *rf_one++ = 0;

    if (targets >= targets_alloc){
        targets_alloc = targets_alloc ? targets_alloc * 2 : 64;
        REALLOC_ARRAY(*target, targets_alloc);
        REALLOC_ARRAY(*write_ref, targets_alloc);
    }
    (*target)[targets] = xstrdup(tg_one);
    (*write_ref)[targets] = xstrdup_or_null(rf_one);
    targets++;
}
",,
implicit_predicate,walker.c,253,+,+,targets_alloc ? targets_alloc * 2 : 64,20,			targets_alloc = targets_alloc ? targets_alloc * 2 : 64;
implicit_predicate,walker.c,267,+,-,"while (targets--){
    free(target[targets]);
    if (write_ref)
        free((char*)write_ref[targets]);
}
",,
implicit_predicate,walker.c,304,+,-,"if (interpret_target(walker, target[i], oids + i)){
    error(""Could not interpret response from server '%s' as something to pull"", target[i]);
    goto done;
}
",,
implicit_predicate,walker.c,312,+,-,"if (loop(walker))
    goto done;
",,
implicit_predicate,walker.c,330,-,+,,9,"					   msg ? msg : ""fetch (unknown)"","
implicit_predicate,wildmatch.c,115,-,+,,19,				match_slash = flags & WM_PATHNAME ? 0 : 1;
implicit_predicate,wildmatch.c,137,+,-,"while (1){
    if (t_ch == '\0')
        break;

    if (!is_glob_special(*p)){
        p_ch = *p;
        if ((flags & WM_CASEFOLD) && ISUPPER(p_ch))
            p_ch = tolower(p_ch);

        while ((t_ch = *text) != '\0' && (match_slash || t_ch != '/')){
            if ((flags & WM_CASEFOLD) && ISUPPER(t_ch))
                t_ch = tolower(t_ch);

            if (t_ch == p_ch)
                break;

            text++;
        }
        if (t_ch != p_ch){
            if (match_slash)
                return WM_ABORT_ALL;
            else
                return WM_ABORT_TO_STARSTAR;
        }
    }
    if ((matched = dowild(p, text, flags)) != WM_NOMATCH){
        if (!match_slash || matched != WM_ABORT_TO_STARSTAR)
            return matched;
    }else
        if (!match_slash && t_ch == '/')
            return WM_ABORT_TO_STARSTAR;

    t_ch = *++text;
}
",,
implicit_predicate,wildmatch.c,161,+,-,"if (match_slash)
    return WM_ABORT_ALL;
else
    return WM_ABORT_TO_STARSTAR;
",,
implicit_predicate,wildmatch.c,183,+,-,"if (negated){
    p_ch = *++p;
}
",,
implicit_predicate,wildmatch.c,279,-,+,,9,	return *text ? WM_NOMATCH : WM_MATCH;
implicit_predicate,winansi.c,161,+,-,"if (negative){
    attributes &= ~FOREGROUND_ALL;
    attributes &= ~BACKGROUND_ALL;
    if (attr & FOREGROUND_RED)
        attributes |= BACKGROUND_RED;

    if (attr & FOREGROUND_GREEN)
        attributes |= BACKGROUND_GREEN;

    if (attr & FOREGROUND_BLUE)
        attributes |= BACKGROUND_BLUE;

    if (attr & BACKGROUND_RED)
        attributes |= FOREGROUND_RED;

    if (attr & BACKGROUND_GREEN)
        attributes |= FOREGROUND_GREEN;

    if (attr & BACKGROUND_BLUE)
        attributes |= FOREGROUND_BLUE;
}
",,
implicit_predicate,winansi.c,655,+,-,"if (con1)
    hconsole1 = swap_osfhnd(1, duplicate_handle(hwrite));
",,
implicit_predicate,winansi.c,657,+,-,"if (con2)
    hconsole2 = swap_osfhnd(2, duplicate_handle(hwrite));
",,
implicit_predicate,worktree.c,151,+,-,"if (ret)
    error_errno(_(""failed to delete '%s'""), sb.buf);
",,
implicit_predicate,worktree.c,247,+,-,"if (ac)
    usage_with_options(git_worktree_prune_usage, options);
",,
implicit_predicate,worktree.c,252,+,-,"if (is_main_worktree(wt))
    return NULL;
",,
implicit_predicate,worktree.c,254,+,-,"if (is_main_worktree(wt))
    return NULL;
",,
implicit_predicate,worktree.c,279,+,-,"if (is_main_worktree(wt))
    return NULL;
",,
implicit_predicate,worktree.c,281,+,-,"if (is_main_worktree(wt))
    return NULL;
",,
implicit_predicate,worktree.c,317,+,-,"if (is_main_worktree(wt)){
    if (is_directory(wt_path.buf)){
        ret = 0;
        goto done;
    }
    strbuf_addf_gently(errmsg, _(""'%s' at main working tree is not the repository directory""), wt_path.buf);
    goto done;
}
",,
implicit_predicate,worktree.c,319,+,-,"if (is_main_worktree(wt)){
    if (is_directory(wt_path.buf)){
        ret = 0;
        goto done;
    }
    strbuf_addf_gently(errmsg, _(""'%s' at main working tree is not the repository directory""), wt_path.buf);
    goto done;
}
",,
implicit_predicate,worktree.c,324,+,-,"if (locked)
    die(_(""'%s' is a missing but locked worktree;\nuse '%s -f -f' to override, or 'unlock' and 'prune' or 'remove' to clear""), path, cmd);
else
    die(_(""'%s' is a missing but already registered worktree;\nuse '%s -f' to override, or 'prune' or 'remove' to clear""), path, cmd);
",,
implicit_predicate,worktree.c,366,+,-,"if (ret)
    strbuf_addf_gently(errmsg, _(""'%s' does not point back to '%s'""), wt->path, git_common_path(""worktrees/%s"", wt->id));
",,
implicit_predicate,worktree.c,368,+,-,"if (ret)
    strbuf_addf_gently(errmsg, _(""'%s' does not point back to '%s'""), wt->path, git_common_path(""worktrees/%s"", wt->id));
",,
implicit_predicate,worktree.c,380,+,-,"if (is_main_worktree(wt))
    BUG(""can't relocate main worktree"");
",,
implicit_predicate,worktree.c,382,+,-,"if (is_main_worktree(wt))
    BUG(""can't relocate main worktree"");
",,
implicit_predicate,worktree.c,442,+,-,"if (is_worktree_being_rebased(wt, target))
    return 1;
",,
implicit_predicate,worktree.c,444,+,-,"if (is_worktree_being_rebased(wt, target))
    return 1;
",,
implicit_predicate,worktree.c,446,+,-,"if (is_worktree_being_bisected(wt, target))
    return 1;
",,
implicit_predicate,worktree.c,464,+,-,"if (is_shared_symref(worktrees[i], symref, target))
    return worktrees[i];
",,
implicit_predicate,worktree.c,466,+,-,"if (is_shared_symref(worktrees[i], symref, target))
    return worktrees[i];
",,
implicit_predicate,worktree.c,513,+,-,"if (ret)
    goto done;
",,
implicit_predicate,worktree.c,521,+,-,"if (ret)
    goto done;
",,
implicit_predicate,worktree.c,523,+,-,"if (is_main_worktree(wt))
    strbuf_addstr(sb, ""main-worktree/"");
else
    strbuf_addf(sb, ""worktrees/%s/"", wt->id);
",,
implicit_predicate,worktree.c,525,+,-,"if (is_main_worktree(wt))
    strbuf_addstr(sb, ""main-worktree/"");
else
    strbuf_addf(sb, ""worktrees/%s/"", wt->id);
",,
implicit_predicate,worktree.c,553,+,-,"if (ret)
    break;
",,
implicit_predicate,worktree.c,555,+,-,"if (ret)
    break;
",,
implicit_predicate,worktree.c,589,+,-,"if (err)
    repair = _("".git file broken"");
else
    if (fspathcmp(backlink, repo.buf))
        repair = _("".git file incorrect"");
",,
implicit_predicate,worktree.c,591,+,-,"if (err)
    repair = _("".git file broken"");
else
    if (fspathcmp(backlink, repo.buf))
        repair = _("".git file incorrect"");
",,
implicit_predicate,worktree.c,595,+,-,"if (force_new_branch){
    struct commit* commit = lookup_commit_reference_by_name(new_branch);
    if (!commit)
        fprintf_ln(stderr, _(""Preparing worktree (new branch '%s')""), new_branch);
    else
        fprintf_ln(stderr, _(""Preparing worktree (resetting branch '%s'; was at %s)""), new_branch, repo_find_unique_abbrev(the_repository, &commit->object.oid, DEFAULT_ABBREV));
}else
    if (new_branch){
        fprintf_ln(stderr, _(""Preparing worktree (new branch '%s')""), new_branch);
    }else{
        struct strbuf s = STRBUF_INIT;
        if (!detach && !strbuf_check_branch_ref(&s, branch) && refs_ref_exists(get_main_ref_store(the_repository), s.buf))
            fprintf_ln(stderr, _(""Preparing worktree (checking out '%s')""), branch);
        else{
            struct commit* commit = lookup_commit_reference_by_name(branch);
            if (!commit)
                BUG(_(""unreachable: invalid reference: %s""), branch);

            fprintf_ln(stderr, _(""Preparing worktree (detached HEAD %s)""), repo_find_unique_abbrev(the_repository, &commit->object.oid, DEFAULT_ABBREV));
        }
        strbuf_release(&s);
    }
",,
implicit_predicate,worktree.c,695,+,-,"if (is_main_worktree_path(path))
    goto done;
",,
implicit_predicate,worktree.c,697,+,-,"if (is_main_worktree_path(path))
    goto done;
",,
implicit_predicate,worktree.c,713,+,-,"if (err){
    fn(1, realdotgit.buf, _(""unable to locate repository; .git file broken""), cb_data);
    goto done;
}
",,
implicit_predicate,worktree.c,715,+,-,"if (err){
    fn(1, realdotgit.buf, _(""unable to locate repository; .git file broken""), cb_data);
    goto done;
}
",,
implicit_predicate,worktree.c,721,+,-,"if (can_use_local_refs(opts)){
    return 0;
}else
    if (remote && can_use_remote_refs(opts)){
        return 0;
    }else
        if (!opts->quiet){
            fprintf_ln(stderr, WORKTREE_ADD_DWIM_ORPHAN_INFER_TEXT);
        }
",,
implicit_predicate,worktree.c,729,+,-,"if (opt_track){
    die(_(""options '%s' and '%s' cannot be used together""), ""--orphan"", ""--track"");
}else
    if (!opts->checkout){
        die(_(""options '%s' and '%s' cannot be used together""), ""--orphan"", ""--no-checkout"");
    }
",,
implicit_predicate,worktree.c,753,+,-,"if (branch_exists)
    return branchname;
",,
implicit_predicate,worktree.c,757,+,-,"if (guess_remote){
    struct object_id oid;
    const char* remote = unique_tracking_name(*new_branch, &oid, NULL);
    return remote;
}
",,
implicit_predicate,worktree.c,822,+,-,"if (keep_locked)
    opts.keep_locked = _(""added with --lock"");
",,
implicit_predicate,worktree.c,848,+,-,"if ((res = move_config_setting(""core.bare"", ""true"", common_config_file, main_worktree_file)))
    goto cleanup;
",,
implicit_predicate,worktree.c,850,+,-,"if ((res = move_config_setting(""core.bare"", ""true"", common_config_file, main_worktree_file)))
    goto cleanup;
",,
implicit_predicate,worktree.c,851,+,-,"if (opts.orphan){
    ;
}else
    if (opts.detach){
        if (!strcmp(branch, ""HEAD""))
            can_use_local_refs(&opts);
    }else
        if (ac < 2 && new_branch){
            opts.orphan = dwim_orphan(&opts, !!opt_track, 0);
        }else
            if (ac < 2){
                const char* s = dwim_branch(path, &new_branch);
                if (s)
                    branch = s;

                opts.orphan = (!s) && dwim_orphan(&opts, !!opt_track, 1);
            }else
                if (ac == 2){
                    struct object_id oid;
                    struct commit* commit;
                    const char* remote;
                    commit = lookup_commit_reference_by_name(branch);
                    if (!commit){
                        remote = unique_tracking_name(branch, &oid, NULL);
                        if (remote){
                            new_branch = branch;
                            branch = remote;
                        }
                    }
                    if (!strcmp(branch, ""HEAD""))
                        can_use_local_refs(&opts);
                }
",,
implicit_predicate,worktree.c,853,+,-,"if (opts.detach){
    if (!strcmp(branch, ""HEAD""))
        can_use_local_refs(&opts);
}else
    if (ac < 2 && new_branch){
        opts.orphan = dwim_orphan(&opts, !!opt_track, 0);
    }else
        if (ac < 2){
            const char* s = dwim_branch(path, &new_branch);
            if (s)
                branch = s;

            opts.orphan = (!s) && dwim_orphan(&opts, !!opt_track, 1);
        }else
            if (ac == 2){
                struct object_id oid;
                struct commit* commit;
                const char* remote;
                commit = lookup_commit_reference_by_name(branch);
                if (!commit){
                    remote = unique_tracking_name(branch, &oid, NULL);
                    if (remote){
                        new_branch = branch;
                        branch = remote;
                    }
                }
                if (!strcmp(branch, ""HEAD""))
                    can_use_local_refs(&opts);
            }
",,
implicit_predicate,worktree.c,860,+,-,"if ((res = move_config_setting(""core.worktree"", core_worktree, common_config_file, main_worktree_file)))
    goto cleanup;
",,
implicit_predicate,worktree.c,862,+,-,"if ((res = move_config_setting(""core.worktree"", core_worktree, common_config_file, main_worktree_file)))
    goto cleanup;
",,
implicit_predicate,worktree.c,893,+,-,"if (attempt_hint){
    advise_if_enabled(ADVICE_WORKTREE_ADD_ORPHAN, WORKTREE_ADD_ORPHAN_NO_DASH_B_HINT_TEXT, path);
}
",,
implicit_predicate,worktree.c,903,+,-,"if (opts.orphan){
    branch = new_branch;
}else
    if (new_branch){
        struct child_process cp = CHILD_PROCESS_INIT;
        cp.git_cmd = 1;
        strvec_push(&cp.args, ""branch"");
        if (new_branch_force)
            strvec_push(&cp.args, ""--force"");

        if (opts.quiet)
            strvec_push(&cp.args, ""--quiet"");

        strvec_push(&cp.args, new_branch);
        strvec_push(&cp.args, branch);
        if (opt_track)
            strvec_push(&cp.args, opt_track);

        if (run_command(&cp))
            return -1;

        branch = new_branch;
    }else
        if (opt_track){
            die(_(""--[no-]track can only be used if a new branch is created""));
        }
",,
implicit_predicate,worktree.c,911,+,-,"if (opts.quiet)
    strvec_push(&cp.args, ""--quiet"");
",,
implicit_predicate,worktree.c,1053,+,-,"if (ac)
    usage_with_options(git_worktree_list_usage, options);
else
    if (verbose && porcelain)
        die(_(""options '%s' and '%s' cannot be used together""), ""--verbose"", ""--porcelain"");
    else
        if (!line_terminator && !porcelain)
            die(_(""the option '%s' requires '%s'""), ""-z"", ""--porcelain"");
        else{
            struct worktree** worktrees = get_worktrees();
            int path_maxlen = 0, abbrev = DEFAULT_ABBREV, i;
            pathsort(worktrees + 1);
            if (!porcelain)
                measure_widths(worktrees, &abbrev, &path_maxlen);

            for (i = 0;worktrees[i];i++){
                if (porcelain)
                    show_worktree_porcelain(worktrees[i], line_terminator);
                else
                    show_worktree(worktrees[i], path_maxlen, abbrev);
            }
            free_worktrees(worktrees);
        }
",,
implicit_predicate,worktree.c,1070,+,-,"if (porcelain)
    show_worktree_porcelain(worktrees[i], line_terminator);
else
    show_worktree(worktrees[i], path_maxlen, abbrev);
",,
implicit_predicate,worktree.c,1175,+,-,"if (found_submodules)
    die(_(""working trees containing submodules cannot be moved or removed""));
",,
implicit_predicate,worktree.c,1281,+,-,"if (ret)
    die_errno(_(""failed to run 'git status' on '%s'""), original_path);
",,
implicit_predicate,worktree.c,1285,+,-,"if (ret)
    die(_(""'%s' contains modified or untracked files, use --force to delete it""), original_path);
",,
implicit_predicate,worktree.c,1290,+,-,"if (ret)
    die_errno(_(""failed to run 'git status' on '%s', code %d""), original_path, ret);
",,
implicit_predicate,wrapper.c,80,+,-,"if (gentle){
    error(""Data too large to fit into virtual memory space."");
    return NULL;
}else
    die(""Data too large to fit into virtual memory space."");
",,
implicit_predicate,wrapper.c,116,-,+,,23,"	return xmemdupz(str, p ? p - str : len);"
implicit_predicate,wrapper.c,122,+,-,"if (res)
    return res;
",,
implicit_predicate,wrapper.c,162,-,+,,41,"		die_errno(_(""could not setenv '%s'""), name ? name : ""(null)"");"
implicit_predicate,wrapper.c,230,+,-,"while (1){
    nr = read(fd, buf, len);
    if (nr < 0){
        if (errno == EINTR)
            continue;

        if (handle_nonblock(fd, POLLIN, errno))
            continue;
    }
    return nr;
}
",,
implicit_predicate,wrapper.c,252,+,-,"while (1){
    nr = write(fd, buf, len);
    if (nr < 0){
        if (errno == EINTR)
            continue;

        if (handle_nonblock(fd, POLLOUT, errno))
            continue;
    }
    return nr;
}
",,
implicit_predicate,wrapper.c,275,+,-,"while (1){
    nr = pread(fd, buf, len, offset);
    if ((nr < 0) && (errno == EAGAIN || errno == EINTR))
        continue;

    return nr;
}
",,
implicit_predicate,writer.c,267,+,-,"if (err){
    err = REFTABLE_ENTRY_TOO_BIG_ERROR;
    goto done;
}
",,
implicit_predicate,writer.c,268,+,-,"if (err){
    err = REFTABLE_ENTRY_TOO_BIG_ERROR;
    goto done;
}
",,
implicit_predicate,writer.c,406,-,+,,21,	size_t threshold = w->opts.unpadded ? 1 : 3;
implicit_predicate,writer.c,615,+,-,"if (empty_table){
    uint8_t header[28];
    int n = writer_write_header(w, header);
    err = padded_write(w, header, n, 0);
    if (err < 0)
        goto done;
}
",,
implicit_predicate,writer.c,616,+,-,"if (empty_table){
    uint8_t header[28];
    int n = writer_write_header(w, header);
    err = padded_write(w, header, n, 0);
    if (err < 0)
        goto done;
}
",,
implicit_predicate,writer.c,650,+,-,"if (empty_table){
    err = REFTABLE_EMPTY_TABLE_ERROR;
    goto done;
}
",,
implicit_predicate,writer.c,651,+,-,"if (empty_table){
    err = REFTABLE_EMPTY_TABLE_ERROR;
    goto done;
}
",,
implicit_predicate,ws.c,54,+,-,"if (negated)
    rule &= ~whitespace_rule_names[i].rule_bits;
else
    rule |= whitespace_rule_names[i].rule_bits;
",,
implicit_predicate,ws.c,240,+,-,"if (trailing_carriage_return)
    fputc('\r', stream);
",,
implicit_predicate,ws.c,242,+,-,"if (trailing_newline)
    fputc('\n', stream);
",,
implicit_predicate,ws.c,329,+,-,"if (need_fix_leading_space){
    int consecutive_spaces = 0;
    int last = last_tab_in_indent + 1;
    if (ws_rule & WS_INDENT_WITH_NON_TAB){
        if (last_tab_in_indent < last_space_in_indent)
            last = last_space_in_indent + 1;
        else
            last = last_tab_in_indent + 1;
    }
    for (i = 0;i < last;i++){
        char ch = src[i];
        if (ch != ' '){
            consecutive_spaces = 0;
            strbuf_addch(dst, ch);
        }else{
            consecutive_spaces++;
            if (consecutive_spaces == ws_tab_width(ws_rule)){
                strbuf_addch(dst, '\t');
                consecutive_spaces = 0;
            }
        }
    }
    while (0 < consecutive_spaces--)
        strbuf_addch(dst, ' ');
    len -= last;
    src += last;
    fixed = 1;
}else
    if ((ws_rule & WS_TAB_IN_INDENT) && last_tab_in_indent >= 0){
        int start = dst->len;
        int last = last_tab_in_indent + 1;
        for (i = 0;i < last;i++){
            if (src[i] == '\t')
                do{
                    strbuf_addch(dst, ' ');
                } while ((dst->len - start) % ws_tab_width(ws_rule));
            else
                strbuf_addch(dst, src[i]);
        }
        len -= last;
        src += last;
        fixed = 1;
    }
",,
implicit_predicate,ws.c,382,+,-,"if (add_cr_to_tail)
    strbuf_addch(dst, '\r');
",,
implicit_predicate,ws.c,384,+,-,"if (add_nl_to_tail)
    strbuf_addch(dst, '\n');
",,
implicit_predicate,wt-status.c,257,+,-,"if (has_dirty_submodules)
    status_printf_ln(s, c, _(""  (commit or discard the untracked or modified content in submodules)""));
",,
implicit_predicate,wt-status.c,329,-,+,,13,		int len = s ? utf8_strwidth(s) : 0;
implicit_predicate,wt-status.c,644,-,+,,12,	opt.def = s->is_initial ? empty_tree_oid_hex() : s->reference;
implicit_predicate,wt-status.c,886,+,-,"if (shown_header)
    wt_longstatus_print_trailer(s);
",,
implicit_predicate,wt-status.c,910,+,-,"if (shown_header)
    wt_longstatus_print_trailer(s);
",,
implicit_predicate,wt-status.c,1007,+,+,"uncommitted ? ""--files"" : ""--cached""",32,"	strvec_push(&sm_summary.args, uncommitted ? ""--files"" : ""--cached"");"
implicit_predicate,wt-status.c,1012,-,+,,33,"		strvec_push(&sm_summary.args, s->amend ? ""HEAD^"" : ""HEAD"");"
implicit_predicate,wt-status.c,1021,+,-,"if (uncommitted)
    strbuf_addstr(&summary, _(""Submodules changed but not updated:""));
else
    strbuf_addstr(&summary, _(""Submodule changes to be committed:""));
",,
implicit_predicate,wt-status.c,1076,-,+,,7,"		    s->display_comment_prefix ? ""#"" : """","
implicit_predicate,wt-status.c,1139,-,+,,12,	opt.def = s->is_initial ? empty_tree_oid_hex() : s->reference;
implicit_predicate,wt-status.c,1215,-,+,,6,"				 s->display_comment_prefix ? comment_line_str : """","
implicit_predicate,wt-status.c,1216,-,+,,6,"				 s->display_comment_prefix ? "" "" : """","
implicit_predicate,wt-status.c,1236,+,-,"if (has_unmerged(s)){
    status_printf_ln(s, color, _(""You have unmerged paths.""));
    if (s->hints){
        status_printf_ln(s, color, _(""  (fix conflicts and run \""git commit\"")""));
        status_printf_ln(s, color, _(""  (use \""git merge --abort\"" to abort the merge)""));
    }
}else{
    status_printf_ln(s, color, _(""All conflicts fixed but you are still merging.""));
    if (s->hints)
        status_printf_ln(s, color, _(""  (use \""git commit\"" to conclude merge)""));
}
",,
implicit_predicate,wt-status.c,1271,+,-,"if (am_empty_patch)
    status_printf_ln(s, color, _(""  (use \""git am --allow-empty\"" to record this patch as an empty commit)""));
",,
implicit_predicate,wt-status.c,1411,+,-,"if (read_rebase_todolist(""rebase-merge/git-rebase-todo"", &yet_to_do))
    status_printf_ln(s, color, _(""git-rebase-todo is missing.""));
",,
implicit_predicate,wt-status.c,1472,+,-,"if (has_unmerged(s)){
    print_rebase_state(s, color);
    if (s->hints){
        status_printf_ln(s, color, _(""  (fix conflicts and then run \""git rebase --continue\"")""));
        status_printf_ln(s, color, _(""  (use \""git rebase --skip\"" to skip this patch)""));
        status_printf_ln(s, color, _(""  (use \""git rebase --abort\"" to check out the original branch)""));
    }
}else
    if (s->state.rebase_in_progress || !stat(git_path_merge_msg(s->repo), &st)){
        print_rebase_state(s, color);
        if (s->hints)
            status_printf_ln(s, color, _(""  (all conflicts fixed: run \""git rebase --continue\"")""));
    }else
        if (split_commit_in_progress(s)){
            if (s->state.branch)
                status_printf_ln(s, color, _(""You are currently splitting a commit while rebasing branch '%s' on '%s'.""), s->state.branch, s->state.onto);
            else
                status_printf_ln(s, color, _(""You are currently splitting a commit during a rebase.""));

            if (s->hints)
                status_printf_ln(s, color, _(""  (Once your working directory is clean, run \""git rebase --continue\"")""));
        }else{
            if (s->state.branch)
                status_printf_ln(s, color, _(""You are currently editing a commit while rebasing branch '%s' on '%s'.""), s->state.branch, s->state.onto);
            else
                status_printf_ln(s, color, _(""You are currently editing a commit during a rebase.""));

            if (s->hints && !s->amend){
                status_printf_ln(s, color, _(""  (use \""git commit --amend\"" to amend the current commit)""));
                status_printf_ln(s, color, _(""  (use \""git rebase --continue\"" once you are satisfied with your changes)""));
            }
        }
",,
implicit_predicate,wt-status.c,1488,+,-,"if (split_commit_in_progress(s)){
    if (s->state.branch)
        status_printf_ln(s, color, _(""You are currently splitting a commit while rebasing branch '%s' on '%s'.""), s->state.branch, s->state.onto);
    else
        status_printf_ln(s, color, _(""You are currently splitting a commit during a rebase.""));

    if (s->hints)
        status_printf_ln(s, color, _(""  (Once your working directory is clean, run \""git rebase --continue\"")""));
}else{
    if (s->state.branch)
        status_printf_ln(s, color, _(""You are currently editing a commit while rebasing branch '%s' on '%s'.""), s->state.branch, s->state.onto);
    else
        status_printf_ln(s, color, _(""You are currently editing a commit during a rebase.""));

    if (s->hints && !s->amend){
        status_printf_ln(s, color, _(""  (use \""git commit --amend\"" to amend the current commit)""));
        status_printf_ln(s, color, _(""  (use \""git rebase --continue\"" once you are satisfied with your changes)""));
    }
}
",,
implicit_predicate,wt-status.c,1532,+,-,"if (has_unmerged(s))
    status_printf_ln(s, color, _(""  (fix conflicts and run \""git cherry-pick --continue\"")""));
else
    if (is_null_oid(&s->state.cherry_pick_head_oid))
        status_printf_ln(s, color, _(""  (run \""git cherry-pick --continue\"" to continue)""));
    else
        status_printf_ln(s, color, _(""  (all conflicts fixed: run \""git cherry-pick --continue\"")""));
",,
implicit_predicate,wt-status.c,1561,+,-,"if (has_unmerged(s))
    status_printf_ln(s, color, _(""  (fix conflicts and run \""git revert --continue\"")""));
else
    if (is_null_oid(&s->state.revert_head_oid))
        status_printf_ln(s, color, _(""  (run \""git revert --continue\"" to continue)""));
    else
        status_printf_ln(s, color, _(""  (all conflicts fixed: run \""git revert --continue\"")""));
",,
implicit_predicate,wt-status.c,1814,+,-,"if (get_detached_from)
    wt_status_get_detached_from(r, state);
",,
implicit_predicate,wt-status.c,1887,-,+,,6,"				 s->commit_template
				 ? _(""Initial commit"")
				 : _(""No commits yet""));"
implicit_predicate,wt-status.c,1924,-,+,,4,"			s->hints
			? _("" (use -u option to show untracked files)"") : """");"
implicit_predicate,wt-status.c,2102,+,-,"if (upstream_is_gone){
    color_fprintf(s->fp, header_color, LABEL(N_(""gone"")));
}else
    if (s->ahead_behind_flags == AHEAD_BEHIND_QUICK){
        color_fprintf(s->fp, header_color, LABEL(N_(""different"")));
    }else
        if (!num_ours){
            color_fprintf(s->fp, header_color, LABEL(N_(""behind "")));
            color_fprintf(s->fp, branch_color_remote, ""%d"", num_theirs);
        }else
            if (!num_theirs){
                color_fprintf(s->fp, header_color, LABEL(N_(""ahead "")));
                color_fprintf(s->fp, branch_color_local, ""%d"", num_ours);
            }else{
                color_fprintf(s->fp, header_color, LABEL(N_(""ahead "")));
                color_fprintf(s->fp, branch_color_local, ""%d"", num_ours);
                color_fprintf(s->fp, header_color, "", %s"", LABEL(N_(""behind "")));
                color_fprintf(s->fp, branch_color_remote, ""%d"", num_theirs);
            }
",,
implicit_predicate,wt-status.c,2121,-,+,,8,"	fputc(s->null_termination ? '\0' : '\n', s->fp);"
implicit_predicate,wt-status.c,2194,-,+,,13,	char eol = s->null_termination ? '\0' : '\n';
implicit_predicate,wt-status.c,2197,-,+,,5,"			(s->is_initial ? ""(initial)"" : oid_to_hex(&s->oid_commit)),"
implicit_predicate,wt-status.c,2253,-,+,,13,	char eol = s->null_termination ? '\0' : '\n';
implicit_predicate,wt-status.c,2271,-,+,,12,		sub[1] = d->new_submodule_commits ? 'C' : '.';
implicit_predicate,wt-status.c,2272,-,+,,12,		sub[2] = (d->dirty_submodule & DIRTY_SUBMODULE_MODIFIED) ? 'M' : '.';
implicit_predicate,wt-status.c,2273,-,+,,12,		sub[3] = (d->dirty_submodule & DIRTY_SUBMODULE_UNTRACKED) ? 'U' : '.';
implicit_predicate,wt-status.c,2349,-,+,,11,	key[0] = d->index_status ? d->index_status : '.';
implicit_predicate,wt-status.c,2350,-,+,,11,	key[1] = d->worktree_status ? d->worktree_status : '.';
implicit_predicate,wt-status.c,2414,-,+,,18,	char eol_char = s->null_termination ? '\0' : '\n';
implicit_predicate,wt-status.c,2588,+,-,"if (ignore_submodules){
    rev_info.diffopt.flags.ignore_submodules = 1;
    rev_info.diffopt.flags.override_submodule_config = 1;
}
",,
implicit_predicate,wt-status.c,2613,+,-,"if (ignore_submodules)
    rev_info.diffopt.flags.ignore_submodules = 1;
",,
implicit_predicate,wt-status.c,2653,+,-,"if (has_unstaged_changes(r, ignore_submodules)){
    error(_(""cannot %s: You have unstaged changes.""), _(action));
    err = 1;
}
",,
implicit_predicate,wt-status.c,2659,+,-,"if (has_uncommitted_changes(r, ignore_submodules)){
    if (err)
        error(_(""additionally, your index contains uncommitted changes.""));
    else
        error(_(""cannot %s: Your index contains uncommitted changes.""), _(action));

    err = 1;
}
",,
implicit_predicate,wt-status.c,2660,+,-,"if (err)
    error(_(""additionally, your index contains uncommitted changes.""));
else
    error(_(""cannot %s: Your index contains uncommitted changes.""), _(action));
",,
implicit_predicate,wt-status.c,2668,+,-,"if (err){
    if (hint){
        if (!*hint)
            BUG(""empty hint passed to require_clean_work_tree(); use NULL instead"");

        error(""%s"", hint);
    }
    if (!gently)
        exit(128);
}
",,
implicit_predicate,xdiff-interface.c,39,+,-,"while (size){
    unsigned long this_size;
    int ret;
    ep = memchr(s, '\n', size);
    this_size = (ep == NULL) ? size : (ep - s + 1);
    ret = priv->line_fn(priv->consume_callback_data, s, this_size);
    if (ret)
        return ret;

    size -= this_size;
    s += this_size;
}
",,
implicit_predicate,xdiff-interface.c,45,+,-,"if (ret)
    return ret;
",,
implicit_predicate,xdiff-interface.c,63,+,-,"if (stop)
    return 1;
",,
implicit_predicate,xdiff-interface.c,80,+,-,"if (stop)
    return -1;
",,
implicit_predicate,xdiff-interface.c,86,+,-,"if (stop)
    return -1;
",,
implicit_predicate,xdiff-interface.c,99,-,+,,13,	char *ap = a->size ? a->ptr + a->size : a->ptr;
implicit_predicate,xdiff-interface.c,100,-,+,,13,	char *bp = b->size ? b->ptr + b->size : b->ptr;
implicit_predicate,xdiff-interface.c,166,-,+,,21,	ptr->ptr = xmalloc(sz ? sz : 1);
implicit_predicate,xdiff-interface.c,278,-,+,,11,		value = ep ? ep + 1 : NULL;
implicit_predicate,xdiffi.c,139,+,-,"if (need_min)
    continue;
",,
implicit_predicate,xdiffi.c,640,+,+,any_blanks ? RELATIVE_INDENT_WITH_BLANK_PENALTY : RELATIVE_INDENT_PENALTY,17,"		s->penalty += any_blanks ?
			RELATIVE_INDENT_WITH_BLANK_PENALTY :
			RELATIVE_INDENT_PENALTY;"
implicit_predicate,xdiffi.c,661,+,+,any_blanks ? RELATIVE_OUTDENT_WITH_BLANK_PENALTY : RELATIVE_OUTDENT_PENALTY,18,"			s->penalty += any_blanks ?
				RELATIVE_OUTDENT_WITH_BLANK_PENALTY :
				RELATIVE_OUTDENT_PENALTY;"
implicit_predicate,xdiffi.c,668,+,+,any_blanks ? RELATIVE_DEDENT_WITH_BLANK_PENALTY : RELATIVE_DEDENT_PENALTY,18,"			s->penalty += any_blanks ?
				RELATIVE_DEDENT_WITH_BLANK_PENALTY :
				RELATIVE_DEDENT_PENALTY;"
implicit_predicate,xdiffi.c,810,+,-,"while (1){
    if (g.end == g.start)
        goto next;

    do{
        groupsize = g.end - g.start;
        end_matching_other = -1;
        while (!group_slide_up(xdf, &g))
            if (group_previous(xdfo, &go))
                BUG(""group sync broken sliding up"");
        earliest_end = g.end;
        if (go.end > go.start)
            end_matching_other = g.end;

        while (1){
            if (group_slide_down(xdf, &g))
                break;

            if (group_next(xdfo, &go))
                BUG(""group sync broken sliding down"");

            if (go.end > go.start)
                end_matching_other = g.end;
        }
    } while (groupsize != g.end - g.start);
    if (g.end == earliest_end){
    }else
        if (end_matching_other != -1){
            while (go.end == go.start){
                if (group_slide_up(xdf, &g))
                    BUG(""match disappeared"");

                if (group_previous(xdfo, &go))
                    BUG(""group sync broken sliding to match"");
            }
        }else
            if (flags & XDF_INDENT_HEURISTIC){
                long shift, best_shift = -1;
                struct split_score best_score;
                shift = earliest_end;
                if (g.end - groupsize - 1 > shift)
                    shift = g.end - groupsize - 1;

                if (g.end - INDENT_HEURISTIC_MAX_SLIDING > shift)
                    shift = g.end - INDENT_HEURISTIC_MAX_SLIDING;

                for (;shift <= g.end;shift++){
                    struct split_measurement m;
                    struct split_score score = {0, 0};
                    measure_split(xdf, shift, &m);
                    score_add_split(&m, &score);
                    measure_split(xdf, shift - groupsize, &m);
                    score_add_split(&m, &score);
                    if (best_shift == -1 || score_cmp(&score, &best_score) <= 0){
                        best_score.effective_indent = score.effective_indent;
                        best_score.penalty = score.penalty;
                        best_shift = shift;
                    }
                }
                while (g.end > best_shift){
                    if (group_slide_up(xdf, &g))
                        BUG(""best shift unreached"");

                    if (group_previous(xdfo, &go))
                        BUG(""group sync broken sliding to blank line"");
                }
            }

    next:
    if (group_next(xdf, &g))
        break;
    if (group_next(xdfo, &go))
        BUG(""group sync broken moving to next group"");
}
",,
implicit_predicate,xdiffi.c,848,+,-,"while (1){
    if (group_slide_down(xdf, &g))
        break;

    if (group_next(xdfo, &go))
        BUG(""group sync broken sliding down"");

    if (go.end > go.start)
        end_matching_other = g.end;
}
",,
implicit_predicate,xdiffi.c,951,+,-,"for (l1 = i1;rchg1[i1 - 1];i1--);

",,
implicit_predicate,xdiffi.c,952,+,-,"for (l2 = i2;rchg2[i2 - 1];i2--);

",,
implicit_predicate,xdiffi.c,1058,-,+,,19,	emit_func_t ef = xecfg->hunk_func ? xdl_call_hunk_func : xdl_emit_diff;
implicit_predicate,xemit.c,141,-,+,,8,	buf = func_line ? func_line->buf : dummy;
implicit_predicate,xemit.c,142,-,+,,9,	size = func_line ? sizeof(func_line->buf) : sizeof(dummy);
implicit_predicate,xhistogram.c,220,+,-,"if (should_break)
    break;
",,
implicit_predicate,xhistogram.c,286,+,-,"if (scanA(&index, line1, count1))
    goto cleanup;
",,
implicit_predicate,xhistogram.c,320,+,-,"while (count2--)
    env->xdf2.rchg[line2++ - 1] = 1;
",,
implicit_predicate,xhistogram.c,324,+,-,"while (count1--)
    env->xdf1.rchg[line1++ - 1] = 1;
",,
implicit_predicate,xhistogram.c,333,+,-,"if (lcs_found)
    result = fall_back_to_classic_diff(xpp, env, line1, count1, line2, count2);
else{
    if (lcs.begin1 == 0 && lcs.begin2 == 0){
        while (count1--)
            env->xdf1.rchg[line1++ - 1] = 1;
        while (count2--)
            env->xdf2.rchg[line2++ - 1] = 1;
        result = 0;
    }else{
        result = histogram_diff(xpp, env, line1, lcs.begin1 - line1, line2, lcs.begin2 - line2);
        if (result)
            goto out;

        count1 = LINE_END(1) - lcs.end1;
        line1 = lcs.end1 + 1;
        count2 = LINE_END(2) - lcs.end2;
        line2 = lcs.end2 + 1;
        goto redo;
    }
}
",,
implicit_predicate,xhistogram.c,337,+,-,"while (count1--)
    env->xdf1.rchg[line1++ - 1] = 1;
",,
implicit_predicate,xhistogram.c,339,+,-,"while (count2--)
    env->xdf2.rchg[line2++ - 1] = 1;
",,
implicit_predicate,xhistogram.c,346,+,-,"if (result)
    goto out;
",,
implicit_predicate,xmerge.c,117,+,+,use_orig ? xe->xdf1.recs : xe->xdf2.recs,10,	recs = (use_orig ? xe->xdf1.recs : xe->xdf2.recs) + i;
implicit_predicate,xmerge.c,125,+,-,"if (add_nl){
    i = recs[count - 1]->size;
    if (i == 0 || recs[count - 1]->ptr[i - 1] != '\n'){
        if (needs_cr){
            if (dest)
                dest[size] = '\r';

            size++;
        }
        if (dest)
            dest[size] = '\n';

        size++;
    }
}
",,
implicit_predicate,xmerge.c,128,+,-,"if (needs_cr){
    if (dest)
        dest[size] = '\r';

    size++;
}
",,
implicit_predicate,xmerge.c,186,+,+,m->i1 ? m->i1 - 1 : 0,37,"	needs_cr = is_eol_crlf(&xe1->xdf2, m->i1 ? m->i1 - 1 : 0);"
implicit_predicate,xmerge.c,187,+,-,"if (needs_cr)
    needs_cr = is_eol_crlf(&xe2->xdf2, m->i2 ? m->i2 - 1 : 0);
",,
implicit_predicate,xmerge.c,188,+,+,m->i2 ? m->i2 - 1 : 0,38,"		needs_cr = is_eol_crlf(&xe2->xdf2, m->i2 ? m->i2 - 1 : 0);"
implicit_predicate,xmerge.c,190,+,-,"if (needs_cr)
    needs_cr = is_eol_crlf(&xe1->xdf1, 0);
",,
implicit_predicate,xmerge.c,202,-,+,,22,	int marker1_size = (name1 ? strlen(name1) + 1 : 0);
implicit_predicate,xmerge.c,203,-,+,,22,	int marker2_size = (name2 ? strlen(name2) + 1 : 0);
implicit_predicate,xmerge.c,204,-,+,,22,	int marker3_size = (name3 ? strlen(name3) + 1 : 0);
implicit_predicate,xmerge.c,212,-,+,,10,			      dest ? dest + size : NULL);
implicit_predicate,xmerge.c,219,+,-,"if (marker1_size){
    dest[size] = ' ';
    memcpy(dest + size + 1, name1, marker1_size - 1);
    size += marker1_size;
}
",,
implicit_predicate,xmerge.c,224,+,-,"if (needs_cr)
    dest[size++] = '\r';
",,
implicit_predicate,xmerge.c,231,-,+,,10,			      dest ? dest + size : NULL);
implicit_predicate,xmerge.c,240,+,-,"if (marker3_size){
    dest[size] = ' ';
    memcpy(dest + size + 1, name3, marker3_size - 1);
    size += marker3_size;
}
",,
implicit_predicate,xmerge.c,245,+,-,"if (needs_cr)
    dest[size++] = '\r';
",,
implicit_predicate,xmerge.c,250,-,+,,11,				      dest ? dest + size : NULL);
implicit_predicate,xmerge.c,258,+,-,"if (needs_cr)
    dest[size++] = '\r';
",,
implicit_predicate,xmerge.c,265,-,+,,10,			      dest ? dest + size : NULL);
implicit_predicate,xmerge.c,271,+,-,"if (marker2_size){
    dest[size] = ' ';
    memcpy(dest + size + 1, name2, marker2_size - 1);
    size += marker2_size;
}
",,
implicit_predicate,xmerge.c,276,+,-,"if (needs_cr)
    dest[size++] = '\r';
",,
implicit_predicate,xmerge.c,301,+,-,"if (m->mode & 3){
    size += xdl_recs_copy(xe1, i, m->i1 - i, 0, 0, dest ? dest + size : NULL);
    if (m->mode & 1){
        int needs_cr = is_cr_needed(xe1, xe2, m);
        size += xdl_recs_copy(xe1, m->i1, m->chg1, needs_cr, (m->mode & 2), dest ? dest + size : NULL);
    }
    if (m->mode & 2)
        size += xdl_recs_copy(xe2, m->i2, m->chg2, 0, 0, dest ? dest + size : NULL);
}else
    continue;
",,
implicit_predicate,xmerge.c,304,-,+,,12,					      dest ? dest + size : NULL);
implicit_predicate,xmerge.c,306,+,-,"if (m->mode & 1){
    int needs_cr = is_cr_needed(xe1, xe2, m);
    size += xdl_recs_copy(xe1, m->i1, m->chg1, needs_cr, (m->mode & 2), dest ? dest + size : NULL);
}
",,
implicit_predicate,xmerge.c,310,-,+,,13,						      dest ? dest + size : NULL);
implicit_predicate,xmerge.c,313,+,-,"if (m->mode & 2)
    size += xdl_recs_copy(xe2, m->i2, m->chg2, 0, 0, dest ? dest + size : NULL);
",,
implicit_predicate,xmerge.c,315,-,+,,13,						      dest ? dest + size : NULL);
implicit_predicate,xmerge.c,321,-,+,,10,			      dest ? dest + size : NULL);
implicit_predicate,xmerge.c,340,+,-,"if (m->mode)
    continue;
",,
implicit_predicate,xmerge.c,373,+,-,"if (m->mode)
    continue;
",,
implicit_predicate,xmerge.c,434,+,-,"while (size--)
    if (isalnum((unsigned char)*(ptr++)))
        return 1;
",,
implicit_predicate,xmerge.c,442,+,-,"for (;chg;chg--, i++)
    if (line_contains_alnum(xe->xdf2.recs[i]->ptr, xe->xdf2.recs[i]->size))
        return 1;
",,
implicit_predicate,xmerge.c,555,+,-,"if (xdl_append_merge(&c, 1, i0, chg0, i1, chg1, i2, chg2)){
    xdl_cleanup_merge(changes);
    return -1;
}
",,
implicit_predicate,xmerge.c,570,+,-,"if (xdl_append_merge(&c, 2, i0, chg0, i1, chg1, i2, chg2)){
    xdl_cleanup_merge(changes);
    return -1;
}
",,
implicit_predicate,xmerge.c,605,+,-,"if (xdl_append_merge(&c, 0, i0, chg0, i1, chg1, i2, chg2)){
    xdl_cleanup_merge(changes);
    return -1;
}
",,
implicit_predicate,xmerge.c,629,+,-,"if (xdl_append_merge(&c, 1, i0, chg0, i1, chg1, i2, chg2)){
    xdl_cleanup_merge(changes);
    return -1;
}
",,
implicit_predicate,xmerge.c,645,+,-,"if (xdl_append_merge(&c, 2, i0, chg0, i1, chg1, i2, chg2)){
    xdl_cleanup_merge(changes);
    return -1;
}
",,
implicit_predicate,xpatience.c,105,+,-,"while (map->entries[index].line1){
    if (map->entries[index].hash != record->ha){
        if (++index >= map->alloc)
            index = 0;

        continue;
    }
    if (pass == 2)
        map->has_matches = 1;

    if (pass == 1 || map->entries[index].line2)
        map->entries[index].line2 = NON_UNIQUE;
    else
        map->entries[index].line2 = line;

    return;
}
",,
implicit_predicate,xpatience.c,154,+,-,"while (count1--)
    insert_record(xpp, line1++, result, 1);
",,
implicit_predicate,xpatience.c,158,+,-,"while (count2--)
    insert_record(xpp, line2++, result, 2);
",,
implicit_predicate,xpatience.c,219,+,-,"if (entry->anchor){
    anchor_i = i;
    longest = anchor_i + 1;
}else
    if (i == longest){
        longest++;
    }
",,
implicit_predicate,xpatience.c,332,+,-,"while (count2--)
    env->xdf2.rchg[line2++ - 1] = 1;
",,
implicit_predicate,xpatience.c,336,+,-,"while (count1--)
    env->xdf1.rchg[line1++ - 1] = 1;
",,
implicit_predicate,xpatience.c,348,+,-,"while (count1--)
    env->xdf1.rchg[line1++ - 1] = 1;
",,
implicit_predicate,xpatience.c,350,+,-,"while (count2--)
    env->xdf2.rchg[line2++ - 1] = 1;
",,
implicit_predicate,xpatience.c,357,+,-,"if (result)
    goto out;
",,
implicit_predicate,xprepare.c,381,-,+,,8,		nm = rcrec ? rcrec->len2 : 0;
implicit_predicate,xprepare.c,389,-,+,,8,		nm = rcrec ? rcrec->len1 : 0;
implicit_predicate,xutils.c,163,+,-,"if (complete)
    s--;
",,
implicit_predicate,xutils.c,259,+,-,"if (cr_at_eol_only){
    if (*ptr == '\r' && (ptr + 1 < top && ptr[1] == '\n'))
        continue;
}else
    if (XDL_ISSPACE(*ptr)){
        const char* ptr2 = ptr;
        int at_eol;
        while (ptr + 1 < top && XDL_ISSPACE(ptr[1]) && ptr[1] != '\n')
            ptr++;
        at_eol = (top <= ptr + 1 || ptr[1] == '\n');
        if (flags & XDF_IGNORE_WHITESPACE);

        else
            if (flags & XDF_IGNORE_WHITESPACE_CHANGE && !at_eol){
                ha += (ha << 5);
                ha ^= (unsigned long )' ';
            }else
                if (flags & XDF_IGNORE_WHITESPACE_AT_EOL && !at_eol){
                    while (ptr2 != ptr + 1){
                        ha += (ha << 5);
                        ha ^= (unsigned long )*ptr2;
                        ptr2++;
                    }
                }

        continue;
    }
",,
implicit_predicate,xutils.c,317,+,+,bits ? bits : 1,9,	return bits ? bits: 1;
implicit_predicate,xutils.c,333,+,-,"if (*ptr)
    for (;*ptr;ptr++, str++)
        *str = *ptr;
else
    *str++ = '0';
",,
implicit_predicate,xutils.c,334,+,-,"for (;*ptr;ptr++, str++)
    *str = *ptr;
",,
implicit_predicate,xutils.c,353,+,+,c1 ? s1 : s1 - 1,30,"	nb += xdl_num_out(buf + nb, c1 ? s1: s1 - 1);"
implicit_predicate,xutils.c,365,+,+,c2 ? s2 : s2 - 1,30,"	nb += xdl_num_out(buf + nb, c2 ? s2: s2 - 1);"
implicit_predicate,xutils.c,398,+,+,c1 ? s1 : s1 - 1,6,"			  c1 ? s1 : s1 - 1, c1,"
implicit_predicate,xutils.c,399,+,+,c2 ? s2 : s2 - 1,6,"			  c2 ? s2 : s2 - 1, c2,"
